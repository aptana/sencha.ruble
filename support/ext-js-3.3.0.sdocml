<?xml version="1.0" encoding="UTF-8"?>
<!-- Aptana Studio support for the ExtJS 3.3.0 JavaScript Libary -->
<javascript><class superclass="Object" type="Ext.Loader"><description/><constructors/><properties/><methods><method name="load" scope="instance"><description>Loads a given set of .js files. Calls the callback function when all files have been loaded
Set preserveOrder to true to ensure non-parallel loading of files if load order is important</description></method></methods></class><class superclass="Object" type="Ext.dd.PanelProxy"><description>A custom drag proxy implementation specific to Ext.Panels. This class is primarily used internally
for the Panel's drag drop implementation, and should never need to be created directly.</description><constructors/><properties/><methods><method name="getEl" scope="instance"><description>Gets the proxy's element</description></method><method name="getGhost" scope="instance"><description>Gets the proxy's ghost element</description></method><method name="getProxy" scope="instance"><description>Gets the proxy's element</description></method><method name="hide" scope="instance"><description>Hides the proxy</description></method><method name="moveProxy" scope="instance"><description>Moves the proxy to a different position in the DOM.  This is typically called while dragging the Panel
to keep the proxy sync'd to the Panel's location.</description></method><method name="show" scope="instance"><description>Shows the proxy</description></method></methods></class><class superclass="Ext.Toolbar" type="Ext.PagingToolbar"><description>As the amount of records increases, the time required for the browser to render
them increases. Paging is used to reduce the amount of data exchanged with the client.
Note: if there are more records/rows than can be viewed in the available screen area, vertical
scrollbars will be added.
Paging is typically handled on the server side (see exception below). The client sends
parameters to the server side, which the server needs to interpret and then respond with the
approprate data.
Ext.PagingToolbar is a specialized toolbar that is bound to a Ext.data.Store
and provides automatic paging control. This Component loads blocks
of data into the store by passing paramNames used for
paging criteria.
PagingToolbar is typically used as one of the Grid's toolbars:
Ext.QuickTips.init(); // to display button quicktips

var myStore = new Ext.data.Store({
    reader: new Ext.data.JsonReader({
        totalProperty: 'results', 
        ...
    }),
    ...
});

var myPageSize = 25;  // server script should only send back 25 items at a time

var grid = new Ext.grid.GridPanel({
    ...
    store: myStore,
    bbar: new Ext.PagingToolbar({
        store: myStore,       // grid and PagingToolbar using same store
        displayInfo: true,
        pageSize: myPageSize,
        prependButtons: true,
        items: [
            'text 1'
        ]
    })
});
To use paging, pass the paging requirements to the server when the store is first loaded.
store.load({
    params: {
        // specify params for the first page load if using paging
        start: 0,          
        limit: myPageSize,
        // other params
        foo:   'bar'
    }
});
If using store's autoLoad configuration:
var myStore = new Ext.data.Store({
    autoLoad: {params:{start: 0, limit: 25}},
    ...
});
The packet sent back from the server would have this form:
{
    &quot;success&quot;: true,
    &quot;results&quot;: 2000, 
    &quot;rows&quot;: [ // *Note: this must be an Array 
        { &quot;id&quot;:  1, &quot;name&quot;: &quot;Bill&quot;, &quot;occupation&quot;: &quot;Gardener&quot; },
        { &quot;id&quot;:  2, &quot;name&quot;:  &quot;Ben&quot;, &quot;occupation&quot;: &quot;Horticulturalist&quot; },
        ...
        { &quot;id&quot;: 25, &quot;name&quot;:  &quot;Sue&quot;, &quot;occupation&quot;: &quot;Botanist&quot; }
    ]
}
Paging with Local Data
Paging can also be accomplished with local data using extensions:

Ext.ux.data.PagingStore
Paging Memory Proxy (examples/ux/PagingMemoryProxy.js)
</description><constructors/><properties/><methods><method name="add" scope="instance"><description>Adds element(s) to the toolbar -- this function takes a variable number of
arguments of mixed type and adds them to the toolbar.
Note: See the notes within Ext.Container.add.</description></method><method name="addButton" scope="instance"><description>Adds a button (or buttons). See Ext.Button for more info on the config.
Note: See the notes within Ext.Container.add.</description></method><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addDom" scope="instance"><description>Adds a new element to the toolbar from the passed Ext.DomHelper config
Note: See the notes within Ext.Container.add.</description></method><method name="addElement" scope="instance"><description>Adds any standard HTML element to the toolbar
Note: See the notes within Ext.Container.add.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addField" scope="instance"><description>Adds a dynamically rendered Ext.form field (TextField, ComboBox, etc). Note: the field should not have
been rendered yet. For a field that has already been rendered, use addElement.
Note: See the notes within Ext.Container.add.</description></method><method name="addFill" scope="instance"><description>Forces subsequent additions into the float:right toolbar
Note: See the notes within Ext.Container.add.</description></method><method name="addItem" scope="instance"><description>Adds any Toolbar.Item or subclass
Note: See the notes within Ext.Container.add.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="addSeparator" scope="instance"><description>Adds a separator
Note: See the notes within Ext.Container.add.</description></method><method name="addSpacer" scope="instance"><description>Adds a spacer element
Note: See the notes within Ext.Container.add.</description></method><method name="addText" scope="instance"><description>Adds text to the toolbar
Note: See the notes within Ext.Container.add.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bind" scope="instance"><description>Binds the paging toolbar to the specified Ext.data.Store (deprecated)</description></method><method name="bindStore" scope="instance"><description>Binds the paging toolbar to the specified Ext.data.Store</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cascade" scope="instance"><description>Cascades down the component/container heirarchy from this component (called first), calling the specified function with
each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the cascade is stopped on that branch.</description></method><method name="changePage" scope="instance"><description>Change the active page</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="doLayout" scope="instance"><description>Force this container's layout to be recalculated. A call to this function is required after adding a new component
to an already rendered container, or possibly after changing sizing/position properties of child components.</description></method><method name="doRefresh" scope="instance"><description>Refresh the current page, has the same effect as clicking the 'refresh' button.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="find" scope="instance"><description>Find a component under this container at any level by property</description></method><method name="findBy" scope="instance"><description>Find a component under this container at any level by a custom function. If the passed function returns
true, the component will be included in the results. The passed function is called with the arguments (component, this container).</description></method><method name="findById" scope="instance"><description>Find a component under this container at any level by id</description></method><method name="findByType" scope="instance"><description>Find a component under this container at any level by xtype or class</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="get" scope="instance"><description>Get a component contained by this container (alias for items.get(key))</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getComponent" scope="instance"><description>Examines this container's items property
and gets a direct child component of this container.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getLayout" scope="instance"><description>Returns the layout currently in use by the container.  If the container does not currently have a layout
set, a default Ext.layout.ContainerLayout will be created and set as the container's layout.</description></method><method name="getLayoutTarget" scope="instance"><description>Returns the Element to be used to contain the child Components of this Container.
An implementation is provided which returns the Container's Element, but
if there is a more complex structure to a Container, this may be overridden to return
the element into which the layout renders child Components.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="insert" scope="instance"><description>Inserts a Component into this Container at a specified index. Fires the
beforeadd event before inserting, then fires the add event after the
Component has been inserted.</description></method><method name="insertButton" scope="instance"><description>Inserts any Ext.Toolbar.Item/Ext.Button at the specified index.
Note: See the notes within Ext.Container.add.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="moveFirst" scope="instance"><description>Move to the first page, has the same effect as clicking the 'first' button.</description></method><method name="moveLast" scope="instance"><description>Move to the last page, has the same effect as clicking the 'last' button.</description></method><method name="moveNext" scope="instance"><description>Move to the next page, has the same effect as clicking the 'next' button.</description></method><method name="movePrevious" scope="instance"><description>Move to the previous page, has the same effect as clicking the 'previous' button.</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="remove" scope="instance"><description>Removes a component from this container.  Fires the beforeremove event before removing, then fires
the remove event after the component has been removed.</description></method><method name="removeAll" scope="instance"><description>Removes all components from this container.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="unbind" scope="instance"><description>Unbinds the paging toolbar from the specified Ext.data.Store (deprecated)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method></methods></class><class superclass="Ext.chart.CartesianChart" type="Ext.chart.BarChart"><description/><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bindStore" scope="instance"><description>Changes the data store bound to this chart and refreshes it.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setSeriesStyles" scope="instance"><description>Sets the styles on all series in the Chart.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setStyle" scope="instance"><description>Sets a single style value on the Chart instance.</description></method><method name="setStyles" scope="instance"><description>Resets all styles on the Chart instance.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method></methods></class><class superclass="Ext.dd.DragDrop" type="Ext.dd.DDTarget"><description>A DragDrop implementation that does not move, but can be a drop
target.  You would get the same result by simply omitting implementation
for the event callbacks, but this way we reduce the processing cost of the
event listener and the callbacks.</description><constructors/><properties/><methods><method name="addToGroup" scope="instance"><description>Add this instance to a group of related drag/drop objects.  All
instances belong to at least one group, and can belong to as many
groups as needed.</description></method><method name="applyConfig" scope="instance"><description>Applies the configuration parameters that were passed into the constructor.
This is supposed to happen at each level through the inheritance chain.  So
a DDProxy implentation will execute apply config on DDProxy, DD, and
DragDrop in order to get all of the parameters that are available in
each object.</description></method><method name="constrainTo" scope="instance"><description>Initializes the drag drop object's constraints to restrict movement to a certain element.
Usage:
 var dd = new Ext.dd.DDProxy(&quot;dragDiv1&quot;, &quot;proxytest&quot;,
                { dragElId: &quot;existingProxyDiv&quot; });
 dd.startDrag = function(){
     this.constrainTo(&quot;parent-id&quot;);
 };
Or you can initalize it using the Ext.Element object:
 Ext.get(&quot;dragDiv1&quot;).initDDProxy(&quot;proxytest&quot;, {dragElId: &quot;existingProxyDiv&quot;}, {
     startDrag : function(){
         this.constrainTo(&quot;parent-id&quot;);
     }
 });</description></method><method name="getEl" scope="instance"><description>Returns a reference to the linked element</description></method><method name="init" scope="instance"><description>Sets up the DragDrop object.  Must be called in the constructor of any
Ext.dd.DragDrop subclass</description></method><method name="initTarget" scope="instance"><description>Initializes Targeting functionality only... the object does not
get a mousedown handler.</description></method><method name="isLocked" scope="instance"><description>Returns true if this instance is locked, or the drag drop mgr is locked
(meaning that all drag/drop is disabled on the page.)</description></method><method name="lock" scope="instance"><description>Lock this instance</description></method><method name="onAvailable" scope="instance"><description>Override the onAvailable method to do what is needed after the initial
position was determined.</description></method><method name="removeFromGroup" scope="instance"><description>Remove's this instance from the supplied interaction group</description></method><method name="setPadding" scope="instance"><description>Configures the padding for the target zone in px.  Effectively expands
(or reduces) the virtual object size for targeting calculations.
Supports css-style shorthand; if only one parameter is passed, all sides
will have that padding, and if only two are passed, the top and bottom
will have the first param, the left and right the second.</description></method><method name="toString" scope="instance"><description>toString method</description></method><method name="unlock" scope="instance"><description>Unlock this instace</description></method><method name="unreg" scope="instance"><description>Remove all drag and drop hooks for this element</description></method></methods></class><class superclass="Ext.util.Observable" type="Ext.Updater"><description>Provides AJAX-style update capabilities for Element objects.  Updater can be used to update
an Ext.Element once, or you can use startAutoRefresh to set up an auto-updating
Element on a specific interval.
Usage:
var el = Ext.get(&quot;foo&quot;); // Get Ext.Element object
var mgr = el.getUpdater();
mgr.update({
        url: &quot;http://myserver.com/index.php&quot;,
        params: {
            param1: &quot;foo&quot;,
            param2: &quot;bar&quot;
        }
});
...
mgr.formUpdate(&quot;myFormId&quot;, &quot;http://myserver.com/index.php&quot;);

// or directly (returns the same Updater instance)
var mgr = new Ext.Updater(&quot;myElementId&quot;);
mgr.startAutoRefresh(60, &quot;http://myserver.com/index.php&quot;);
mgr.on(&quot;update&quot;, myFcnNeedsToKnow);

// short handed call directly from the element object
Ext.get(&quot;foo&quot;).load({
        url: &quot;bar.php&quot;,
        scripts: true,
        params: &quot;param1=foo&amp;param2=bar&quot;,
        text: &quot;Loading Foo...&quot;
});</description><constructors/><properties/><methods><method name="Updater.updateElement" scope="instance"><description>Static convenience method. This method is deprecated in favor of el.load({url:'foo.php', ...}).
Usage:
Ext.Updater.updateElement(&quot;my-div&quot;, &quot;stuff.php&quot;);</description></method><method name="abort" scope="instance"><description>Aborts the currently executing transaction, if any.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="formUpdate" scope="instance"><description>Performs an asynchronous form post, updating this element with the response. If the form has the attribute
enctype=&quot;multipart/form-data&quot;, it assumes it's a file upload.
Uses this.sslBlankUrl for SSL file uploads to prevent IE security warning.
File uploads are not performed using normal &quot;Ajax&quot; techniques, that is they are not
performed using XMLHttpRequests. Instead the form is submitted in the standard manner with the
DOM &lt;form&gt; element temporarily modified to have its
target set to refer
to a dynamically generated, hidden &lt;iframe&gt; which is inserted into the document
but removed after the return data has been gathered.
Be aware that file upload packets, sent with the content type multipart/form-data
and some server technologies (notably JEE) may require some custom processing in order to
retrieve parameter names and parameter values from the packet content.</description></method><method name="getDefaultRenderer" scope="instance"><description>This is an overrideable method which returns a reference to a default
renderer class if none is specified when creating the Ext.Updater.
Defaults to Ext.Updater.BasicRenderer</description></method><method name="getEl" scope="instance"><description>Get the Element this Updater is bound to</description></method><method name="getRenderer" scope="instance"><description>Returns the current content renderer for this Updater. See Ext.Updater.BasicRenderer.render for more details.</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="isAutoRefreshing" scope="instance"><description>Returns true if the Updater is currently set to auto refresh its content (see startAutoRefresh), otherwise false.</description></method><method name="isUpdating" scope="instance"><description>Returns true if an update is in progress, otherwise false.</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="refresh" scope="instance"><description>Refresh the element with the last used url or defaultUrl. If there is no url, it returns immediately</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setDefaultUrl" scope="instance"><description>Sets the default URL used for updates.</description></method><method name="setRenderer" scope="instance"><description>Sets the content renderer for this Updater. See Ext.Updater.BasicRenderer.render for more details.</description></method><method name="showLoading" scope="instance"><description>Display the element's &quot;loading&quot; state. By default, the element is updated with indicatorText. This
method may be overridden to perform a custom action while this Updater is actively updating its contents.</description></method><method name="startAutoRefresh" scope="instance"><description>Set this element to auto refresh.  Can be canceled by calling stopAutoRefresh.</description></method><method name="stopAutoRefresh" scope="instance"><description>Stop auto refresh on this element.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Performs an asynchronous request, updating this element with the response.
If params are specified it uses POST, otherwise it uses GET.
Note: Due to the asynchronous nature of remote server requests, the Element
will not have been fully updated when the function returns. To post-process the returned
data, use the callback option, or an update event handler.</description></method></methods></class><class superclass="Ext.form.Action" type="Ext.form.Action.Submit"><description>A class which handles submission of data from Forms
and processes the returned response.
Instances of this class are only created by a Form when
submitting.
Response Packet Criteria
A response packet may contain:

success property : Boolean
The success property is required.
errors property : Object
The errors property,
which is optional, contains error messages for invalid fields.

JSON Packets
By default, response packets are assumed to be JSON, so a typical response
packet may look like this:{
    success: false,
    errors: {
        clientCode: &quot;Client not found&quot;,
        portOfLoading: &quot;This field must not be null&quot;
    }
}
Other data may be placed into the response for processing by the Ext.form.BasicForm's callback
or event handler methods. The object decoded from this JSON is available in the
result property.
Alternatively, if an errorReader is specified as an XmlReader:errorReader: new Ext.data.XmlReader({
            record : 'field',
            success: '@success'
        }, [
            'id', 'msg'
        ]
    )
then the results may be sent back in XML format:&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;message success=&quot;false&quot;&gt;
&lt;errors&gt;
    &lt;field&gt;
        &lt;id&gt;clientCode&lt;/id&gt;
        &lt;msg&gt;&lt;![CDATA[Code not found. &lt;br /&gt;&lt;i&gt;This is a test validation message from the server &lt;/i&gt;]]&gt;&lt;/msg&gt;
    &lt;/field&gt;
    &lt;field&gt;
        &lt;id&gt;portOfLoading&lt;/id&gt;
        &lt;msg&gt;&lt;![CDATA[Port not found. &lt;br /&gt;&lt;i&gt;This is a test validation message from the server &lt;/i&gt;]]&gt;&lt;/msg&gt;
    &lt;/field&gt;
&lt;/errors&gt;
&lt;/message&gt;
Other elements may be placed into the response XML for processing by the Ext.form.BasicForm's callback
or event handler methods. The XML document is available in the errorReader's xmlData property.</description><constructors/><properties/><methods/></class><class superclass="Object" type="Ext.layout.BorderLayout.Region"><description>This is a region of a BorderLayout that acts as a subcontainer
within the layout.  Each region has its own layout that is
independent of other regions and the containing BorderLayout, and can be any of the
valid Ext layout types.
Region size is managed automatically and cannot be changed by the user -- for
resizable regions, see Ext.layout.BorderLayout.SplitRegion.</description><constructors/><properties/><methods><method name="getMargins" scope="instance"><description>Returns the current margins for this region.  If the region is collapsed, the
cmargins (collapsed margins) value will be returned, otherwise the
margins value will be returned.</description></method><method name="getMinHeight" scope="instance"><description>Returns the minimum allowable height for this region.</description></method><method name="getMinWidth" scope="instance"><description>Returns the minimum allowable width for this region.</description></method><method name="getSize" scope="instance"><description>Returns the current size of this region.  If the region is collapsed, the size of the
collapsedEl will be returned, otherwise the size of the region's panel will be returned.</description></method><method name="isVisible" scope="instance"><description>True if this region is currently visible, else false.</description></method><method name="setPanel" scope="instance"><description>Sets the specified panel as the container element for this region.</description></method><method name="slideIn" scope="instance"><description>If this Region is floatable, and this Region has been slid into floating visibility, then this method slides
this region back into its collapsed state.</description></method><method name="slideOut" scope="instance"><description>If this Region is floatable, this method slides this Region into full visibility over the top
of the center Region where it floats until either slideIn is called, or other regions of the layout
are clicked, or the mouse exits the Region.</description></method></methods></class><class superclass="Ext.FlashComponent" type="Ext.chart.Chart"><description>The Ext.chart package provides the capability to visualize data with flash based charting.
Each chart binds directly to an Ext.data.Store enabling automatic updates of the chart.
To change the look and feel of a chart, see the chartStyle and extraStyle config options.</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bindStore" scope="instance"><description>Changes the data store bound to this chart and refreshes it.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setSeriesStyles" scope="instance"><description>Sets the styles on all series in the Chart.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setStyle" scope="instance"><description>Sets a single style value on the Chart instance.</description></method><method name="setStyles" scope="instance"><description>Resets all styles on the Chart instance.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method></methods></class><class superclass="Object" type="Ext.slider.Thumb"><description>Represents a single thumb element on a Slider. This would not usually be created manually and would instead
be created internally by an Ext.Slider.</description><constructors/><properties/><methods><method name="disable" scope="instance"><description>Disables the thumb if it is currently enabled</description></method><method name="enable" scope="instance"><description>Enables the thumb if it is currently disabled</description></method><method name="initEvents" scope="instance"><description>Sets up an Ext.dd.DragTracker for this thumb</description></method><method name="render" scope="instance"><description>Renders the thumb into a slider</description></method></methods></class><class superclass="Ext.form.Field" type="Ext.form.CheckboxGroup"><description>A grouping container for Ext.form.Checkbox controls.
Sample usage:
var myCheckboxGroup = new Ext.form.CheckboxGroup({
    id:'myGroup',
    xtype: 'checkboxgroup',
    fieldLabel: 'Single Column',
    itemCls: 'x-check-group-alt',
    // Put all controls in a single column with width 100%
    columns: 1,
    items: [
        {boxLabel: 'Item 1', name: 'cb-col-1'},
        {boxLabel: 'Item 2', name: 'cb-col-2', checked: true},
        {boxLabel: 'Item 3', name: 'cb-col-3'}
    ]
});</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="clearInvalid" scope="instance"><description>Clear any invalid styles/messages for this field</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getActiveError" scope="instance"><description>Gets the active error message for this field.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getErrors" scope="instance"><description>Runs CheckboxGroup's validations and returns an array of any errors. The only error by default
is if allowBlank is set to true and no items are checked.</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getName" scope="instance"><description>Returns the name or hiddenName
attribute of the field if available.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getValue" scope="instance"><description>Gets an array of the selected Ext.form.Checkbox in the group.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isDirty" scope="instance"><description>Returns true if the value of this Field has been changed from its original value.
Will return false if the field is disabled or has not been rendered yet.
Note that if the owning form was configured with
Ext.form.BasicForm.trackResetOnLoad
then the original value is updated when the values are loaded by
Ext.form.BasicForm.setValues.</description></method><method name="isValid" scope="instance"><description>Returns whether or not the field value is currently valid by
validating the processed value
of the field. Note: disabled fields are ignored.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="markInvalid" scope="instance"><description>Display an error message associated with this field, using msgTarget to determine how to
display the message and applying invalidClass to the field's UI element.
Note: this method does not cause the Field's validate method to return false
if the value does pass validation. So simply marking a Field as invalid will not prevent
submission of forms submitted with the Ext.form.Action.Submit.clientValidation option set.
invalid.</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="processValue" scope="instance"><description>This method should only be overridden if necessary to prepare raw values
for validation (see validate and isValid).  This method
is expected to return the processed value for the field which will
be used for validation (see validateValue method).</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="reset" scope="instance"><description>Resets the current field value to the originally loaded value and clears any validation messages.
See Ext.form.BasicForm.trackResetOnLoad</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setActiveError" scope="instance"><description>Sets the current activeError to the given string. Fires the 'invalid' event.
This does not set up the error icon, only sets the message and fires the event. To show the error icon,
use markInvalid instead, which calls this method internally</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setReadOnly" scope="instance"><description>Sets the read only state of this field.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setValue" scope="instance"><description>Set the value(s) of an item or items
in the group. Examples illustrating how this method may be called:
// call with name and value
myCheckboxGroup.setValue('cb-col-1', true);
// call with an array of boolean values
myCheckboxGroup.setValue([true, false, false]);
// call with an object literal specifying item:value pairs
myCheckboxGroup.setValue({
    'cb-col-2': false,
    'cb-col-3': true
});
// use comma separated string to set items with name to true (checked)
myCheckboxGroup.setValue('cb-col-1,cb-col-3');
See Ext.form.Checkbox.setValue for additional information.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="unsetActiveError" scope="instance"><description>Clears the activeError and fires the 'valid' event. This is called internally by clearInvalid and would not
usually need to be called manually</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method><method name="validate" scope="instance"><description>Validates the field value</description></method><method name="validateValue" scope="instance"><description>Uses getErrors to build an array of validation errors. If any errors are found, markInvalid is called
with the first and false is returned, otherwise true is returned. Previously, subclasses were invited
to provide an implementation of this to process validations - from 3.2 onwards getErrors should be
overridden instead.</description></method></methods></class><class superclass="Ext.form.TextField" type="Ext.form.TriggerField"><description>Provides a convenient wrapper for TextFields that adds a clickable trigger button (looks like a combobox by default).
The trigger has no default action, so you must assign a function to implement the trigger click handler by
overriding onTriggerClick. You can create a TriggerField directly, as it renders exactly like a combobox
for which you can provide a custom implementation.  For example:
var trigger = new Ext.form.TriggerField();
trigger.onTriggerClick = myTriggerFn;
trigger.applyToMarkup('my-field');
However, in general you will most likely want to use TriggerField as the base class for a reusable component.
Ext.form.DateField and Ext.form.ComboBox are perfect examples of this.</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="clearInvalid" scope="instance"><description>Clear any invalid styles/messages for this field</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getActiveError" scope="instance"><description>Gets the active error message for this field.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getErrors" scope="instance"><description>Validates a value according to the field's validation rules and returns an array of errors
for any failing validations. Validation rules are processed in the following order:

1. Field specific validator

A validator offers a way to customize and reuse a validation specification.
If a field is configured with a validator
function, it will be passed the current field value.  The validator
function is expected to return either:

Boolean true if the value is valid (validation continues).
a String to represent the invalid message if invalid (validation halts).


2. Basic Validation

If the validator has not halted validation,
basic validation proceeds as follows:

allowBlank : (Invalid message =
emptyText)
Depending on the configuration of allowBlank, a
blank field will cause validation to halt at this step and return
Boolean true or false accordingly.  

minLength : (Invalid message =
minLengthText)
If the passed value does not satisfy the minLength
specified, validation halts.

maxLength : (Invalid message =
maxLengthText)
If the passed value does not satisfy the maxLength
specified, validation halts.



3. Preconfigured Validation Types (VTypes)

If none of the prior validation steps halts validation, a field
configured with a vtype will utilize the
corresponding VTypes validation function.
If invalid, either the field's vtypeText or
the VTypes vtype Text property will be used for the invalid message.
Keystrokes on the field will be filtered according to the VTypes
vtype Mask property.

4. Field specific regex test

If none of the prior validation steps halts validation, a field's
configured regex test will be processed.
The invalid message for this test is configured with
regexText.
</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getName" scope="instance"><description>Returns the name or hiddenName
attribute of the field if available.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getRawValue" scope="instance"><description>Returns the raw data value which may or may not be a valid, defined value.  To return a normalized value see getValue.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getValue" scope="instance"><description>Returns the normalized data value (undefined or emptyText will be returned as '').  To return the raw value see getRawValue.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isDirty" scope="instance"><description>Returns true if the value of this Field has been changed from its original value.
Will return false if the field is disabled or has not been rendered yet.
Note that if the owning form was configured with
Ext.form.BasicForm.trackResetOnLoad
then the original value is updated when the values are loaded by
Ext.form.BasicForm.setValues.</description></method><method name="isValid" scope="instance"><description>Returns whether or not the field value is currently valid by
validating the processed value
of the field. Note: disabled fields are ignored.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="markInvalid" scope="instance"><description>Display an error message associated with this field, using msgTarget to determine how to
display the message and applying invalidClass to the field's UI element.
Note: this method does not cause the Field's validate method to return false
if the value does pass validation. So simply marking a Field as invalid will not prevent
submission of forms submitted with the Ext.form.Action.Submit.clientValidation option set.
invalid.</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="onTriggerClick" scope="instance"><description>The function that should handle the trigger's click event.  This method does nothing by default
until overridden by an implementing function.  See Ext.form.ComboBox and Ext.form.DateField for
sample implementations.</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="processValue" scope="instance"><description>This method should only be overridden if necessary to prepare raw values
for validation (see validate and isValid).  This method
is expected to return the processed value for the field which will
be used for validation (see validateValue method).</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="reset" scope="instance"><description>Resets the current field value to the originally-loaded value and clears any validation messages.
Also adds emptyText and emptyClass if the
original value was blank.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="selectText" scope="instance"><description>Selects text in this field</description></method><method name="setActiveError" scope="instance"><description>Sets the current activeError to the given string. Fires the 'invalid' event.
This does not set up the error icon, only sets the message and fires the event. To show the error icon,
use markInvalid instead, which calls this method internally</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setEditable" scope="instance"><description>Allow or prevent the user from directly editing the field text.  If false is passed,
the user will only be able to modify the field using the trigger.  Will also add
a click event to the text field which will call the trigger. This method
is the runtime equivalent of setting the editable config option at config time.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setHideTrigger" scope="instance"><description>Changes the hidden status of the trigger.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setRawValue" scope="instance"><description>Sets the underlying DOM field's value directly, bypassing validation.  To set the value with validation see setValue.</description></method><method name="setReadOnly" scope="instance"><description>Setting this to true will supersede settings editable and hideTrigger.
Setting this to false will defer back to editable and hideTrigger. This method
is the runtime equivalent of setting the readOnly config option at config time.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setValue" scope="instance"><description>Sets a data value into the field and validates it.  To set the value directly without validation see setRawValue.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="unsetActiveError" scope="instance"><description>Clears the activeError and fires the 'valid' event. This is called internally by clearInvalid and would not
usually need to be called manually</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method><method name="validate" scope="instance"><description>Validates the field value</description></method><method name="validateValue" scope="instance"><description>Uses getErrors to build an array of validation errors. If any errors are found, markInvalid is called
with the first and false is returned, otherwise true is returned. Previously, subclasses were invited
to provide an implementation of this to process validations - from 3.2 onwards getErrors should be
overridden instead.</description></method></methods></class><class superclass="Ext.BoxComponent" type="Ext.Spacer"><description>Used to provide a sizable space in a layout.</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method></methods></class><class superclass="Ext.Editor" type="Ext.tree.TreeEditor"><description>Provides editor functionality for inline tree node editing.  Any valid Ext.form.Field subclass can be used
as the editor field.</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cancelEdit" scope="instance"><description>Cancels the editing process and hides the editor without persisting any changes.  The field value will be
reverted to the original starting value.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="completeEdit" scope="instance"><description>Ends the editing process, persists the changed value to the underlying field, and hides the editor.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getValue" scope="instance"><description>Gets the data value of the editor</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="realign" scope="instance"><description>Realigns the editor to the bound field based on the current alignment config value.</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setSize" scope="instance"><description>Sets the height and width of this editor.</description></method><method name="setValue" scope="instance"><description>Sets the data value of the editor</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="startEdit" scope="instance"><description>Starts the editing process and shows the editor.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="triggerEdit" scope="instance"><description>Edit the text of the passed TreeNode.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method></methods></class><class superclass="Ext.Panel" type="Ext.ButtonGroup"><description>Container for a group of buttons. Example usage:
var p = new Ext.Panel({
    title: 'Panel with Button Group',
    width: 300,
    height:200,
    renderTo: document.body,
    html: 'whatever',
    tbar: [{
        xtype: 'buttongroup',
        columns: 3,
        title: 'Clipboard',
        items: [{
            text: 'Paste',
            scale: 'large',
            rowspan: 3, iconCls: 'add',
            iconAlign: 'top',
            cls: 'x-btn-as-arrow'
        },{
            xtype:'splitbutton',
            text: 'Menu Button',
            scale: 'large',
            rowspan: 3,
            iconCls: 'add',
            iconAlign: 'top',
            arrowAlign:'bottom',
            menu: [{text: 'Menu Item 1'}]
        },{
            xtype:'splitbutton', text: 'Cut', iconCls: 'add16', menu: [{text: 'Cut Menu Item'}]
        },{
            text: 'Copy', iconCls: 'add16'
        },{
            text: 'Format', iconCls: 'add16'
        }]
    }]
});</description><constructors/><properties/><methods><method name="add" scope="instance"><description>Adds Component(s) to this Container.
Description :

Fires the beforeadd event before adding
The Container's default config values will be applied
accordingly (see defaults for details).
Fires the add event after the component has been added.

Notes :

If the Container is already rendered when add
is called, you may need to call doLayout to refresh the view which causes
any unrendered child Components to be rendered. This is required so that you can
add multiple child components if needed while only refreshing the layout
once. For example:var tb = new Ext.Toolbar();
tb.render(document.body);  // toolbar is rendered
tb.add({text:'Button 1'}); // add multiple items (defaultType for Toolbar is 'button')
tb.add({text:'Button 2'});
tb.doLayout();             // refresh the layout
Warning: Containers directly managed by the BorderLayout layout manager
may not be removed or added.  See the Notes for BorderLayout
for more details.
</description></method><method name="addButton" scope="instance"><description>Adds a button to this panel.  Note that this method must be called prior to rendering.  The preferred
approach is to add buttons via the buttons config.</description></method><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cascade" scope="instance"><description>Cascades down the component/container heirarchy from this component (called first), calling the specified function with
each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the cascade is stopped on that branch.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="collapse" scope="instance"><description>Collapses the panel body so that it becomes hidden.  Fires the beforecollapse event which will
cancel the collapse action if it returns false.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="doLayout" scope="instance"><description>Force this container's layout to be recalculated. A call to this function is required after adding a new component
to an already rendered container, or possibly after changing sizing/position properties of child components.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="expand" scope="instance"><description>Expands the panel body so that it becomes visible.  Fires the beforeexpand event which will
cancel the expand action if it returns false.</description></method><method name="find" scope="instance"><description>Find a component under this container at any level by property</description></method><method name="findBy" scope="instance"><description>Find a component under this container at any level by a custom function. If the passed function returns
true, the component will be included in the results. The passed function is called with the arguments (component, this container).</description></method><method name="findById" scope="instance"><description>Find a component under this container at any level by id</description></method><method name="findByType" scope="instance"><description>Find a component under this container at any level by xtype or class</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="get" scope="instance"><description>Get a component contained by this container (alias for items.get(key))</description></method><method name="getBottomToolbar" scope="instance"><description>Returns the toolbar from the bottom (bbar) section of the panel.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getComponent" scope="instance"><description>Examines this container's items property
and gets a direct child component of this container.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getFooterToolbar" scope="instance"><description>Returns the toolbar from the footer (fbar) section of the panel.</description></method><method name="getFrameHeight" scope="instance"><description>Returns the height in pixels of the framing elements of this panel (including any top and bottom bars and
header and footer elements, but not including the body height).  To retrieve the body height see getInnerHeight.</description></method><method name="getFrameWidth" scope="instance"><description>Returns the width in pixels of the framing elements of this panel (not including the body width).  To
retrieve the body width see getInnerWidth.</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getInnerHeight" scope="instance"><description>Returns the height in pixels of the body element (not including the height of any framing elements).
For the frame height see getFrameHeight.</description></method><method name="getInnerWidth" scope="instance"><description>Returns the width in pixels of the body element (not including the width of any framing elements).
For the frame width see getFrameWidth.</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getLayout" scope="instance"><description>Returns the layout currently in use by the container.  If the container does not currently have a layout
set, a default Ext.layout.ContainerLayout will be created and set as the container's layout.</description></method><method name="getLayoutTarget" scope="instance"><description>Returns the Element to be used to contain the child Components of this Container.
An implementation is provided which returns the Container's Element, but
if there is a more complex structure to a Container, this may be overridden to return
the element into which the layout renders child Components.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getTool" scope="instance"><description>Retrieve a tool by id.</description></method><method name="getTopToolbar" scope="instance"><description>Returns the toolbar from the top (tbar) section of the panel.</description></method><method name="getUpdater" scope="instance"><description>Get the Ext.Updater for this panel. Enables you to perform Ajax updates of this panel's body.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="insert" scope="instance"><description>Inserts a Component into this Container at a specified index. Fires the
beforeadd event before inserting, then fires the add event after the
Component has been inserted.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="load" scope="instance"><description>Loads this content panel immediately with content returned from an XHR call.</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="remove" scope="instance"><description>Removes a component from this container.  Fires the beforeremove event before removing, then fires
the remove event after the component has been removed.</description></method><method name="removeAll" scope="instance"><description>Removes all components from this container.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setIconClass" scope="instance"><description>Sets the CSS class that provides the icon image for this panel.  This method will replace any existing
icon class if one has already been set and fire the iconchange event after completion.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setTitle" scope="instance"><description>Sets the title text for the panel and optionally the icon class.
In order to be able to set the title, a header element must have been created
for the Panel. This is triggered either by configuring the Panel with a non-blank title,
or configuring it with header: true.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="toggleCollapse" scope="instance"><description>Shortcut for performing an expand or collapse based on the current state of the panel.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method></methods></class><class superclass="Ext.layout.ContainerLayout" type="Ext.layout.BorderLayout"><description>This is a multi-pane, application-oriented UI layout style that supports multiple
nested panels, automatic split bars between
regions and built-in
expanding and collapsing of regions.
This class is intended to be extended or created via the layout:'border'
Ext.Container.layout config, and should generally not need to be created directly
via the new keyword.
BorderLayout does not have any direct config options (other than inherited ones).
All configuration options available for customizing the BorderLayout are at the
Ext.layout.BorderLayout.Region and Ext.layout.BorderLayout.SplitRegion
levels.
Example usage:
var myBorderPanel = new Ext.Panel({
    renderTo: document.body,
    width: 700,
    height: 500,
    title: 'Border Layout',
    layout: 'border',
    items: [{
        title: 'South Region is resizable',
        region: 'south',     // position for region
        height: 100,
        split: true,         // enable resizing
        minSize: 75,         // defaults to 50
        maxSize: 150,
        margins: '0 5 5 5'
    },{
        // xtype: 'panel' implied by default
        title: 'West Region is collapsible',
        region:'west',
        margins: '5 0 0 5',
        width: 200,
        collapsible: true,   // make collapsible
        cmargins: '5 5 0 5', // adjust top margin when collapsed
        id: 'west-region-container',
        layout: 'fit',
        unstyled: true
    },{
        title: 'Center Region',
        region: 'center',     // center region is required, no width/height specified
        xtype: 'container',
        layout: 'fit',
        margins: '5 5 0 0'
    }]
});
Notes:
Any container using the BorderLayout must have a child item with region:'center'.
The child item in the center region will always be resized to fill the remaining space not used by
the other regions in the layout.
Any child items with a region of west or east must have width defined
(an integer representing the number of pixels that the region should take up).
Any child items with a region of north or south must have height defined.
The regions of a BorderLayout are fixed at render time and thereafter, its child Components may not be removed or added.  To add/remove
Components within a BorderLayout, have them wrapped by an additional Container which is directly
managed by the BorderLayout.  If the region is to be collapsible, the Container used directly
by the BorderLayout manager should be a Panel.  In the following example a Container (an Ext.Panel)
is added to the west region:
wrc = Ext.getCmp('west-region-container');
wrc.removeAll();
wrc.add({
    title: 'Added Panel',
    html: 'Some content'
});
wrc.doLayout();

 To reference a Region:
wr = myBorderPanel.layout.west;

</description><constructors/><properties/><methods><method name="parseMargins" scope="instance"><description>Parses a number or string representing margin sizes into an object. Supports CSS-style margin declarations
(e.g. 10, &quot;10&quot;, &quot;10 10&quot;, &quot;10 10 10&quot; and &quot;10 10 10 10&quot; are all valid options and would return the same result)</description></method></methods></class><class superclass="Object" type="Ext.EventObject"><description>Just as Ext.Element wraps around a native DOM node, Ext.EventObject
wraps the browser's native event-object normalizing cross-browser differences,
such as which mouse button is clicked, keys pressed, mechanisms to stop
event-propagation along with a method to prevent default actions from taking place.
For example:
function handleClick(e, t){ // e is not a standard event object, it is a Ext.EventObject
    e.preventDefault();
    var target = e.getTarget(); // same as t (the target HTMLElement)
    ...
}
var myDiv = Ext.get(&quot;myDiv&quot;);  // get reference to an Ext.Element
myDiv.on(         // 'on' is shorthand for addListener
    &quot;click&quot;,      // perform an action on click of myDiv
    handleClick   // reference to the action handler
);
// other methods to do the same:
Ext.EventManager.on(&quot;myDiv&quot;, 'click', handleClick);
Ext.EventManager.addListener(&quot;myDiv&quot;, 'click', handleClick);</description><constructors/><properties/><methods><method name="getCharCode" scope="instance"><description>Gets the character code for the event.</description></method><method name="getKey" scope="instance"><description>Returns a normalized keyCode for the event.</description></method><method name="getPageX" scope="instance"><description>Gets the x coordinate of the event.</description></method><method name="getPageY" scope="instance"><description>Gets the y coordinate of the event.</description></method><method name="getRelatedTarget" scope="instance"><description>Gets the related target.</description></method><method name="getTarget" scope="instance"><description>Gets the target for the event.</description></method><method name="getWheelDelta" scope="instance"><description>Normalizes mouse wheel delta across browsers</description></method><method name="getXY" scope="instance"><description>Gets the page coordinates of the event.</description></method><method name="preventDefault" scope="instance"><description>Prevents the browsers default handling of the event.</description></method><method name="stopEvent" scope="instance"><description>Stop the event (preventDefault and stopPropagation)</description></method><method name="stopPropagation" scope="instance"><description>Cancels bubbling of the event.</description></method><method name="within" scope="instance"><description>Returns true if the target of this event is a child of el.  Unless the allowEl parameter is set, it will return false if if the target is el.
Example usage:// Handle click on any child of an element
        Ext.getBody().on('click', function(e){
            if(e.within('some-el')){
                alert('Clicked on a child of some-el!');
            }
        });

        // Handle click directly on an element, ignoring clicks on child nodes
        Ext.getBody().on('click', function(e,t){
            if((t.id == 'some-el') &amp;&amp; !e.within(t, true)){
                alert('Clicked directly on some-el!');
            }
        });</description></method></methods></class><class superclass="Object" type="Ext.tree.RootTreeNodeUI"><description>This class provides the default UI implementation for root Ext TreeNodes.
The RootTreeNode UI implementation allows customizing the appearance of the root tree node.

If you are customizing the Tree's user interface, you
may need to extend this class, but you should never need to instantiate this class.</description><constructors/><properties/><methods/></class><class superclass="Ext.Tip" type="Ext.slider.Tip"><description>Simple plugin for using an Ext.Tip with a slider to show the slider value. Example usage:

new Ext.Slider({
    width: 214,
    minValue: 0,
    maxValue: 100,
    plugins: new Ext.slider.Tip()
});

Optionally provide your own tip text by overriding getText:
 
 new Ext.Slider({
     width: 214,
     minValue: 0,
     maxValue: 100,
     plugins: new Ext.slider.Tip({
         getText: function(thumb){
             return String.format('{0}% complete', thumb.value);
         }
     })
 });
 </description><constructors/><properties/><methods><method name="add" scope="instance"><description>Adds Component(s) to this Container.
Description :

Fires the beforeadd event before adding
The Container's default config values will be applied
accordingly (see defaults for details).
Fires the add event after the component has been added.

Notes :

If the Container is already rendered when add
is called, you may need to call doLayout to refresh the view which causes
any unrendered child Components to be rendered. This is required so that you can
add multiple child components if needed while only refreshing the layout
once. For example:var tb = new Ext.Toolbar();
tb.render(document.body);  // toolbar is rendered
tb.add({text:'Button 1'}); // add multiple items (defaultType for Toolbar is 'button')
tb.add({text:'Button 2'});
tb.doLayout();             // refresh the layout
Warning: Containers directly managed by the BorderLayout layout manager
may not be removed or added.  See the Notes for BorderLayout
for more details.
</description></method><method name="addButton" scope="instance"><description>Adds a button to this panel.  Note that this method must be called prior to rendering.  The preferred
approach is to add buttons via the buttons config.</description></method><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cascade" scope="instance"><description>Cascades down the component/container heirarchy from this component (called first), calling the specified function with
each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the cascade is stopped on that branch.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="collapse" scope="instance"><description>Collapses the panel body so that it becomes hidden.  Fires the beforecollapse event which will
cancel the collapse action if it returns false.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="doLayout" scope="instance"><description>Force this container's layout to be recalculated. A call to this function is required after adding a new component
to an already rendered container, or possibly after changing sizing/position properties of child components.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="expand" scope="instance"><description>Expands the panel body so that it becomes visible.  Fires the beforeexpand event which will
cancel the expand action if it returns false.</description></method><method name="find" scope="instance"><description>Find a component under this container at any level by property</description></method><method name="findBy" scope="instance"><description>Find a component under this container at any level by a custom function. If the passed function returns
true, the component will be included in the results. The passed function is called with the arguments (component, this container).</description></method><method name="findById" scope="instance"><description>Find a component under this container at any level by id</description></method><method name="findByType" scope="instance"><description>Find a component under this container at any level by xtype or class</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="get" scope="instance"><description>Get a component contained by this container (alias for items.get(key))</description></method><method name="getBottomToolbar" scope="instance"><description>Returns the toolbar from the bottom (bbar) section of the panel.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getComponent" scope="instance"><description>Examines this container's items property
and gets a direct child component of this container.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getFooterToolbar" scope="instance"><description>Returns the toolbar from the footer (fbar) section of the panel.</description></method><method name="getFrameHeight" scope="instance"><description>Returns the height in pixels of the framing elements of this panel (including any top and bottom bars and
header and footer elements, but not including the body height).  To retrieve the body height see getInnerHeight.</description></method><method name="getFrameWidth" scope="instance"><description>Returns the width in pixels of the framing elements of this panel (not including the body width).  To
retrieve the body width see getInnerWidth.</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getInnerHeight" scope="instance"><description>Returns the height in pixels of the body element (not including the height of any framing elements).
For the frame height see getFrameHeight.</description></method><method name="getInnerWidth" scope="instance"><description>Returns the width in pixels of the body element (not including the width of any framing elements).
For the frame width see getFrameWidth.</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getLayout" scope="instance"><description>Returns the layout currently in use by the container.  If the container does not currently have a layout
set, a default Ext.layout.ContainerLayout will be created and set as the container's layout.</description></method><method name="getLayoutTarget" scope="instance"><description>Returns the Element to be used to contain the child Components of this Container.
An implementation is provided which returns the Container's Element, but
if there is a more complex structure to a Container, this may be overridden to return
the element into which the layout renders child Components.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getText" scope="instance"><description>Used to create the text that appears in the Tip's body. By default this just returns
the value of the Slider Thumb that the Tip is attached to. Override to customize.</description></method><method name="getTool" scope="instance"><description>Retrieve a tool by id.</description></method><method name="getTopToolbar" scope="instance"><description>Returns the toolbar from the top (tbar) section of the panel.</description></method><method name="getUpdater" scope="instance"><description>Get the Ext.Updater for this panel. Enables you to perform Ajax updates of this panel's body.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="insert" scope="instance"><description>Inserts a Component into this Container at a specified index. Fires the
beforeadd event before inserting, then fires the add event after the
Component has been inserted.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="load" scope="instance"><description>Loads this content panel immediately with content returned from an XHR call.</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="remove" scope="instance"><description>Removes a component from this container.  Fires the beforeremove event before removing, then fires
the remove event after the component has been removed.</description></method><method name="removeAll" scope="instance"><description>Removes all components from this container.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setIconClass" scope="instance"><description>Sets the CSS class that provides the icon image for this panel.  This method will replace any existing
icon class if one has already been set and fire the iconchange event after completion.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setTitle" scope="instance"><description>Sets the title text for the panel and optionally the icon class.
In order to be able to set the title, a header element must have been created
for the Panel. This is triggered either by configuring the Panel with a non-blank title,
or configuring it with header: true.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="showAt" scope="instance"><description>Shows this tip at the specified XY position.  Example usage:
// Show the tip at x:50 and y:100
tip.showAt([50,100]);</description></method><method name="showBy" scope="instance"><description>Experimental. Shows this tip at a position relative to another element using a standard Ext.Element.alignTo
anchor position value.  Example usage:
// Show the tip at the default position ('tl-br?')
tip.showBy('my-el');

// Show the tip's top-left corner anchored to the element's top-right corner
tip.showBy('my-el', 'tl-tr');</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="toggleCollapse" scope="instance"><description>Shortcut for performing an expand or collapse based on the current state of the panel.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method></methods></class><class superclass="Ext.dd.DDProxy" type="Ext.dd.DragSource"><description>A simple class that provides the basic implementation needed to make any element draggable.</description><constructors/><properties/><methods><method name="addInvalidHandleClass" scope="instance"><description>Lets you specify a css class of elements that will not initiate a drag</description></method><method name="addInvalidHandleId" scope="instance"><description>Lets you to specify an element id for a child of a drag handle
that should not initiate a drag</description></method><method name="addInvalidHandleType" scope="instance"><description>Allows you to specify a tag name that should not start a drag operation
when clicked.  This is designed to facilitate embedding links within a
drag handle that do something other than start the drag.</description></method><method name="addToGroup" scope="instance"><description>Add this instance to a group of related drag/drop objects.  All
instances belong to at least one group, and can belong to as many
groups as needed.</description></method><method name="afterDragDrop" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action
after a valid drag drop has occurred by providing an implementation.</description></method><method name="afterDragEnter" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action
when the dragged item enters the drop target by providing an implementation.</description></method><method name="afterDragOut" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action
after the dragged item is dragged out of the target without dropping.</description></method><method name="afterDragOver" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action
while the dragged item is over the drop target by providing an implementation.</description></method><method name="afterInvalidDrop" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action
after an invalid drop has occurred by providing an implementation.</description></method><method name="alignElWithMouse" scope="instance"><description>Sets the element to the location of the mousedown or click event,
maintaining the cursor location relative to the location on the element
that was clicked.  Override this if you want to place the element in a
location other than where the cursor is.</description></method><method name="applyConfig" scope="instance"><description>Sets up config options specific to this class. Overrides
Ext.dd.DragDrop, but all versions of this method through the
inheritance chain are called</description></method><method name="autoOffset" scope="instance"><description>Sets the pointer offset to the distance between the linked element's top
left corner and the location the element was clicked</description></method><method name="b4Drag" scope="instance"><description>Event that fires prior to the onDrag event.  Overrides
Ext.dd.DragDrop.</description></method><method name="b4MouseDown" scope="instance"><description>Event that fires prior to the onMouseDown event.  Overrides
Ext.dd.DragDrop.</description></method><method name="beforeDragDrop" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action before the dragged
item is dropped onto the target and optionally cancel the onDragDrop.</description></method><method name="beforeDragEnter" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action
before the dragged item enters the drop target and optionally cancel the onDragEnter.</description></method><method name="beforeDragOut" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action before the dragged
item is dragged out of the target without dropping, and optionally cancel the onDragOut.</description></method><method name="beforeDragOver" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action
while the dragged item is over the drop target and optionally cancel the onDragOver.</description></method><method name="beforeInvalidDrop" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action after an invalid
drop has occurred.</description></method><method name="cachePosition" scope="instance"><description>Saves the most recent position so that we can reset the constraints and
tick marks on-demand.  We need to know this so that we can calculate the
number of pixels the element is offset from its original position.</description></method><method name="clearConstraints" scope="instance"><description>Clears any constraints applied to this instance.  Also clears ticks
since they can't exist independent of a constraint at this time.</description></method><method name="clearTicks" scope="instance"><description>Clears any tick interval defined for this instance</description></method><method name="constrainTo" scope="instance"><description>Initializes the drag drop object's constraints to restrict movement to a certain element.
Usage:
 var dd = new Ext.dd.DDProxy(&quot;dragDiv1&quot;, &quot;proxytest&quot;,
                { dragElId: &quot;existingProxyDiv&quot; });
 dd.startDrag = function(){
     this.constrainTo(&quot;parent-id&quot;);
 };
Or you can initalize it using the Ext.Element object:
 Ext.get(&quot;dragDiv1&quot;).initDDProxy(&quot;proxytest&quot;, {dragElId: &quot;existingProxyDiv&quot;}, {
     startDrag : function(){
         this.constrainTo(&quot;parent-id&quot;);
     }
 });</description></method><method name="createFrame" scope="instance"><description>Creates the proxy element if it does not yet exist</description></method><method name="endDrag" scope="instance"><description>Fired when we are done dragging the object</description></method><method name="getDragData" scope="instance"><description>Returns the data object associated with this drag source</description></method><method name="getDragEl" scope="instance"><description>Returns a reference to the actual element to drag.  By default this is
the same as the html element, but it can be assigned to another
element. An example of this can be found in Ext.dd.DDProxy</description></method><method name="getEl" scope="instance"><description>Returns a reference to the linked element</description></method><method name="getProxy" scope="instance"><description>Returns the drag source's underlying Ext.dd.StatusProxy</description></method><method name="hideProxy" scope="instance"><description>Hides the drag source's Ext.dd.StatusProxy</description></method><method name="init" scope="instance"><description>Sets up the DragDrop object.  Must be called in the constructor of any
Ext.dd.DragDrop subclass</description></method><method name="initFrame" scope="instance"><description>Initialization for the drag frame element.  Must be called in the
constructor of all subclasses</description></method><method name="initTarget" scope="instance"><description>Initializes Targeting functionality only... the object does not
get a mousedown handler.</description></method><method name="isLocked" scope="instance"><description>Returns true if this instance is locked, or the drag drop mgr is locked
(meaning that all drag/drop is disabled on the page.)</description></method><method name="isValidHandleChild" scope="instance"><description>Checks the tag exclusion list to see if this click should be ignored</description></method><method name="lock" scope="instance"><description>Lock this instance</description></method><method name="onAvailable" scope="instance"><description>Override the onAvailable method to do what is needed after the initial
position was determined.</description></method><method name="onBeforeDrag" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action before the initial
drag event begins and optionally cancel it.</description></method><method name="onDrag" scope="instance"><description>Abstract method called during the onMouseMove event while dragging an
object.</description></method><method name="onDragDrop" scope="instance"><description>Abstract method called when this item is dropped on another DragDrop
obj</description></method><method name="onDragEnter" scope="instance"><description>Abstract method called when this element fist begins hovering over
another DragDrop obj</description></method><method name="onDragOut" scope="instance"><description>Abstract method called when we are no longer hovering over an element</description></method><method name="onDragOver" scope="instance"><description>Abstract method called when this element is hovering over another
DragDrop obj</description></method><method name="onInvalidDrop" scope="instance"><description>Abstract method called when this item is dropped on an area with no
drop target</description></method><method name="onMouseDown" scope="instance"><description>Event handler that fires when a drag/drop obj gets a mousedown</description></method><method name="onMouseUp" scope="instance"><description>Event handler that fires when a drag/drop obj gets a mouseup</description></method><method name="onStartDrag" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action once the initial
drag event has begun.  The drag cannot be canceled from this function.</description></method><method name="removeFromGroup" scope="instance"><description>Remove's this instance from the supplied interaction group</description></method><method name="removeInvalidHandleClass" scope="instance"><description>Unsets an invalid css class</description></method><method name="removeInvalidHandleId" scope="instance"><description>Unsets an invalid handle id</description></method><method name="removeInvalidHandleType" scope="instance"><description>Unsets an excluded tag name set by addInvalidHandleType</description></method><method name="resetConstraints" scope="instance"><description>resetConstraints must be called if you manually reposition a dd element.</description></method><method name="setDelta" scope="instance"><description>Sets the pointer offset.  You can call this directly to force the
offset to be in a particular location (e.g., pass in 0,0 to set it
to the center of the object)</description></method><method name="setDragElId" scope="instance"><description>Allows you to specify that an element other than the linked element
will be moved with the cursor during a drag</description></method><method name="setDragElPos" scope="instance"><description>Sets the drag element to the location of the mousedown or click event,
maintaining the cursor location relative to the location on the element
that was clicked.  Override this if you want to place the element in a
location other than where the cursor is.</description></method><method name="setHandleElId" scope="instance"><description>Allows you to specify a child of the linked element that should be
used to initiate the drag operation.  An example of this would be if
you have a content div with text and links.  Clicking anywhere in the
content area would normally start the drag operation.  Use this method
to specify that an element inside of the content div is the element
that starts the drag operation.</description></method><method name="setInitPosition" scope="instance"><description>Stores the initial placement of the linked element.</description></method><method name="setOuterHandleElId" scope="instance"><description>Allows you to set an element outside of the linked element as a drag
handle</description></method><method name="setPadding" scope="instance"><description>Configures the padding for the target zone in px.  Effectively expands
(or reduces) the virtual object size for targeting calculations.
Supports css-style shorthand; if only one parameter is passed, all sides
will have that padding, and if only two are passed, the top and bottom
will have the first param, the left and right the second.</description></method><method name="setXConstraint" scope="instance"><description>By default, the element can be dragged any place on the screen.  Use
this method to limit the horizontal travel of the element.  Pass in
0,0 for the parameters if you want to lock the drag to the y axis.</description></method><method name="setYConstraint" scope="instance"><description>By default, the element can be dragged any place on the screen.  Set
this to limit the vertical travel of the element.  Pass in 0,0 for the
parameters if you want to lock the drag to the x axis.</description></method><method name="startDrag" scope="instance"><description>Abstract method called after a drag/drop object is clicked
and the drag or mousedown time thresholds have beeen met.</description></method><method name="toString" scope="instance"><description>toString method</description></method><method name="unlock" scope="instance"><description>Unlock this instace</description></method><method name="unreg" scope="instance"><description>Remove all drag and drop hooks for this element</description></method></methods></class><class superclass="Ext.DataView" type="Ext.list.ListView"><description>Ext.list.ListView is a fast and light-weight implentation of a
Grid like view with the following characteristics:

resizable columns
selectable
column widths are initially proportioned by percentage based on the container
width and number of columns
uses templates to render the data in any required format
no horizontal scrolling
no editing

Example usage:
// consume JSON of this form:
{
   &quot;images&quot;:[
      {
         &quot;name&quot;:&quot;dance_fever.jpg&quot;,
         &quot;size&quot;:2067,
         &quot;lastmod&quot;:1236974993000,
         &quot;url&quot;:&quot;images\/thumbs\/dance_fever.jpg&quot;
      },
      {
         &quot;name&quot;:&quot;zack_sink.jpg&quot;,
         &quot;size&quot;:2303,
         &quot;lastmod&quot;:1236974993000,
         &quot;url&quot;:&quot;images\/thumbs\/zack_sink.jpg&quot;
      }
   ]
}
var store = new Ext.data.JsonStore({
    url: 'get-images.php',
    root: 'images',
    fields: [
        'name', 'url',
        {name:'size', type: 'float'},
        {name:'lastmod', type:'date', dateFormat:'timestamp'}
    ]
});
store.load();

var listView = new Ext.list.ListView({
    store: store,
    multiSelect: true,
    emptyText: 'No images to display',
    reserveScrollOffset: true,
    columns: [{
        header: 'File',
        width: .5,
        dataIndex: 'name'
    },{
        header: 'Last Modified',
        width: .35,
        dataIndex: 'lastmod',
        tpl: '{lastmod:date(&quot;m-d h:i a&quot;)}'
    },{
        header: 'Size',
        dataIndex: 'size',
        tpl: '{size:fileSize}', // format using Ext.util.Format.fileSize()
        align: 'right'
    }]
});

// put it in a Panel so it looks pretty
var panel = new Ext.Panel({
    id:'images-view',
    width:425,
    height:250,
    collapsible:true,
    layout:'fit',
    title:'Simple ListView (0 items selected)',
    items: listView
});
panel.render(document.body);

// little bit of feedback
listView.on('selectionchange', function(view, nodes){
    var l = nodes.length;
    var s = l != 1 ? 's' : '';
    panel.setTitle('Simple ListView ('+l+' item'+s+' selected)');
});</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bindStore" scope="instance"><description>Changes the data store bound to this view and refreshes it.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="clearSelections" scope="instance"><description>Clears all selections.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="collectData" scope="instance"><description>Function which can be overridden which returns the data object passed to this
view's template to render the whole ListView. The returned object
shall contain the following properties:

columns : StringSee columns
rows : StringSee
Ext.DataView.collectData
</description></method><method name="deselect" scope="instance"><description>Deselects a node.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findItemFromChild" scope="instance"><description>Returns the template node the passed child belongs to, or null if it doesn't belong to one.</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getNode" scope="instance"><description>Gets a template node.</description></method><method name="getNodes" scope="instance"><description>Gets a range nodes.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getRecord" scope="instance"><description>Gets a record from a node</description></method><method name="getRecords" scope="instance"><description>Gets an array of the records from an array of nodes</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSelectedIndexes" scope="instance"><description>Gets the indexes of the selected nodes.</description></method><method name="getSelectedNodes" scope="instance"><description>Gets the currently selected nodes.</description></method><method name="getSelectedRecords" scope="instance"><description>Gets an array of the selected records</description></method><method name="getSelectionCount" scope="instance"><description>Gets the number of selected nodes.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getStore" scope="instance"><description>Returns the store associated with this DataView.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="indexOf" scope="instance"><description>Finds the index of the passed node.</description></method><method name="isSelected" scope="instance"><description>Returns true if the passed node is selected, else false.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="prepareData" scope="instance"><description>Function which can be overridden to provide custom formatting for each Record that is used by this
DataView's template to render each node.</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="refresh" scope="instance"><description>Refreshes the view by reloading the data from the store and re-rendering the template.</description></method><method name="refreshNode" scope="instance"><description>Refreshes an individual node's data from the store.</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="select" scope="instance"><description>Selects a set of nodes.</description></method><method name="selectRange" scope="instance"><description>Selects a range of nodes. All nodes between start and end are selected.</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setStore" scope="instance"><description>Changes the data store bound to this view and refreshes it. (deprecated in favor of bindStore)</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method></methods></class><class superclass="Object" type="Ext.util.TaskRunner"><description>Provides the ability to execute one or more arbitrary tasks in a multithreaded
manner.  Generally, you can use the singleton Ext.TaskMgr instead, but
if needed, you can create separate instances of TaskRunner.  Any number of
separate tasks can be started at any time and will run independently of each
other. Example usage:
// Start a simple clock task that updates a div once per second
var updateClock = function(){
    Ext.fly('clock').update(new Date().format('g:i:s A'));
} 
var task = {
    run: updateClock,
    interval: 1000 //1 second
}
var runner = new Ext.util.TaskRunner();
runner.start(task);

// equivalent using TaskMgr
Ext.TaskMgr.start({
    run: updateClock,
    interval: 1000
});
See the start method for details about how to configure a task object.
Also see Ext.util.DelayedTask.</description><constructors/><properties/><methods><method name="start" scope="instance"><description>Starts a new task.</description></method><method name="stop" scope="instance"><description>Stops an existing running task.</description></method><method name="stopAll" scope="instance"><description>Stops all tasks that are currently running.</description></method></methods></class><class superclass="Ext.Toolbar.Item" type="Ext.Toolbar.Separator"><description>A simple class that adds a vertical separator bar between toolbar items
(css class:'xtb-sep'). Example usage:
new Ext.Panel({
    tbar : [
        'Item 1',
        {xtype: 'tbseparator'}, // or '-'
        'Item 2'
    ]
});</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method></methods></class><class superclass="Object" type="Ext.util.TextMetrics"><description>Provides precise pixel measurements for blocks of text so that you can determine exactly how high and
wide, in pixels, a given block of text will be. Note that when measuring text, it should be plain text and
should not contain any HTML, otherwise it may not be measured correctly.</description><constructors/><properties/><methods><method name="bind" scope="instance"><description>Only available on the instance returned from createInstance, not on the singleton.
Binds this TextMetrics instance to an element from which to copy existing CSS styles
that can affect the size of the rendered text</description></method><method name="createInstance" scope="instance"><description>Return a unique TextMetrics instance that can be bound directly to an element and reused.  This reduces
the overhead of multiple calls to initialize the style properties on each measurement.</description></method><method name="getHeight" scope="instance"><description>Only available on the instance returned from createInstance, not on the singleton.
Returns the measured height of the specified text.  For multiline text, be sure to call
setFixedWidth if necessary.</description></method><method name="getSize" scope="instance"><description>Only available on the instance returned from createInstance, not on the singleton.
Returns the size of the specified text based on the internal element's style and width properties</description></method><method name="getWidth" scope="instance"><description>Only available on the instance returned from createInstance, not on the singleton.
Returns the measured width of the specified text</description></method><method name="measure" scope="instance"><description>Measures the size of the specified text</description></method><method name="setFixedWidth" scope="instance"><description>Only available on the instance returned from createInstance, not on the singleton.
Sets a fixed width on the internal measurement element.  If the text will be multiline, you have
to set a fixed width in order to accurately measure the text height.</description></method></methods></class><class superclass="Ext.grid.Column" type="Ext.grid.TemplateColumn"><description>A Column definition class which renders a value by processing a Record's
data using a configured XTemplate.
See the xtype config option of Ext.grid.Column for more
details.</description><constructors/><properties/><methods><method name="getCellEditor" scope="instance"><description>Returns the editor defined for this column that was created to wrap the Field
used to edit the cell.</description></method><method name="setEditor" scope="instance"><description>Sets a new editor for this column.</description></method></methods></class><class superclass="Ext.data.Store" type="Ext.data.XmlStore"><description>Small helper class to make creating Ext.data.Stores from XML data easier.
A XmlStore will be automatically configured with a Ext.data.XmlReader.
A store configuration would be something like:var store = new Ext.data.XmlStore({
    // store configs
    autoDestroy: true,
    storeId: 'myStore',
    url: 'sheldon.xml', // automatically configures a HttpProxy
    // reader configs
    record: 'Item', // records will have an &quot;Item&quot; tag
    idPath: 'ASIN',
    totalRecords: '@TotalResults'
    fields: [
        // set up the fields mapping into the xml doc
        // The first needs mapping, the others are very basic
        {name: 'Author', mapping: 'ItemAttributes &gt; Author'},
        'Title', 'Manufacturer', 'ProductGroup'
    ]
});
This store is configured to consume a returned object of the form:&amp;#60?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&amp;#60ItemSearchResponse xmlns=&quot;http://webservices.amazon.com/AWSECommerceService/2009-05-15&quot;&gt;
    &amp;#60Items&gt;
        &amp;#60Request&gt;
            &amp;#60IsValid&gt;True&amp;#60/IsValid&gt;
            &amp;#60ItemSearchRequest&gt;
                &amp;#60Author&gt;Sidney Sheldon&amp;#60/Author&gt;
                &amp;#60SearchIndex&gt;Books&amp;#60/SearchIndex&gt;
            &amp;#60/ItemSearchRequest&gt;
        &amp;#60/Request&gt;
        &amp;#60TotalResults&gt;203&amp;#60/TotalResults&gt;
        &amp;#60TotalPages&gt;21&amp;#60/TotalPages&gt;
        &amp;#60Item&gt;
            &amp;#60ASIN&gt;0446355453&amp;#60/ASIN&gt;
            &amp;#60DetailPageURL&gt;
                http://www.amazon.com/
            &amp;#60/DetailPageURL&gt;
            &amp;#60ItemAttributes&gt;
                &amp;#60Author&gt;Sidney Sheldon&amp;#60/Author&gt;
                &amp;#60Manufacturer&gt;Warner Books&amp;#60/Manufacturer&gt;
                &amp;#60ProductGroup&gt;Book&amp;#60/ProductGroup&gt;
                &amp;#60Title&gt;Master of the Game&amp;#60/Title&gt;
            &amp;#60/ItemAttributes&gt;
        &amp;#60/Item&gt;
    &amp;#60/Items&gt;
&amp;#60/ItemSearchResponse&gt;
An object literal of this form could also be used as the data config option.
Note: Although not listed here, this class accepts all of the configuration options of 
XmlReader.</description><constructors/><properties/><methods><method name="add" scope="instance"><description>Add Records to the Store and fires the add event.  To add Records
to the store from a remote source use load({add:true}).
See also recordType and insert.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="addSorted" scope="instance"><description>(Local sort only) Inserts the passed Record into the Store at the index where it
should go based on the current sort information.</description></method><method name="clearFilter" scope="instance"><description>Revert to a view of the Record cache with no filtering applied.</description></method><method name="collect" scope="instance"><description>Collects unique values for a particular dataIndex from this store.</description></method><method name="commitChanges" scope="instance"><description>Commit all Records with outstanding changes. To handle updates for changes,
subscribe to the Store's update event, and perform updating when the third parameter is
Ext.data.Record.COMMIT.</description></method><method name="destroy" scope="instance"><description>Destroys the store.</description></method><method name="each" scope="instance"><description>Calls the specified function for each of the Records in the cache.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="filter" scope="instance"><description>Filter the records by a specified property. Alternatively, pass an array of filter
options to filter by more than one property.
Single filter example:
store.filter('name', 'Ed', true, true); //finds all records containing the substring 'Ed'
Multiple filter example:
store.filter([
{
property     : 'name',
value        : 'Ed',
anyMatch     : true, //optional, defaults to true
caseSensitive: true  //optional, defaults to true
},
//filter functions can also be passed
{
fn   : function(record) {
return record.get('age') == 24
},
scope: this
}
]);</description></method><method name="filterBy" scope="instance"><description>Filter by a function. The specified function will be called for each
Record in this Store. If the function returns true the Record is included,
otherwise it is filtered out.</description></method><method name="find" scope="instance"><description>Finds the index of the first matching Record in this store by a specific field value.</description></method><method name="findBy" scope="instance"><description>Find the index of the first matching Record in this Store by a function.
If the function returns true it is considered a match.</description></method><method name="findExact" scope="instance"><description>Finds the index of the first matching Record in this store by a specific field value.</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="getAt" scope="instance"><description>Get the Record at the specified index.</description></method><method name="getById" scope="instance"><description>Get the Record with the specified id.</description></method><method name="getCount" scope="instance"><description>Gets the number of cached records.
If using paging, this may not be the total size of the dataset. If the data object
used by the Reader contains the dataset size, then the getTotalCount function returns
the dataset size.  Note: see the Important note in load.</description></method><method name="getModifiedRecords" scope="instance"><description>Gets all records modified since the last commit.  Modified records are
persisted across load operations (e.g., during paging). Note: deleted records are not
included.  See also pruneModifiedRecords and
Ext.data.RecordmarkDirty..</description></method><method name="getRange" scope="instance"><description>Returns a range of Records between specified indices.</description></method><method name="getSortState" scope="instance"><description>Returns an object describing the current sort state of this Store.</description></method><method name="getTotalCount" scope="instance"><description>Gets the total number of records in the dataset as returned by the server.
If using paging, for this to be accurate, the data object used by the Reader
must contain the dataset size. For remote data sources, the value for this property
(totalProperty for JsonReader,
totalRecords for XmlReader) shall be returned by a query on the server.
Note: see the Important note in load.</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="indexOf" scope="instance"><description>Get the index within the cache of the passed Record.</description></method><method name="indexOfId" scope="instance"><description>Get the index within the cache of the Record with the passed id.</description></method><method name="insert" scope="instance"><description>Inserts Records into the Store at the given index and fires the add event.
See also add and addSorted.</description></method><method name="isFiltered" scope="instance"><description>Returns true if this store is currently filtered</description></method><method name="load" scope="instance"><description>Loads the Record cache from the configured proxy using the configured reader.
Notes:
Important: loading is asynchronous! This call will return before the new data has been
loaded. To perform any post-processing where information from the load call is required, specify
the callback function to be called, or use a a 'load' event handler.
If using remote paging, the first load call must specify the start and limit
properties in the options.params property to establish the initial position within the
dataset, and the number of Records to cache on each read from the Proxy.
If using remote sorting, the configured sortInfo
will be automatically included with the posted parameters according to the specified
paramNames.
</description></method><method name="loadData" scope="instance"><description>Loads data from a passed data block and fires the load event. A Reader
which understands the format of the data must have been configured in the constructor.</description></method><method name="multiSort" scope="instance"><description>Sorts the contents of this store by multiple field/direction sorters. This is called internally by sort
and would not usually be called manually.
Multi sorting only currently applies to local datasets - multiple sort data is not currently sent to a proxy
if remoteSort is used.</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="query" scope="instance"><description>Query the records by a specified property.</description></method><method name="queryBy" scope="instance"><description>Query the cached records in this Store using a filtering function. The specified function
will be called with each record in this Store. If the function returns true the record is
included in the results.</description></method><method name="rejectChanges" scope="instance"><description>Reject outstanding changes on all modified records.</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="reload" scope="instance"><description>Reloads the Record cache from the configured Proxy using the configured
Reader and the options from the last load operation
performed.
Note: see the Important note in load.</description></method><method name="remove" scope="instance"><description>Remove Records from the Store and fires the remove event.</description></method><method name="removeAll" scope="instance"><description>Remove all Records from the Store and fires the clear event.</description></method><method name="removeAt" scope="instance"><description>Remove a Record from the Store at the specified index. Fires the remove event.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="save" scope="instance"><description>Saves all pending changes to the store.  If the commensurate Ext.data.Api.actions action is not configured, then
the configured url will be used.

change            url
---------------   --------------------
removed records   Ext.data.Api.actions.destroy
phantom records   Ext.data.Api.actions.create
modified records  Ext.data.Api.actions.update
</description></method><method name="setBaseParam" scope="instance"><description>Set the value for a property name in this store's baseParams.  Usage:myStore.setBaseParam('foo', {bar:3});</description></method><method name="setDefaultSort" scope="instance"><description>Sets the default sort column and order to be used by the next load operation.</description></method><method name="singleSort" scope="instance"><description>Sorts the store contents by a single field and direction. This is called internally by sort and would
not usually be called manually</description></method><method name="sort" scope="instance"><description>Sort the Records.
If remote sorting is used, the sort is performed on the server, and the cache is reloaded. If local
sorting is used, the cache is sorted internally. See also remoteSort and paramNames.
This function accepts two call signatures - pass in a field name as the first argument to sort on a single
field, or pass in an array of sort configuration objects to sort by multiple fields.
Single sort example:
store.sort('name', 'ASC');
Multi sort example:
store.sort([
{
field    : 'name',
direction: 'ASC'
},
{
field    : 'salary',
direction: 'DESC'
}
], 'ASC');
In this second form, the sort configs are applied in order, with later sorters sorting within earlier sorters' results.
For example, if two records with the same name are present they will also be sorted by salary if given the sort configs
above. Any number of sort configs can be added.</description></method><method name="sum" scope="instance"><description>Sums the value of property for each record between start
and end and returns the result.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method></methods></class><class superclass="Ext.form.Field" type="Ext.form.CompositeField"><description>Composite field allowing a number of form Fields to be rendered on the same row. The fields are rendered
using an hbox layout internally, so all of the normal HBox layout config items are available. Example usage:

{
    xtype: 'compositefield',
    labelWidth: 120
    items: [
        {
            xtype     : 'textfield',
            fieldLabel: 'Title',
            width     : 20
        },
        {
            xtype     : 'textfield',
            fieldLabel: 'First',
            flex      : 1
        },
        {
            xtype     : 'textfield',
            fieldLabel: 'Last',
            flex      : 1
        }
    ]
}

In the example above the composite's fieldLabel will be set to 'Title, First, Last' as it groups the fieldLabels
of each of its children. This can be overridden by setting a fieldLabel on the compositefield itself:

{
    xtype: 'compositefield',
    fieldLabel: 'Custom label',
    items: [...]
}

Any Ext.form.* component can be placed inside a composite field.</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="buildCombinedErrorMessage" scope="instance"><description>Takes an object containing error messages for contained fields, returning a combined error
string (defaults to just placing each item on a new line). This can be overridden to provide
custom combined error message handling.</description></method><method name="buildLabel" scope="instance"><description>Builds a label string from an array of subfield labels.
By default this just joins the labels together with a comma</description></method><method name="clearInvalid" scope="instance"><description>Clear any invalid styles/messages for this field</description></method><method name="clearInvalidChildren" scope="instance"><description>Calls clearInvalid on all child fields. This is a convenience function and should not often need to be called
as fields usually take care of clearing themselves</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getActiveError" scope="instance"><description>Gets the active error message for this field.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getErrors" scope="instance"><description>Runs this field's validators and returns an array of error messages for any validation failures.
This is called internally during validation and would not usually need to be used manually.
Each subclass should override or augment the return value to provide their own errors</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getName" scope="instance"><description>Returns the name or hiddenName
attribute of the field if available.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getRawValue" scope="instance"><description>Returns the raw data value which may or may not be a valid, defined value.  To return a normalized value see getValue.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getValue" scope="instance"><description>Returns the normalized data value (undefined or emptyText will be returned as '').  To return the raw value see getRawValue.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isDirty" scope="instance"><description>Checks each field in the composite and returns true if any is dirty</description></method><method name="isValid" scope="instance"><description>Returns whether or not the field value is currently valid by
validating the processed value
of the field. Note: disabled fields are ignored.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="markInvalid" scope="instance"><description>Display an error message associated with this field, using msgTarget to determine how to
display the message and applying invalidClass to the field's UI element.
Note: this method does not cause the Field's validate method to return false
if the value does pass validation. So simply marking a Field as invalid will not prevent
submission of forms submitted with the Ext.form.Action.Submit.clientValidation option set.
invalid.</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="onFieldClearInvalid" scope="instance"><description>Called if combineErrors is true and a subfield's clearInvalid method is called.
By default this just updates the internal fieldErrors MixedCollection.</description></method><method name="onFieldMarkInvalid" scope="instance"><description>Called if combineErrors is true and a subfield's markInvalid method is called.
By default this just adds the subfield's error to the internal fieldErrors MixedCollection</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="processValue" scope="instance"><description>This method should only be overridden if necessary to prepare raw values
for validation (see validate and isValid).  This method
is expected to return the processed value for the field which will
be used for validation (see validateValue method).</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="reset" scope="instance"><description>Resets each field in the composite to their previous value</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setActiveError" scope="instance"><description>Sets the current activeError to the given string. Fires the 'invalid' event.
This does not set up the error icon, only sets the message and fires the event. To show the error icon,
use markInvalid instead, which calls this method internally</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setRawValue" scope="instance"><description>Sets the underlying DOM field's value directly, bypassing validation.  To set the value with validation see setValue.</description></method><method name="setReadOnly" scope="instance"><description>Sets the read only state of this field.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setValue" scope="instance"><description>Sets a data value into the field and validates it.  To set the value directly without validation see setRawValue.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="sortErrors" scope="instance"><description>Sorts the internal fieldErrors MixedCollection by the order in which the fields are defined.
This is called before displaying errors to ensure that the errors are presented in the expected order.
This function can be overridden to provide a custom sorting order if needed.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="unsetActiveError" scope="instance"><description>Clears the activeError and fires the 'valid' event. This is called internally by clearInvalid and would not
usually need to be called manually</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method><method name="validate" scope="instance"><description>Validates the field value</description></method><method name="validateValue" scope="instance"><description>Performs validation checks on each subfield and returns false if any of them fail validation.</description></method></methods></class><class superclass="Object" type="Ext.util.JSON"><description>Modified version of Douglas Crockford&quot;s json.js that doesn&quot;t
mess with the Object prototype
http://www.json.org/js.html</description><constructors/><properties/><methods><method name="decode" scope="instance"><description>Decodes (parses) a JSON string to an object. If the JSON is invalid, this function throws a SyntaxError unless the safe option is set.</description></method><method name="encode" scope="instance"><description>Encodes an Object, Array or other value</description></method><method name="encodeDate" scope="instance"><description>Encodes a Date. This returns the actual string which is inserted into the JSON string as the literal expression.
The returned value includes enclosing double quotation marks.
The default return format is &quot;yyyy-mm-ddThh:mm:ss&quot;.
To override this:Ext.util.JSON.encodeDate = function(d) {
    return d.format('&quot;Y-m-d&quot;');
};</description></method></methods></class><class superclass="Ext.util.Observable" type="Ext.SplitBar"><description>Creates draggable splitter bar functionality from two elements (element to be dragged and element to be resized).

Usage:
var split = new Ext.SplitBar(&quot;elementToDrag&quot;, &quot;elementToSize&quot;,
                   Ext.SplitBar.HORIZONTAL, Ext.SplitBar.LEFT);
split.setAdapter(new Ext.SplitBar.AbsoluteLayoutAdapter(&quot;container&quot;));
split.minSize = 100;
split.maxSize = 600;
split.animate = true;
split.on('moved', splitterMoved);</description><constructors/><properties/><methods><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="destroy" scope="instance"><description>Destroy this splitbar.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="getAdapter" scope="instance"><description>Get the adapter this SplitBar uses</description></method><method name="getMaximumSize" scope="instance"><description>Gets the maximum size for the resizing element</description></method><method name="getMinimumSize" scope="instance"><description>Gets the minimum size for the resizing element</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setAdapter" scope="instance"><description>Set the adapter this SplitBar uses</description></method><method name="setCurrentSize" scope="instance"><description>Sets the initialize size for the resizing element</description></method><method name="setMaximumSize" scope="instance"><description>Sets the maximum size for the resizing element</description></method><method name="setMinimumSize" scope="instance"><description>Sets the minimum size for the resizing element</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method></methods></class><class superclass="Ext.form.TriggerField" type="Ext.form.TwinTriggerField"><description>TwinTriggerField is not a public class to be used directly.  It is meant as an abstract base class
to be extended by an implementing class.  For an example of implementing this class, see the custom
SearchField implementation here:
http://extjs.com/deploy/ext/examples/form/custom.html</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="autoSize" scope="instance"><description>Automatically grows the field to accomodate the width of the text up to the maximum field width allowed.
This only takes effect if grow = true, and fires the autosize event.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="clearInvalid" scope="instance"><description>Clear any invalid styles/messages for this field</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getActiveError" scope="instance"><description>Gets the active error message for this field.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getErrors" scope="instance"><description>Validates a value according to the field's validation rules and returns an array of errors
for any failing validations. Validation rules are processed in the following order:

1. Field specific validator

A validator offers a way to customize and reuse a validation specification.
If a field is configured with a validator
function, it will be passed the current field value.  The validator
function is expected to return either:

Boolean true if the value is valid (validation continues).
a String to represent the invalid message if invalid (validation halts).


2. Basic Validation

If the validator has not halted validation,
basic validation proceeds as follows:

allowBlank : (Invalid message =
emptyText)
Depending on the configuration of allowBlank, a
blank field will cause validation to halt at this step and return
Boolean true or false accordingly.  

minLength : (Invalid message =
minLengthText)
If the passed value does not satisfy the minLength
specified, validation halts.

maxLength : (Invalid message =
maxLengthText)
If the passed value does not satisfy the maxLength
specified, validation halts.



3. Preconfigured Validation Types (VTypes)

If none of the prior validation steps halts validation, a field
configured with a vtype will utilize the
corresponding VTypes validation function.
If invalid, either the field's vtypeText or
the VTypes vtype Text property will be used for the invalid message.
Keystrokes on the field will be filtered according to the VTypes
vtype Mask property.

4. Field specific regex test

If none of the prior validation steps halts validation, a field's
configured regex test will be processed.
The invalid message for this test is configured with
regexText.
</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getName" scope="instance"><description>Returns the name or hiddenName
attribute of the field if available.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getRawValue" scope="instance"><description>Returns the raw data value which may or may not be a valid, defined value.  To return a normalized value see getValue.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getValue" scope="instance"><description>Returns the normalized data value (undefined or emptyText will be returned as '').  To return the raw value see getRawValue.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isDirty" scope="instance"><description>Returns true if the value of this Field has been changed from its original value.
Will return false if the field is disabled or has not been rendered yet.
Note that if the owning form was configured with
Ext.form.BasicForm.trackResetOnLoad
then the original value is updated when the values are loaded by
Ext.form.BasicForm.setValues.</description></method><method name="isValid" scope="instance"><description>Returns whether or not the field value is currently valid by
validating the processed value
of the field. Note: disabled fields are ignored.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="markInvalid" scope="instance"><description>Display an error message associated with this field, using msgTarget to determine how to
display the message and applying invalidClass to the field's UI element.
Note: this method does not cause the Field's validate method to return false
if the value does pass validation. So simply marking a Field as invalid will not prevent
submission of forms submitted with the Ext.form.Action.Submit.clientValidation option set.
invalid.</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="onTrigger1Click" scope="instance"><description>The function that should handle the trigger's click event.  This method does nothing by default
until overridden by an implementing function. See Ext.form.TriggerField.onTriggerClick
for additional information.</description></method><method name="onTrigger2Click" scope="instance"><description>The function that should handle the trigger's click event.  This method does nothing by default
until overridden by an implementing function. See Ext.form.TriggerField.onTriggerClick
for additional information.</description></method><method name="onTriggerClick" scope="instance"><description>The function that should handle the trigger's click event.  This method does nothing by default
until overridden by an implementing function.  See Ext.form.ComboBox and Ext.form.DateField for
sample implementations.</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="processValue" scope="instance"><description>This method should only be overridden if necessary to prepare raw values
for validation (see validate and isValid).  This method
is expected to return the processed value for the field which will
be used for validation (see validateValue method).</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="reset" scope="instance"><description>Resets the current field value to the originally-loaded value and clears any validation messages.
Also adds emptyText and emptyClass if the
original value was blank.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="selectText" scope="instance"><description>Selects text in this field</description></method><method name="setActiveError" scope="instance"><description>Sets the current activeError to the given string. Fires the 'invalid' event.
This does not set up the error icon, only sets the message and fires the event. To show the error icon,
use markInvalid instead, which calls this method internally</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setEditable" scope="instance"><description>Allow or prevent the user from directly editing the field text.  If false is passed,
the user will only be able to modify the field using the trigger.  Will also add
a click event to the text field which will call the trigger. This method
is the runtime equivalent of setting the editable config option at config time.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setHideTrigger" scope="instance"><description>Changes the hidden status of the trigger.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setRawValue" scope="instance"><description>Sets the underlying DOM field's value directly, bypassing validation.  To set the value with validation see setValue.</description></method><method name="setReadOnly" scope="instance"><description>Setting this to true will supersede settings editable and hideTrigger.
Setting this to false will defer back to editable and hideTrigger. This method
is the runtime equivalent of setting the readOnly config option at config time.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setValue" scope="instance"><description>Sets a data value into the field and validates it.  To set the value directly without validation see setRawValue.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="unsetActiveError" scope="instance"><description>Clears the activeError and fires the 'valid' event. This is called internally by clearInvalid and would not
usually need to be called manually</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method><method name="validate" scope="instance"><description>Validates the field value</description></method><method name="validateValue" scope="instance"><description>Uses getErrors to build an array of validation errors. If any errors are found, markInvalid is called
with the first and false is returned, otherwise true is returned. Previously, subclasses were invited
to provide an implementation of this to process validations - from 3.2 onwards getErrors should be
overridden instead.</description></method></methods></class><class superclass="Ext.data.Store" type="Ext.data.ArrayStore"><description>Formerly known as &quot;SimpleStore&quot;.
Small helper class to make creating Ext.data.Stores from Array data easier.
An ArrayStore will be automatically configured with a Ext.data.ArrayReader.
A store configuration would be something like:var store = new Ext.data.ArrayStore({
    // store configs
    autoDestroy: true,
    storeId: 'myStore',
    // reader configs
    idIndex: 0,  
    fields: [
       'company',
       {name: 'price', type: 'float'},
       {name: 'change', type: 'float'},
       {name: 'pctChange', type: 'float'},
       {name: 'lastChange', type: 'date', dateFormat: 'n/j h:ia'}
    ]
});
This store is configured to consume a returned object of the form:var myData = [
    ['3m Co',71.72,0.02,0.03,'9/1 12:00am'],
    ['Alcoa Inc',29.01,0.42,1.47,'9/1 12:00am'],
    ['Boeing Co.',75.43,0.53,0.71,'9/1 12:00am'],
    ['Hewlett-Packard Co.',36.53,-0.03,-0.08,'9/1 12:00am'],
    ['Wal-Mart Stores, Inc.',45.45,0.73,1.63,'9/1 12:00am']
];
An object literal of this form could also be used as the data config option.
*Note: Although not listed here, this class accepts all of the configuration options of 
ArrayReader.</description><constructors/><properties/><methods><method name="add" scope="instance"><description>Add Records to the Store and fires the add event.  To add Records
to the store from a remote source use load({add:true}).
See also recordType and insert.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="addSorted" scope="instance"><description>(Local sort only) Inserts the passed Record into the Store at the index where it
should go based on the current sort information.</description></method><method name="clearFilter" scope="instance"><description>Revert to a view of the Record cache with no filtering applied.</description></method><method name="collect" scope="instance"><description>Collects unique values for a particular dataIndex from this store.</description></method><method name="commitChanges" scope="instance"><description>Commit all Records with outstanding changes. To handle updates for changes,
subscribe to the Store's update event, and perform updating when the third parameter is
Ext.data.Record.COMMIT.</description></method><method name="destroy" scope="instance"><description>Destroys the store.</description></method><method name="each" scope="instance"><description>Calls the specified function for each of the Records in the cache.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="filter" scope="instance"><description>Filter the records by a specified property. Alternatively, pass an array of filter
options to filter by more than one property.
Single filter example:
store.filter('name', 'Ed', true, true); //finds all records containing the substring 'Ed'
Multiple filter example:
store.filter([
{
property     : 'name',
value        : 'Ed',
anyMatch     : true, //optional, defaults to true
caseSensitive: true  //optional, defaults to true
},
//filter functions can also be passed
{
fn   : function(record) {
return record.get('age') == 24
},
scope: this
}
]);</description></method><method name="filterBy" scope="instance"><description>Filter by a function. The specified function will be called for each
Record in this Store. If the function returns true the Record is included,
otherwise it is filtered out.</description></method><method name="find" scope="instance"><description>Finds the index of the first matching Record in this store by a specific field value.</description></method><method name="findBy" scope="instance"><description>Find the index of the first matching Record in this Store by a function.
If the function returns true it is considered a match.</description></method><method name="findExact" scope="instance"><description>Finds the index of the first matching Record in this store by a specific field value.</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="getAt" scope="instance"><description>Get the Record at the specified index.</description></method><method name="getById" scope="instance"><description>Get the Record with the specified id.</description></method><method name="getCount" scope="instance"><description>Gets the number of cached records.
If using paging, this may not be the total size of the dataset. If the data object
used by the Reader contains the dataset size, then the getTotalCount function returns
the dataset size.  Note: see the Important note in load.</description></method><method name="getModifiedRecords" scope="instance"><description>Gets all records modified since the last commit.  Modified records are
persisted across load operations (e.g., during paging). Note: deleted records are not
included.  See also pruneModifiedRecords and
Ext.data.RecordmarkDirty..</description></method><method name="getRange" scope="instance"><description>Returns a range of Records between specified indices.</description></method><method name="getSortState" scope="instance"><description>Returns an object describing the current sort state of this Store.</description></method><method name="getTotalCount" scope="instance"><description>Gets the total number of records in the dataset as returned by the server.
If using paging, for this to be accurate, the data object used by the Reader
must contain the dataset size. For remote data sources, the value for this property
(totalProperty for JsonReader,
totalRecords for XmlReader) shall be returned by a query on the server.
Note: see the Important note in load.</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="indexOf" scope="instance"><description>Get the index within the cache of the passed Record.</description></method><method name="indexOfId" scope="instance"><description>Get the index within the cache of the Record with the passed id.</description></method><method name="insert" scope="instance"><description>Inserts Records into the Store at the given index and fires the add event.
See also add and addSorted.</description></method><method name="isFiltered" scope="instance"><description>Returns true if this store is currently filtered</description></method><method name="load" scope="instance"><description>Loads the Record cache from the configured proxy using the configured reader.
Notes:
Important: loading is asynchronous! This call will return before the new data has been
loaded. To perform any post-processing where information from the load call is required, specify
the callback function to be called, or use a a 'load' event handler.
If using remote paging, the first load call must specify the start and limit
properties in the options.params property to establish the initial position within the
dataset, and the number of Records to cache on each read from the Proxy.
If using remote sorting, the configured sortInfo
will be automatically included with the posted parameters according to the specified
paramNames.
</description></method><method name="loadData" scope="instance"><description>Loads data from a passed data block and fires the load event. A Reader
which understands the format of the data must have been configured in the constructor.</description></method><method name="multiSort" scope="instance"><description>Sorts the contents of this store by multiple field/direction sorters. This is called internally by sort
and would not usually be called manually.
Multi sorting only currently applies to local datasets - multiple sort data is not currently sent to a proxy
if remoteSort is used.</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="query" scope="instance"><description>Query the records by a specified property.</description></method><method name="queryBy" scope="instance"><description>Query the cached records in this Store using a filtering function. The specified function
will be called with each record in this Store. If the function returns true the record is
included in the results.</description></method><method name="rejectChanges" scope="instance"><description>Reject outstanding changes on all modified records.</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="reload" scope="instance"><description>Reloads the Record cache from the configured Proxy using the configured
Reader and the options from the last load operation
performed.
Note: see the Important note in load.</description></method><method name="remove" scope="instance"><description>Remove Records from the Store and fires the remove event.</description></method><method name="removeAll" scope="instance"><description>Remove all Records from the Store and fires the clear event.</description></method><method name="removeAt" scope="instance"><description>Remove a Record from the Store at the specified index. Fires the remove event.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="save" scope="instance"><description>Saves all pending changes to the store.  If the commensurate Ext.data.Api.actions action is not configured, then
the configured url will be used.

change            url
---------------   --------------------
removed records   Ext.data.Api.actions.destroy
phantom records   Ext.data.Api.actions.create
modified records  Ext.data.Api.actions.update
</description></method><method name="setBaseParam" scope="instance"><description>Set the value for a property name in this store's baseParams.  Usage:myStore.setBaseParam('foo', {bar:3});</description></method><method name="setDefaultSort" scope="instance"><description>Sets the default sort column and order to be used by the next load operation.</description></method><method name="singleSort" scope="instance"><description>Sorts the store contents by a single field and direction. This is called internally by sort and would
not usually be called manually</description></method><method name="sort" scope="instance"><description>Sort the Records.
If remote sorting is used, the sort is performed on the server, and the cache is reloaded. If local
sorting is used, the cache is sorted internally. See also remoteSort and paramNames.
This function accepts two call signatures - pass in a field name as the first argument to sort on a single
field, or pass in an array of sort configuration objects to sort by multiple fields.
Single sort example:
store.sort('name', 'ASC');
Multi sort example:
store.sort([
{
field    : 'name',
direction: 'ASC'
},
{
field    : 'salary',
direction: 'DESC'
}
], 'ASC');
In this second form, the sort configs are applied in order, with later sorters sorting within earlier sorters' results.
For example, if two records with the same name are present they will also be sorted by salary if given the sort configs
above. Any number of sort configs can be added.</description></method><method name="sum" scope="instance"><description>Sums the value of property for each record between start
and end and returns the result.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method></methods></class><class superclass="Ext.dd.DragZone" type="Ext.grid.GridDragZone"><description>A customized implementation of a DragZone which provides default implementations of two of the
template methods of DragZone to enable dragging of the selected rows of a GridPanel.
A cooperating DropZone must be created who's template method implementations of
onNodeEnter, onNodeOver,
onNodeOut and onNodeDrop are able
to process the data which is provided.</description><constructors/><properties/><methods><method name="addInvalidHandleClass" scope="instance"><description>Lets you specify a css class of elements that will not initiate a drag</description></method><method name="addInvalidHandleId" scope="instance"><description>Lets you to specify an element id for a child of a drag handle
that should not initiate a drag</description></method><method name="addInvalidHandleType" scope="instance"><description>Allows you to specify a tag name that should not start a drag operation
when clicked.  This is designed to facilitate embedding links within a
drag handle that do something other than start the drag.</description></method><method name="addToGroup" scope="instance"><description>Add this instance to a group of related drag/drop objects.  All
instances belong to at least one group, and can belong to as many
groups as needed.</description></method><method name="afterDragDrop" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action
after a valid drag drop has occurred by providing an implementation.</description></method><method name="afterDragEnter" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action
when the dragged item enters the drop target by providing an implementation.</description></method><method name="afterDragOut" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action
after the dragged item is dragged out of the target without dropping.</description></method><method name="afterDragOver" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action
while the dragged item is over the drop target by providing an implementation.</description></method><method name="afterInvalidDrop" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action
after an invalid drop has occurred by providing an implementation.</description></method><method name="afterRepair" scope="instance"><description>An empty immplementation. Implement this to provide behaviour after a repair of an invalid drop. An implementation might highlight
the selected rows to show that they have not been dragged.</description></method><method name="alignElWithMouse" scope="instance"><description>Sets the element to the location of the mousedown or click event,
maintaining the cursor location relative to the location on the element
that was clicked.  Override this if you want to place the element in a
location other than where the cursor is.</description></method><method name="applyConfig" scope="instance"><description>Sets up config options specific to this class. Overrides
Ext.dd.DragDrop, but all versions of this method through the
inheritance chain are called</description></method><method name="autoOffset" scope="instance"><description>Sets the pointer offset to the distance between the linked element's top
left corner and the location the element was clicked</description></method><method name="b4Drag" scope="instance"><description>Event that fires prior to the onDrag event.  Overrides
Ext.dd.DragDrop.</description></method><method name="b4MouseDown" scope="instance"><description>Event that fires prior to the onMouseDown event.  Overrides
Ext.dd.DragDrop.</description></method><method name="beforeDragDrop" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action before the dragged
item is dropped onto the target and optionally cancel the onDragDrop.</description></method><method name="beforeDragEnter" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action
before the dragged item enters the drop target and optionally cancel the onDragEnter.</description></method><method name="beforeDragOut" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action before the dragged
item is dragged out of the target without dropping, and optionally cancel the onDragOut.</description></method><method name="beforeDragOver" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action
while the dragged item is over the drop target and optionally cancel the onDragOver.</description></method><method name="beforeInvalidDrop" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action after an invalid
drop has occurred.</description></method><method name="cachePosition" scope="instance"><description>Saves the most recent position so that we can reset the constraints and
tick marks on-demand.  We need to know this so that we can calculate the
number of pixels the element is offset from its original position.</description></method><method name="clearConstraints" scope="instance"><description>Clears any constraints applied to this instance.  Also clears ticks
since they can't exist independent of a constraint at this time.</description></method><method name="clearTicks" scope="instance"><description>Clears any tick interval defined for this instance</description></method><method name="constrainTo" scope="instance"><description>Initializes the drag drop object's constraints to restrict movement to a certain element.
Usage:
 var dd = new Ext.dd.DDProxy(&quot;dragDiv1&quot;, &quot;proxytest&quot;,
                { dragElId: &quot;existingProxyDiv&quot; });
 dd.startDrag = function(){
     this.constrainTo(&quot;parent-id&quot;);
 };
Or you can initalize it using the Ext.Element object:
 Ext.get(&quot;dragDiv1&quot;).initDDProxy(&quot;proxytest&quot;, {dragElId: &quot;existingProxyDiv&quot;}, {
     startDrag : function(){
         this.constrainTo(&quot;parent-id&quot;);
     }
 });</description></method><method name="createFrame" scope="instance"><description>Creates the proxy element if it does not yet exist</description></method><method name="endDrag" scope="instance"><description>Fired when we are done dragging the object</description></method><method name="getDragData" scope="instance"><description>The provided implementation of the getDragData method which collects the data to be dragged from the GridPanel on mousedown.
This data is available for processing in the onNodeEnter, onNodeOver,
onNodeOut and onNodeDrop methods of a cooperating DropZone.
The data object contains the following properties:
grid : Ext.Grid.GridPanelThe GridPanel from which the data is being dragged.
ddel : htmlElementAn htmlElement which provides the &quot;picture&quot; of the data being dragged.
rowIndex : NumberThe index of the row which receieved the mousedown gesture which triggered the drag.
selections : ArrayAn Array of the selected Records which are being dragged from the GridPanel.
</description></method><method name="getDragEl" scope="instance"><description>Returns a reference to the actual element to drag.  By default this is
the same as the html element, but it can be assigned to another
element. An example of this can be found in Ext.dd.DDProxy</description></method><method name="getEl" scope="instance"><description>Returns a reference to the linked element</description></method><method name="getProxy" scope="instance"><description>Returns the drag source's underlying Ext.dd.StatusProxy</description></method><method name="getRepairXY" scope="instance"><description>An empty implementation. Implement this to provide coordinates for the drag proxy to slide back to after an invalid drop.
Called before a repair of an invalid drop to get the XY to animate to.</description></method><method name="hideProxy" scope="instance"><description>Hides the drag source's Ext.dd.StatusProxy</description></method><method name="init" scope="instance"><description>Sets up the DragDrop object.  Must be called in the constructor of any
Ext.dd.DragDrop subclass</description></method><method name="initFrame" scope="instance"><description>Initialization for the drag frame element.  Must be called in the
constructor of all subclasses</description></method><method name="initTarget" scope="instance"><description>Initializes Targeting functionality only... the object does not
get a mousedown handler.</description></method><method name="isLocked" scope="instance"><description>Returns true if this instance is locked, or the drag drop mgr is locked
(meaning that all drag/drop is disabled on the page.)</description></method><method name="isValidHandleChild" scope="instance"><description>Checks the tag exclusion list to see if this click should be ignored</description></method><method name="lock" scope="instance"><description>Lock this instance</description></method><method name="onAvailable" scope="instance"><description>Override the onAvailable method to do what is needed after the initial
position was determined.</description></method><method name="onBeforeDrag" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action before the initial
drag event begins and optionally cancel it.</description></method><method name="onDrag" scope="instance"><description>Abstract method called during the onMouseMove event while dragging an
object.</description></method><method name="onDragDrop" scope="instance"><description>Abstract method called when this item is dropped on another DragDrop
obj</description></method><method name="onDragEnter" scope="instance"><description>Abstract method called when this element fist begins hovering over
another DragDrop obj</description></method><method name="onDragOut" scope="instance"><description>Abstract method called when we are no longer hovering over an element</description></method><method name="onDragOver" scope="instance"><description>Abstract method called when this element is hovering over another
DragDrop obj</description></method><method name="onInitDrag" scope="instance"><description>The provided implementation of the onInitDrag method. Sets the innerHTML of the drag proxy which provides the &quot;picture&quot;
of the data being dragged.
The innerHTML data is found by calling the owning GridPanel's getDragDropText.</description></method><method name="onInvalidDrop" scope="instance"><description>Abstract method called when this item is dropped on an area with no
drop target</description></method><method name="onMouseDown" scope="instance"><description>Event handler that fires when a drag/drop obj gets a mousedown</description></method><method name="onMouseUp" scope="instance"><description>Event handler that fires when a drag/drop obj gets a mouseup</description></method><method name="onStartDrag" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action once the initial
drag event has begun.  The drag cannot be canceled from this function.</description></method><method name="removeFromGroup" scope="instance"><description>Remove's this instance from the supplied interaction group</description></method><method name="removeInvalidHandleClass" scope="instance"><description>Unsets an invalid css class</description></method><method name="removeInvalidHandleId" scope="instance"><description>Unsets an invalid handle id</description></method><method name="removeInvalidHandleType" scope="instance"><description>Unsets an excluded tag name set by addInvalidHandleType</description></method><method name="resetConstraints" scope="instance"><description>resetConstraints must be called if you manually reposition a dd element.</description></method><method name="setDelta" scope="instance"><description>Sets the pointer offset.  You can call this directly to force the
offset to be in a particular location (e.g., pass in 0,0 to set it
to the center of the object)</description></method><method name="setDragElId" scope="instance"><description>Allows you to specify that an element other than the linked element
will be moved with the cursor during a drag</description></method><method name="setDragElPos" scope="instance"><description>Sets the drag element to the location of the mousedown or click event,
maintaining the cursor location relative to the location on the element
that was clicked.  Override this if you want to place the element in a
location other than where the cursor is.</description></method><method name="setHandleElId" scope="instance"><description>Allows you to specify a child of the linked element that should be
used to initiate the drag operation.  An example of this would be if
you have a content div with text and links.  Clicking anywhere in the
content area would normally start the drag operation.  Use this method
to specify that an element inside of the content div is the element
that starts the drag operation.</description></method><method name="setInitPosition" scope="instance"><description>Stores the initial placement of the linked element.</description></method><method name="setOuterHandleElId" scope="instance"><description>Allows you to set an element outside of the linked element as a drag
handle</description></method><method name="setPadding" scope="instance"><description>Configures the padding for the target zone in px.  Effectively expands
(or reduces) the virtual object size for targeting calculations.
Supports css-style shorthand; if only one parameter is passed, all sides
will have that padding, and if only two are passed, the top and bottom
will have the first param, the left and right the second.</description></method><method name="setXConstraint" scope="instance"><description>By default, the element can be dragged any place on the screen.  Use
this method to limit the horizontal travel of the element.  Pass in
0,0 for the parameters if you want to lock the drag to the y axis.</description></method><method name="setYConstraint" scope="instance"><description>By default, the element can be dragged any place on the screen.  Set
this to limit the vertical travel of the element.  Pass in 0,0 for the
parameters if you want to lock the drag to the x axis.</description></method><method name="startDrag" scope="instance"><description>Abstract method called after a drag/drop object is clicked
and the drag or mousedown time thresholds have beeen met.</description></method><method name="toString" scope="instance"><description>toString method</description></method><method name="unlock" scope="instance"><description>Unlock this instace</description></method><method name="unreg" scope="instance"><description>Remove all drag and drop hooks for this element</description></method></methods></class><class superclass="Ext.layout.boxOverflow.Scroller" type="Ext.layout.boxOverflow.HorizontalScroller"><description>Description</description><constructors/><properties/><methods><method name="getScrollPosition" scope="instance"><description>Returns the current scroll position of the innerCt element</description></method><method name="scrollToItem" scope="instance"><description>Scrolls to the given component.</description></method></methods></class><class superclass="Ext.util.Observable" type="Ext.tree.MultiSelectionModel"><description>Multi selection for a TreePanel.</description><constructors/><properties/><methods><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="clearSelections" scope="instance"><description>Clear all selections</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="getSelectedNodes" scope="instance"><description>Returns an array of the selected nodes</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="isSelected" scope="instance"><description>Returns true if the node is selected</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="select" scope="instance"><description>Select a node.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="unselect" scope="instance"><description>Deselect a node.</description></method></methods></class><class superclass="Object" type="Ext.util.Format"><description>Reusable data formatting functions</description><constructors/><properties/><methods><method name="capitalize" scope="instance"><description>Converts the first character only of a string to upper case</description></method><method name="date" scope="instance"><description>Parse a value into a formatted date using the specified format pattern.</description></method><method name="dateRenderer" scope="instance"><description>Returns a date rendering function that can be reused to apply a date format multiple times efficiently</description></method><method name="defaultValue" scope="instance"><description>Checks a reference and converts it to the default value if it's empty</description></method><method name="ellipsis" scope="instance"><description>Truncate a string and add an ellipsis ('...') to the end if it exceeds the specified length</description></method><method name="fileSize" scope="instance"><description>Simple format for a file size (xxx bytes, xxx KB, xxx MB)</description></method><method name="htmlDecode" scope="instance"><description>Convert certain characters (&amp;, &lt;, &gt;, and ') from their HTML character equivalents.</description></method><method name="htmlEncode" scope="instance"><description>Convert certain characters (&amp;, &lt;, &gt;, and ') to their HTML character equivalents for literal display in web pages.</description></method><method name="lowercase" scope="instance"><description>Converts a string to all lower case letters</description></method><method name="math" scope="instance"><description>It does simple math for use in a template, for example:var tpl = new Ext.Template('{value} * 10 = {value:math(&quot;* 10&quot;)}');</description></method><method name="nl2br" scope="instance"><description>Converts newline characters to the HTML tag &lt;br/&gt;</description></method><method name="number" scope="instance"><description>Formats the number according to the format string.
examples (123456.789):

0 - (123456) show only digits, no precision
0.00 - (123456.78) show only digits, 2 precision
0.0000 - (123456.7890) show only digits, 4 precision
0,000 - (123,456) show comma and digits, no precision
0,000.00 - (123,456.78) show comma and digits, 2 precision
0,0.00 - (123,456.78) shortcut method, show comma and digits, 2 precision
To reverse the grouping (,) and decimal (.) for international numbers, add /i to the end.
For example: 0.000,00/i
</description></method><method name="numberRenderer" scope="instance"><description>Returns a number rendering function that can be reused to apply a number format multiple times efficiently</description></method><method name="plural" scope="instance"><description>Selectively do a plural form of a word based on a numeric value. For example, in a template,
{commentCount:plural(&quot;Comment&quot;)}  would result in &quot;1 Comment&quot; if commentCount was 1 or would be &quot;x Comments&quot;
if the value is 0 or greater than 1.</description></method><method name="round" scope="instance"><description>Rounds the passed number to the required decimal precision.</description></method><method name="stripScripts" scope="instance"><description>Strips all script tags</description></method><method name="stripTags" scope="instance"><description>Strips all HTML tags</description></method><method name="substr" scope="instance"><description>Returns a substring from within an original string</description></method><method name="trim" scope="instance"><description>Trims any whitespace from either side of a string</description></method><method name="undef" scope="instance"><description>Checks a reference and converts it to empty string if it is undefined</description></method><method name="uppercase" scope="instance"><description>Converts a string to all upper case letters</description></method><method name="usMoney" scope="instance"><description>Format a number as US currency</description></method></methods></class><class superclass="Object" type="Ext.Error"><description>A base error class. Future implementations are intended to provide more
robust error handling throughout the framework (in the debug build only)
to check for common errors and problems. The messages issued by this class
will aid error checking. Error checks will be automatically removed in the
production build so that performance is not negatively impacted.
Some sample messages currently implemented:
&quot;DataProxy attempted to execute an API-action but found an undefined
url / function. Please review your Proxy url/api-configuration.&quot;

&quot;Could not locate your &quot;root&quot; property in your server response.
Please review your JsonReader config to ensure the config-property
&quot;root&quot; matches the property your server-response.  See the JsonReader
docs for additional assistance.&quot;

An example of the code used for generating error messages:try {
    generateError({
        foo: 'bar'
    });
}
catch (e) {
    console.error(e);
}
function generateError(data) {
    throw new Ext.Error('foo-error', data);
}</description><constructors/><properties/><methods><method name="getMessage" scope="instance"><description>getMessage</description></method><method name="getName" scope="instance"><description>getName</description></method><method name="toJson" scope="instance"><description>toJson</description></method></methods></class><class superclass="Object" type="Ext.state.Manager"><description>This is the global state manager. By default all components that are &quot;state aware&quot; check this class
for state information if you don't pass them a custom state provider. In order for this class
to be useful, it must be initialized with a provider when your application initializes. Example usage:
 // in your initialization function
init : function(){
   Ext.state.Manager.setProvider(new Ext.state.CookieProvider());
   var win = new Window(...);
   win.restoreState();
}</description><constructors/><properties/><methods><method name="clear" scope="instance"><description>Clears a value from the state</description></method><method name="get" scope="instance"><description>Returns the current value for a key</description></method><method name="getProvider" scope="instance"><description>Gets the currently configured state provider</description></method><method name="set" scope="instance"><description>Sets the value for a key</description></method><method name="setProvider" scope="instance"><description>Configures the default state provider for your application</description></method></methods></class><class superclass="Object" type="String"><description>These functions are available as static methods on the JavaScript String object.</description><constructors/><properties/><methods><method name="escape" scope="instance"><description>Escapes the passed string for ' and \</description></method><method name="format" scope="instance"><description>Allows you to define a tokenized string and pass an arbitrary number of arguments to replace the tokens.  Each
token must be unique, and must increment in the format {0}, {1}, etc.  Example usage:
var cls = 'my-class', text = 'Some text';
var s = String.format('&lt;div class=&quot;{0}&quot;&gt;{1}&lt;/div&gt;', cls, text);
// s now contains the string: '&lt;div class=&quot;my-class&quot;&gt;Some text&lt;/div&gt;'</description></method><method name="leftPad" scope="instance"><description>Pads the left side of a string with a specified character.  This is especially useful
for normalizing number and date strings.  Example usage:
var s = String.leftPad('123', 5, '0');
// s now contains the string: '00123'</description></method><method name="toggle" scope="instance"><description>Utility function that allows you to easily switch a string between two alternating values.  The passed value
is compared to the current string, and if they are equal, the other value that was passed in is returned.  If
they are already different, the first value passed in is returned.  Note that this method returns the new value
but does not change the current string.
// alternate sort directions
sort = sort.toggle('ASC', 'DESC');

// instead of conditional logic:
sort = (sort == 'ASC' ? 'DESC' : 'ASC');</description></method><method name="trim" scope="instance"><description>Trims whitespace from either end of a string, leaving spaces within the string intact.  Example:
var s = '  foo bar  ';
alert('-' + s + '-');         //alerts &quot;- foo bar -&quot;
alert('-' + s.trim() + '-');  //alerts &quot;-foo bar-&quot;</description></method></methods></class><class superclass="Ext.list.Column" type="Ext.list.BooleanColumn"><description>A Column definition class which renders boolean data fields.  See the xtype
config option of Ext.list.Column for more details.</description><constructors/><properties/><methods/></class><class superclass="Ext.chart.Chart" type="Ext.chart.CartesianChart"><description/><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bindStore" scope="instance"><description>Changes the data store bound to this chart and refreshes it.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setSeriesStyles" scope="instance"><description>Sets the styles on all series in the Chart.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setStyle" scope="instance"><description>Sets a single style value on the Chart instance.</description></method><method name="setStyles" scope="instance"><description>Resets all styles on the Chart instance.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method></methods></class><class superclass="Ext.Error" type="Ext.data.DataProxy.Error"><description>DataProxy Error extension.
constructor</description><constructors/><properties/><methods><method name="getMessage" scope="instance"><description>getMessage</description></method><method name="getName" scope="instance"><description>getName</description></method><method name="toJson" scope="instance"><description>toJson</description></method></methods></class><class superclass="Object" type="Ext.dd.ScrollManager"><description>Provides automatic scrolling of overflow regions in the page during drag operations.
The ScrollManager configs will be used as the defaults for any scroll container registered with it,
but you can also override most of the configs per scroll container by adding a 
ddScrollConfig object to the target element that contains these properties: hthresh,
vthresh, increment and frequency.  Example usage:
var el = Ext.get('scroll-ct');
el.ddScrollConfig = {
    vthresh: 50,
    hthresh: -1,
    frequency: 100,
    increment: 200
};
Ext.dd.ScrollManager.register(el);
Note: This class uses &quot;Point Mode&quot; and is untested in &quot;Intersect Mode&quot;.</description><constructors/><properties/><methods><method name="refreshCache" scope="instance"><description>Manually trigger a cache refresh.</description></method><method name="register" scope="instance"><description>Registers new overflow element(s) to auto scroll</description></method><method name="unregister" scope="instance"><description>Unregisters overflow element(s) so they are no longer scrolled</description></method></methods></class><class superclass="Ext.util.Observable" type="Ext.grid.AbstractSelectionModel"><description>Abstract base class for grid SelectionModels.  It provides the interface that should be
implemented by descendant classes.  This class should not be directly instantiated.</description><constructors/><properties/><methods><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="isLocked" scope="instance"><description>Returns true if the selections are locked.</description></method><method name="lock" scope="instance"><description>Locks the selections.</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="unlock" scope="instance"><description>Unlocks the selections.</description></method></methods></class><class superclass="Object" type="Ext.data.Record"><description>Instances of this class encapsulate both Record definition information, and Record
value information for use in Ext.data.Store objects, or any code which needs
to access Records cached in an Ext.data.Store object.
Constructors for this class are generated by passing an Array of field definition objects to create.
Instances are usually only created by Ext.data.Reader implementations when processing unformatted data
objects.
Note that an instance of a Record class may only belong to one Store at a time.
In order to copy data from one Store to another, use the copy method to create an exact
copy of the Record, and insert the new instance into the other Store.
When serializing a Record for submission to the server, be aware that it contains many private
properties, and also a reference to its owning Store which in turn holds references to its Records.
This means that a whole Record may not be encoded using Ext.util.JSON.encode. Instead, use the
data and id properties.
Record objects generated by this constructor inherit all the methods of Ext.data.Record listed below.</description><constructors/><properties/><methods><method name="Record.id" scope="instance"><description>Generates a sequential id. This method is typically called when a record is created
and no id has been specified. The returned id takes the form:
&#123;PREFIX}-&#123;AUTO_ID}.
PREFIX : StringExt.data.Record.PREFIX
(defaults to 'ext-record')
AUTO_ID : StringExt.data.Record.AUTO_ID
(defaults to 1 initially)
</description></method><method name="beginEdit" scope="instance"><description>Begin an edit. While in edit mode, no events (e.g.. the update event)
are relayed to the containing store.
See also: endEdit and cancelEdit.</description></method><method name="cancelEdit" scope="instance"><description>Cancels all changes made in the current edit operation.</description></method><method name="commit" scope="instance"><description>Usually called by the Ext.data.Store which owns the Record.
Commits all changes made to the Record since either creation, or the last commit operation.
Developers should subscribe to the Ext.data.Store.update event
to have their code notified of commit operations.</description></method><method name="copy" scope="instance"><description>Creates a copy (clone) of this Record.</description></method><method name="create" scope="instance"><description>Generate a constructor for a specific Record layout.</description></method><method name="endEdit" scope="instance"><description>End an edit. If any data was modified, the containing store is notified
(ie, the store's update event will fire).</description></method><method name="get" scope="instance"><description>Get the value of the named field.</description></method><method name="getChanges" scope="instance"><description>Gets a hash of only the fields that have been modified since this Record was created or commited.</description></method><method name="isModified" scope="instance"><description>Returns true if the passed field name has been modified
since the load or last commit.</description></method><method name="isValid" scope="instance"><description>By default returns false if any field within the
record configured with Ext.data.Field.allowBlank = false returns
true from an Ext.isempty test.</description></method><method name="markDirty" scope="instance"><description>Marks this Record as dirty.  This method
is used interally when adding phantom records to a
writer enabled store.
Marking a record dirty causes the phantom to
be returned by Ext.data.Store.getModifiedRecords where it will
have a create action composed for it during store save
operations.</description></method><method name="reject" scope="instance"><description>Usually called by the Ext.data.Store which owns the Record.
Rejects all changes made to the Record since either creation, or the last commit operation.
Modified fields are reverted to their original values.
Developers should subscribe to the Ext.data.Store.update event
to have their code notified of reject operations.</description></method><method name="set" scope="instance"><description>Set the named field to the specified value.  For example:
// record has a field named 'firstname'
var Employee = Ext.data.Record.create([
    {name: 'firstname'},
    ...
]);

// update the 2nd record in the store:
var rec = myStore.getAt(1);

// set the value (shows dirty flag):
rec.set('firstname', 'Betty');

// commit the change (removes dirty flag):
rec.commit();

// update the record in the store, bypass setting dirty flag,
// and do not store the change in the modified records
rec.data['firstname'] = 'Wilma'; // updates record, but not the view
rec.commit(); // updates the view
Notes:
If the store has a writer and autoSave=true, each set()
will execute an XHR to the server.
Use beginEdit to prevent the store's update
event firing while using set().
Use endEdit to have the store's update
event fire.
</description></method></methods></class><class superclass="Ext.Toolbar.Item" type="Ext.Toolbar.Spacer"><description>A simple element that adds extra horizontal space between items in a toolbar.
By default a 2px wide space is added via css specification:.x-toolbar .xtb-spacer {
    width:2px;
}
Example usage:
new Ext.Panel({
    tbar : [
        'Item 1',
        {xtype: 'tbspacer'}, // or ' '
        'Item 2',
        // space width is also configurable via javascript
        {xtype: 'tbspacer', width: 50}, // add a 50px space
        'Item 3'
    ]
});</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method></methods></class><class superclass="Ext.chart.CartesianSeries" type="Ext.chart.LineSeries"><description>LineSeries class for the charts widget.</description><constructors/><properties/><methods/></class><class superclass="Ext.dd.DragSource" type="Ext.dd.DragZone"><description>This class provides a container DD instance that allows dragging of multiple child source nodes.
This class does not move the drag target nodes, but a proxy element which may contain
any DOM structure you wish. The DOM element to show in the proxy is provided by either a
provided implementation of getDragData, or by registered draggables registered with Ext.dd.Registry
If you wish to provide draggability for an arbitrary number of DOM nodes, each of which represent some
application object (For example nodes in a DataView) then use of this class
is the most efficient way to &quot;activate&quot; those nodes.
By default, this class requires that draggable child nodes are registered with Ext.dd.Registry.
However a simpler way to allow a DragZone to manage any number of draggable elements is to configure
the DragZone with  an implementation of the getDragData method which interrogates the passed
mouse event to see if it has taken place within an element, or class of elements. This is easily done
by using the event's getTarget method to identify a node based on a
Ext.DomQuery selector. For example, to make the nodes of a DataView draggable, use the following
technique. Knowledge of the use of the DataView is required:myDataView.on('render', function(v) {
    myDataView.dragZone = new Ext.dd.DragZone(v.getEl(), {

//      On receipt of a mousedown event, see if it is within a DataView node.
//      Return a drag data object if so.
        getDragData: function(e) {

//          Use the DataView's own itemSelector (a mandatory property) to
//          test if the mousedown is within one of the DataView's nodes.
            var sourceEl = e.getTarget(v.itemSelector, 10);

//          If the mousedown is within a DataView node, clone the node to produce
//          a ddel element for use by the drag proxy. Also add application data
//          to the returned data object.
            if (sourceEl) {
                d = sourceEl.cloneNode(true);
                d.id = Ext.id();
                return {
                    ddel: d,
                    sourceEl: sourceEl,
                    repairXY: Ext.fly(sourceEl).getXY(),
                    sourceStore: v.store,
                    draggedRecord: v.getRecord(sourceEl)
                }
            }
        },

//      Provide coordinates for the proxy to slide back to on failed drag.
//      This is the original XY coordinates of the draggable element captured
//      in the getDragData method.
        getRepairXY: function() {
            return this.dragData.repairXY;
        }
    });
});
See the DropZone documentation for details about building a DropZone which
cooperates with this DragZone.</description><constructors/><properties/><methods><method name="addInvalidHandleClass" scope="instance"><description>Lets you specify a css class of elements that will not initiate a drag</description></method><method name="addInvalidHandleId" scope="instance"><description>Lets you to specify an element id for a child of a drag handle
that should not initiate a drag</description></method><method name="addInvalidHandleType" scope="instance"><description>Allows you to specify a tag name that should not start a drag operation
when clicked.  This is designed to facilitate embedding links within a
drag handle that do something other than start the drag.</description></method><method name="addToGroup" scope="instance"><description>Add this instance to a group of related drag/drop objects.  All
instances belong to at least one group, and can belong to as many
groups as needed.</description></method><method name="afterDragDrop" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action
after a valid drag drop has occurred by providing an implementation.</description></method><method name="afterDragEnter" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action
when the dragged item enters the drop target by providing an implementation.</description></method><method name="afterDragOut" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action
after the dragged item is dragged out of the target without dropping.</description></method><method name="afterDragOver" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action
while the dragged item is over the drop target by providing an implementation.</description></method><method name="afterInvalidDrop" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action
after an invalid drop has occurred by providing an implementation.</description></method><method name="afterRepair" scope="instance"><description>Called after a repair of an invalid drop. By default, highlights this.dragData.ddel</description></method><method name="alignElWithMouse" scope="instance"><description>Sets the element to the location of the mousedown or click event,
maintaining the cursor location relative to the location on the element
that was clicked.  Override this if you want to place the element in a
location other than where the cursor is.</description></method><method name="applyConfig" scope="instance"><description>Sets up config options specific to this class. Overrides
Ext.dd.DragDrop, but all versions of this method through the
inheritance chain are called</description></method><method name="autoOffset" scope="instance"><description>Sets the pointer offset to the distance between the linked element's top
left corner and the location the element was clicked</description></method><method name="b4Drag" scope="instance"><description>Event that fires prior to the onDrag event.  Overrides
Ext.dd.DragDrop.</description></method><method name="b4MouseDown" scope="instance"><description>Event that fires prior to the onMouseDown event.  Overrides
Ext.dd.DragDrop.</description></method><method name="beforeDragDrop" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action before the dragged
item is dropped onto the target and optionally cancel the onDragDrop.</description></method><method name="beforeDragEnter" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action
before the dragged item enters the drop target and optionally cancel the onDragEnter.</description></method><method name="beforeDragOut" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action before the dragged
item is dragged out of the target without dropping, and optionally cancel the onDragOut.</description></method><method name="beforeDragOver" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action
while the dragged item is over the drop target and optionally cancel the onDragOver.</description></method><method name="beforeInvalidDrop" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action after an invalid
drop has occurred.</description></method><method name="cachePosition" scope="instance"><description>Saves the most recent position so that we can reset the constraints and
tick marks on-demand.  We need to know this so that we can calculate the
number of pixels the element is offset from its original position.</description></method><method name="clearConstraints" scope="instance"><description>Clears any constraints applied to this instance.  Also clears ticks
since they can't exist independent of a constraint at this time.</description></method><method name="clearTicks" scope="instance"><description>Clears any tick interval defined for this instance</description></method><method name="constrainTo" scope="instance"><description>Initializes the drag drop object's constraints to restrict movement to a certain element.
Usage:
 var dd = new Ext.dd.DDProxy(&quot;dragDiv1&quot;, &quot;proxytest&quot;,
                { dragElId: &quot;existingProxyDiv&quot; });
 dd.startDrag = function(){
     this.constrainTo(&quot;parent-id&quot;);
 };
Or you can initalize it using the Ext.Element object:
 Ext.get(&quot;dragDiv1&quot;).initDDProxy(&quot;proxytest&quot;, {dragElId: &quot;existingProxyDiv&quot;}, {
     startDrag : function(){
         this.constrainTo(&quot;parent-id&quot;);
     }
 });</description></method><method name="createFrame" scope="instance"><description>Creates the proxy element if it does not yet exist</description></method><method name="endDrag" scope="instance"><description>Fired when we are done dragging the object</description></method><method name="getDragData" scope="instance"><description>Called when a mousedown occurs in this container. Looks in Ext.dd.Registry
for a valid target to drag based on the mouse down. Override this method
to provide your own lookup logic (e.g. finding a child by class name). Make sure your returned
object has a &quot;ddel&quot; attribute (with an HTML Element) for other functions to work.</description></method><method name="getDragEl" scope="instance"><description>Returns a reference to the actual element to drag.  By default this is
the same as the html element, but it can be assigned to another
element. An example of this can be found in Ext.dd.DDProxy</description></method><method name="getEl" scope="instance"><description>Returns a reference to the linked element</description></method><method name="getProxy" scope="instance"><description>Returns the drag source's underlying Ext.dd.StatusProxy</description></method><method name="getRepairXY" scope="instance"><description>Called before a repair of an invalid drop to get the XY to animate to. By default returns
the XY of this.dragData.ddel</description></method><method name="hideProxy" scope="instance"><description>Hides the drag source's Ext.dd.StatusProxy</description></method><method name="init" scope="instance"><description>Sets up the DragDrop object.  Must be called in the constructor of any
Ext.dd.DragDrop subclass</description></method><method name="initFrame" scope="instance"><description>Initialization for the drag frame element.  Must be called in the
constructor of all subclasses</description></method><method name="initTarget" scope="instance"><description>Initializes Targeting functionality only... the object does not
get a mousedown handler.</description></method><method name="isLocked" scope="instance"><description>Returns true if this instance is locked, or the drag drop mgr is locked
(meaning that all drag/drop is disabled on the page.)</description></method><method name="isValidHandleChild" scope="instance"><description>Checks the tag exclusion list to see if this click should be ignored</description></method><method name="lock" scope="instance"><description>Lock this instance</description></method><method name="onAvailable" scope="instance"><description>Override the onAvailable method to do what is needed after the initial
position was determined.</description></method><method name="onBeforeDrag" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action before the initial
drag event begins and optionally cancel it.</description></method><method name="onDrag" scope="instance"><description>Abstract method called during the onMouseMove event while dragging an
object.</description></method><method name="onDragDrop" scope="instance"><description>Abstract method called when this item is dropped on another DragDrop
obj</description></method><method name="onDragEnter" scope="instance"><description>Abstract method called when this element fist begins hovering over
another DragDrop obj</description></method><method name="onDragOut" scope="instance"><description>Abstract method called when we are no longer hovering over an element</description></method><method name="onDragOver" scope="instance"><description>Abstract method called when this element is hovering over another
DragDrop obj</description></method><method name="onInitDrag" scope="instance"><description>Called once drag threshold has been reached to initialize the proxy element. By default, it clones the
this.dragData.ddel</description></method><method name="onInvalidDrop" scope="instance"><description>Abstract method called when this item is dropped on an area with no
drop target</description></method><method name="onMouseDown" scope="instance"><description>Event handler that fires when a drag/drop obj gets a mousedown</description></method><method name="onMouseUp" scope="instance"><description>Event handler that fires when a drag/drop obj gets a mouseup</description></method><method name="onStartDrag" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action once the initial
drag event has begun.  The drag cannot be canceled from this function.</description></method><method name="removeFromGroup" scope="instance"><description>Remove's this instance from the supplied interaction group</description></method><method name="removeInvalidHandleClass" scope="instance"><description>Unsets an invalid css class</description></method><method name="removeInvalidHandleId" scope="instance"><description>Unsets an invalid handle id</description></method><method name="removeInvalidHandleType" scope="instance"><description>Unsets an excluded tag name set by addInvalidHandleType</description></method><method name="resetConstraints" scope="instance"><description>resetConstraints must be called if you manually reposition a dd element.</description></method><method name="setDelta" scope="instance"><description>Sets the pointer offset.  You can call this directly to force the
offset to be in a particular location (e.g., pass in 0,0 to set it
to the center of the object)</description></method><method name="setDragElId" scope="instance"><description>Allows you to specify that an element other than the linked element
will be moved with the cursor during a drag</description></method><method name="setDragElPos" scope="instance"><description>Sets the drag element to the location of the mousedown or click event,
maintaining the cursor location relative to the location on the element
that was clicked.  Override this if you want to place the element in a
location other than where the cursor is.</description></method><method name="setHandleElId" scope="instance"><description>Allows you to specify a child of the linked element that should be
used to initiate the drag operation.  An example of this would be if
you have a content div with text and links.  Clicking anywhere in the
content area would normally start the drag operation.  Use this method
to specify that an element inside of the content div is the element
that starts the drag operation.</description></method><method name="setInitPosition" scope="instance"><description>Stores the initial placement of the linked element.</description></method><method name="setOuterHandleElId" scope="instance"><description>Allows you to set an element outside of the linked element as a drag
handle</description></method><method name="setPadding" scope="instance"><description>Configures the padding for the target zone in px.  Effectively expands
(or reduces) the virtual object size for targeting calculations.
Supports css-style shorthand; if only one parameter is passed, all sides
will have that padding, and if only two are passed, the top and bottom
will have the first param, the left and right the second.</description></method><method name="setXConstraint" scope="instance"><description>By default, the element can be dragged any place on the screen.  Use
this method to limit the horizontal travel of the element.  Pass in
0,0 for the parameters if you want to lock the drag to the y axis.</description></method><method name="setYConstraint" scope="instance"><description>By default, the element can be dragged any place on the screen.  Set
this to limit the vertical travel of the element.  Pass in 0,0 for the
parameters if you want to lock the drag to the x axis.</description></method><method name="startDrag" scope="instance"><description>Abstract method called after a drag/drop object is clicked
and the drag or mousedown time thresholds have beeen met.</description></method><method name="toString" scope="instance"><description>toString method</description></method><method name="unlock" scope="instance"><description>Unlock this instace</description></method><method name="unreg" scope="instance"><description>Remove all drag and drop hooks for this element</description></method></methods></class><class superclass="Ext.dd.DragZone" type="Ext.tree.TreeDragZone"><description/><constructors/><properties/><methods><method name="addInvalidHandleClass" scope="instance"><description>Lets you specify a css class of elements that will not initiate a drag</description></method><method name="addInvalidHandleId" scope="instance"><description>Lets you to specify an element id for a child of a drag handle
that should not initiate a drag</description></method><method name="addInvalidHandleType" scope="instance"><description>Allows you to specify a tag name that should not start a drag operation
when clicked.  This is designed to facilitate embedding links within a
drag handle that do something other than start the drag.</description></method><method name="addToGroup" scope="instance"><description>Add this instance to a group of related drag/drop objects.  All
instances belong to at least one group, and can belong to as many
groups as needed.</description></method><method name="afterDragDrop" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action
after a valid drag drop has occurred by providing an implementation.</description></method><method name="afterDragEnter" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action
when the dragged item enters the drop target by providing an implementation.</description></method><method name="afterDragOut" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action
after the dragged item is dragged out of the target without dropping.</description></method><method name="afterDragOver" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action
while the dragged item is over the drop target by providing an implementation.</description></method><method name="afterInvalidDrop" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action
after an invalid drop has occurred by providing an implementation.</description></method><method name="afterRepair" scope="instance"><description>Called after a repair of an invalid drop. By default, highlights this.dragData.ddel</description></method><method name="alignElWithMouse" scope="instance"><description>Sets the element to the location of the mousedown or click event,
maintaining the cursor location relative to the location on the element
that was clicked.  Override this if you want to place the element in a
location other than where the cursor is.</description></method><method name="applyConfig" scope="instance"><description>Sets up config options specific to this class. Overrides
Ext.dd.DragDrop, but all versions of this method through the
inheritance chain are called</description></method><method name="autoOffset" scope="instance"><description>Sets the pointer offset to the distance between the linked element's top
left corner and the location the element was clicked</description></method><method name="b4Drag" scope="instance"><description>Event that fires prior to the onDrag event.  Overrides
Ext.dd.DragDrop.</description></method><method name="b4MouseDown" scope="instance"><description>Event that fires prior to the onMouseDown event.  Overrides
Ext.dd.DragDrop.</description></method><method name="beforeDragDrop" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action before the dragged
item is dropped onto the target and optionally cancel the onDragDrop.</description></method><method name="beforeDragEnter" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action
before the dragged item enters the drop target and optionally cancel the onDragEnter.</description></method><method name="beforeDragOut" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action before the dragged
item is dragged out of the target without dropping, and optionally cancel the onDragOut.</description></method><method name="beforeDragOver" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action
while the dragged item is over the drop target and optionally cancel the onDragOver.</description></method><method name="beforeInvalidDrop" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action after an invalid
drop has occurred.</description></method><method name="cachePosition" scope="instance"><description>Saves the most recent position so that we can reset the constraints and
tick marks on-demand.  We need to know this so that we can calculate the
number of pixels the element is offset from its original position.</description></method><method name="clearConstraints" scope="instance"><description>Clears any constraints applied to this instance.  Also clears ticks
since they can't exist independent of a constraint at this time.</description></method><method name="clearTicks" scope="instance"><description>Clears any tick interval defined for this instance</description></method><method name="constrainTo" scope="instance"><description>Initializes the drag drop object's constraints to restrict movement to a certain element.
Usage:
 var dd = new Ext.dd.DDProxy(&quot;dragDiv1&quot;, &quot;proxytest&quot;,
                { dragElId: &quot;existingProxyDiv&quot; });
 dd.startDrag = function(){
     this.constrainTo(&quot;parent-id&quot;);
 };
Or you can initalize it using the Ext.Element object:
 Ext.get(&quot;dragDiv1&quot;).initDDProxy(&quot;proxytest&quot;, {dragElId: &quot;existingProxyDiv&quot;}, {
     startDrag : function(){
         this.constrainTo(&quot;parent-id&quot;);
     }
 });</description></method><method name="createFrame" scope="instance"><description>Creates the proxy element if it does not yet exist</description></method><method name="endDrag" scope="instance"><description>Fired when we are done dragging the object</description></method><method name="getDragData" scope="instance"><description>Called when a mousedown occurs in this container. Looks in Ext.dd.Registry
for a valid target to drag based on the mouse down. Override this method
to provide your own lookup logic (e.g. finding a child by class name). Make sure your returned
object has a &quot;ddel&quot; attribute (with an HTML Element) for other functions to work.</description></method><method name="getDragEl" scope="instance"><description>Returns a reference to the actual element to drag.  By default this is
the same as the html element, but it can be assigned to another
element. An example of this can be found in Ext.dd.DDProxy</description></method><method name="getEl" scope="instance"><description>Returns a reference to the linked element</description></method><method name="getProxy" scope="instance"><description>Returns the drag source's underlying Ext.dd.StatusProxy</description></method><method name="getRepairXY" scope="instance"><description>Called before a repair of an invalid drop to get the XY to animate to. By default returns
the XY of this.dragData.ddel</description></method><method name="hideProxy" scope="instance"><description>Hides the drag source's Ext.dd.StatusProxy</description></method><method name="init" scope="instance"><description>Sets up the DragDrop object.  Must be called in the constructor of any
Ext.dd.DragDrop subclass</description></method><method name="initFrame" scope="instance"><description>Initialization for the drag frame element.  Must be called in the
constructor of all subclasses</description></method><method name="initTarget" scope="instance"><description>Initializes Targeting functionality only... the object does not
get a mousedown handler.</description></method><method name="isLocked" scope="instance"><description>Returns true if this instance is locked, or the drag drop mgr is locked
(meaning that all drag/drop is disabled on the page.)</description></method><method name="isValidHandleChild" scope="instance"><description>Checks the tag exclusion list to see if this click should be ignored</description></method><method name="lock" scope="instance"><description>Lock this instance</description></method><method name="onAvailable" scope="instance"><description>Override the onAvailable method to do what is needed after the initial
position was determined.</description></method><method name="onBeforeDrag" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action before the initial
drag event begins and optionally cancel it.</description></method><method name="onDrag" scope="instance"><description>Abstract method called during the onMouseMove event while dragging an
object.</description></method><method name="onDragDrop" scope="instance"><description>Abstract method called when this item is dropped on another DragDrop
obj</description></method><method name="onDragEnter" scope="instance"><description>Abstract method called when this element fist begins hovering over
another DragDrop obj</description></method><method name="onDragOut" scope="instance"><description>Abstract method called when we are no longer hovering over an element</description></method><method name="onDragOver" scope="instance"><description>Abstract method called when this element is hovering over another
DragDrop obj</description></method><method name="onInitDrag" scope="instance"><description>Called once drag threshold has been reached to initialize the proxy element. By default, it clones the
this.dragData.ddel</description></method><method name="onInvalidDrop" scope="instance"><description>Abstract method called when this item is dropped on an area with no
drop target</description></method><method name="onMouseDown" scope="instance"><description>Event handler that fires when a drag/drop obj gets a mousedown</description></method><method name="onMouseUp" scope="instance"><description>Event handler that fires when a drag/drop obj gets a mouseup</description></method><method name="onStartDrag" scope="instance"><description>An empty function by default, but provided so that you can perform a custom action once the initial
drag event has begun.  The drag cannot be canceled from this function.</description></method><method name="removeFromGroup" scope="instance"><description>Remove's this instance from the supplied interaction group</description></method><method name="removeInvalidHandleClass" scope="instance"><description>Unsets an invalid css class</description></method><method name="removeInvalidHandleId" scope="instance"><description>Unsets an invalid handle id</description></method><method name="removeInvalidHandleType" scope="instance"><description>Unsets an excluded tag name set by addInvalidHandleType</description></method><method name="resetConstraints" scope="instance"><description>resetConstraints must be called if you manually reposition a dd element.</description></method><method name="setDelta" scope="instance"><description>Sets the pointer offset.  You can call this directly to force the
offset to be in a particular location (e.g., pass in 0,0 to set it
to the center of the object)</description></method><method name="setDragElId" scope="instance"><description>Allows you to specify that an element other than the linked element
will be moved with the cursor during a drag</description></method><method name="setDragElPos" scope="instance"><description>Sets the drag element to the location of the mousedown or click event,
maintaining the cursor location relative to the location on the element
that was clicked.  Override this if you want to place the element in a
location other than where the cursor is.</description></method><method name="setHandleElId" scope="instance"><description>Allows you to specify a child of the linked element that should be
used to initiate the drag operation.  An example of this would be if
you have a content div with text and links.  Clicking anywhere in the
content area would normally start the drag operation.  Use this method
to specify that an element inside of the content div is the element
that starts the drag operation.</description></method><method name="setInitPosition" scope="instance"><description>Stores the initial placement of the linked element.</description></method><method name="setOuterHandleElId" scope="instance"><description>Allows you to set an element outside of the linked element as a drag
handle</description></method><method name="setPadding" scope="instance"><description>Configures the padding for the target zone in px.  Effectively expands
(or reduces) the virtual object size for targeting calculations.
Supports css-style shorthand; if only one parameter is passed, all sides
will have that padding, and if only two are passed, the top and bottom
will have the first param, the left and right the second.</description></method><method name="setXConstraint" scope="instance"><description>By default, the element can be dragged any place on the screen.  Use
this method to limit the horizontal travel of the element.  Pass in
0,0 for the parameters if you want to lock the drag to the y axis.</description></method><method name="setYConstraint" scope="instance"><description>By default, the element can be dragged any place on the screen.  Set
this to limit the vertical travel of the element.  Pass in 0,0 for the
parameters if you want to lock the drag to the x axis.</description></method><method name="startDrag" scope="instance"><description>Abstract method called after a drag/drop object is clicked
and the drag or mousedown time thresholds have beeen met.</description></method><method name="toString" scope="instance"><description>toString method</description></method><method name="unlock" scope="instance"><description>Unlock this instace</description></method><method name="unreg" scope="instance"><description>Remove all drag and drop hooks for this element</description></method></methods></class><class superclass="Ext.chart.CartesianChart" type="Ext.chart.LineChart"><description/><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bindStore" scope="instance"><description>Changes the data store bound to this chart and refreshes it.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setSeriesStyles" scope="instance"><description>Sets the styles on all series in the Chart.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setStyle" scope="instance"><description>Sets a single style value on the Chart instance.</description></method><method name="setStyles" scope="instance"><description>Resets all styles on the Chart instance.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method></methods></class><class superclass="Object" type="Ext.chart.Axis"><description>Defines a CartesianChart's vertical or horizontal axis.</description><constructors/><properties/><methods/></class><class superclass="Ext.Panel" type="Ext.Tip"><description/><constructors/><properties/><methods><method name="add" scope="instance"><description>Adds Component(s) to this Container.
Description :

Fires the beforeadd event before adding
The Container's default config values will be applied
accordingly (see defaults for details).
Fires the add event after the component has been added.

Notes :

If the Container is already rendered when add
is called, you may need to call doLayout to refresh the view which causes
any unrendered child Components to be rendered. This is required so that you can
add multiple child components if needed while only refreshing the layout
once. For example:var tb = new Ext.Toolbar();
tb.render(document.body);  // toolbar is rendered
tb.add({text:'Button 1'}); // add multiple items (defaultType for Toolbar is 'button')
tb.add({text:'Button 2'});
tb.doLayout();             // refresh the layout
Warning: Containers directly managed by the BorderLayout layout manager
may not be removed or added.  See the Notes for BorderLayout
for more details.
</description></method><method name="addButton" scope="instance"><description>Adds a button to this panel.  Note that this method must be called prior to rendering.  The preferred
approach is to add buttons via the buttons config.</description></method><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cascade" scope="instance"><description>Cascades down the component/container heirarchy from this component (called first), calling the specified function with
each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the cascade is stopped on that branch.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="collapse" scope="instance"><description>Collapses the panel body so that it becomes hidden.  Fires the beforecollapse event which will
cancel the collapse action if it returns false.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="doLayout" scope="instance"><description>Force this container's layout to be recalculated. A call to this function is required after adding a new component
to an already rendered container, or possibly after changing sizing/position properties of child components.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="expand" scope="instance"><description>Expands the panel body so that it becomes visible.  Fires the beforeexpand event which will
cancel the expand action if it returns false.</description></method><method name="find" scope="instance"><description>Find a component under this container at any level by property</description></method><method name="findBy" scope="instance"><description>Find a component under this container at any level by a custom function. If the passed function returns
true, the component will be included in the results. The passed function is called with the arguments (component, this container).</description></method><method name="findById" scope="instance"><description>Find a component under this container at any level by id</description></method><method name="findByType" scope="instance"><description>Find a component under this container at any level by xtype or class</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="get" scope="instance"><description>Get a component contained by this container (alias for items.get(key))</description></method><method name="getBottomToolbar" scope="instance"><description>Returns the toolbar from the bottom (bbar) section of the panel.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getComponent" scope="instance"><description>Examines this container's items property
and gets a direct child component of this container.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getFooterToolbar" scope="instance"><description>Returns the toolbar from the footer (fbar) section of the panel.</description></method><method name="getFrameHeight" scope="instance"><description>Returns the height in pixels of the framing elements of this panel (including any top and bottom bars and
header and footer elements, but not including the body height).  To retrieve the body height see getInnerHeight.</description></method><method name="getFrameWidth" scope="instance"><description>Returns the width in pixels of the framing elements of this panel (not including the body width).  To
retrieve the body width see getInnerWidth.</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getInnerHeight" scope="instance"><description>Returns the height in pixels of the body element (not including the height of any framing elements).
For the frame height see getFrameHeight.</description></method><method name="getInnerWidth" scope="instance"><description>Returns the width in pixels of the body element (not including the width of any framing elements).
For the frame width see getFrameWidth.</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getLayout" scope="instance"><description>Returns the layout currently in use by the container.  If the container does not currently have a layout
set, a default Ext.layout.ContainerLayout will be created and set as the container's layout.</description></method><method name="getLayoutTarget" scope="instance"><description>Returns the Element to be used to contain the child Components of this Container.
An implementation is provided which returns the Container's Element, but
if there is a more complex structure to a Container, this may be overridden to return
the element into which the layout renders child Components.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getTool" scope="instance"><description>Retrieve a tool by id.</description></method><method name="getTopToolbar" scope="instance"><description>Returns the toolbar from the top (tbar) section of the panel.</description></method><method name="getUpdater" scope="instance"><description>Get the Ext.Updater for this panel. Enables you to perform Ajax updates of this panel's body.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="insert" scope="instance"><description>Inserts a Component into this Container at a specified index. Fires the
beforeadd event before inserting, then fires the add event after the
Component has been inserted.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="load" scope="instance"><description>Loads this content panel immediately with content returned from an XHR call.</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="remove" scope="instance"><description>Removes a component from this container.  Fires the beforeremove event before removing, then fires
the remove event after the component has been removed.</description></method><method name="removeAll" scope="instance"><description>Removes all components from this container.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setIconClass" scope="instance"><description>Sets the CSS class that provides the icon image for this panel.  This method will replace any existing
icon class if one has already been set and fire the iconchange event after completion.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setTitle" scope="instance"><description>Sets the title text for the panel and optionally the icon class.
In order to be able to set the title, a header element must have been created
for the Panel. This is triggered either by configuring the Panel with a non-blank title,
or configuring it with header: true.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="showAt" scope="instance"><description>Shows this tip at the specified XY position.  Example usage:
// Show the tip at x:50 and y:100
tip.showAt([50,100]);</description></method><method name="showBy" scope="instance"><description>Experimental. Shows this tip at a position relative to another element using a standard Ext.Element.alignTo
anchor position value.  Example usage:
// Show the tip at the default position ('tl-br?')
tip.showBy('my-el');

// Show the tip's top-left corner anchored to the element's top-right corner
tip.showBy('my-el', 'tl-tr');</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="toggleCollapse" scope="instance"><description>Shortcut for performing an expand or collapse based on the current state of the panel.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method></methods></class><class superclass="Ext.Component" type="Ext.Editor"><description>A base editor field that handles displaying/hiding on demand and has some built-in sizing and event handling logic.</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cancelEdit" scope="instance"><description>Cancels the editing process and hides the editor without persisting any changes.  The field value will be
reverted to the original starting value.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="completeEdit" scope="instance"><description>Ends the editing process, persists the changed value to the underlying field, and hides the editor.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getValue" scope="instance"><description>Gets the data value of the editor</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="realign" scope="instance"><description>Realigns the editor to the bound field based on the current alignment config value.</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setSize" scope="instance"><description>Sets the height and width of this editor.</description></method><method name="setValue" scope="instance"><description>Sets the data value of the editor</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="startEdit" scope="instance"><description>Starts the editing process and shows the editor.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method></methods></class><class superclass="Object" type="Ext.DomHelper"><description>The DomHelper class provides a layer of abstraction from DOM and transparently supports creating
elements via DOM or using HTML fragments. It also has the ability to create HTML fragment templates
from your DOM building code.
DomHelper element specification object
A specification object is used when creating elements. Attributes of this object
are assumed to be element attributes, except for 4 special attributes:

tag : The tag name of the element
children : or cnAn array of the
same kind of element definition objects to be created and appended. These can be nested
as deep as you want.
cls : The class attribute of the element.
This will end up being either the &quot;class&quot; attribute on a HTML fragment or className
for a DOM node, depending on whether DomHelper is using fragments or DOM.
html : The innerHTML for the element

Insertion methods
Commonly used insertion methods:

append : 
insertBefore : 
insertAfter : 
overwrite : 
createTemplate : 
insertHtml : 

Example
This is an example, where an unordered list with 3 children items is appended to an existing
element with id 'my-div':
 var dh = Ext.DomHelper; // create shorthand alias
// specification object
var spec = {
    id: 'my-ul',
    tag: 'ul',
    cls: 'my-list',
    // append children after creating
    children: [     // may also specify 'cn' instead of 'children'
        {tag: 'li', id: 'item0', html: 'List Item 0'},
        {tag: 'li', id: 'item1', html: 'List Item 1'},
        {tag: 'li', id: 'item2', html: 'List Item 2'}
    ]
};
var list = dh.append(
    'my-div', // the context element 'my-div' can either be the id or the actual node
    spec      // the specification object
);
Element creation specification parameters in this class may also be passed as an Array of
specification objects. This can be used to insert multiple sibling nodes into an existing
container very efficiently. For example, to add more list items to the example above:dh.append('my-ul', [
    {tag: 'li', id: 'item3', html: 'List Item 3'},
    {tag: 'li', id: 'item4', html: 'List Item 4'}
]);
Templating
The real power is in the built-in templating. Instead of creating or appending any elements,
createTemplate returns a Template object which can be used over and over to
insert new elements. Revisiting the example above, we could utilize templating this time:
// create the node
var list = dh.append('my-div', {tag: 'ul', cls: 'my-list'});
// get template
var tpl = dh.createTemplate({tag: 'li', id: 'item{0}', html: 'List Item {0}'});

for(var i = 0; i &lt; 5, i++){
    tpl.append(list, [i]); // use template to append to the actual node
}
An example using a template:var html = '&quot;{0}&quot; href=&quot;{1}&quot; class=&quot;nav&quot;&gt;{2}';

var tpl = new Ext.DomHelper.createTemplate(html);
tpl.append('blog-roll', ['link1', 'http://www.jackslocum.com/', &quot;Jack&#39;s Site&quot;]);
tpl.append('blog-roll', ['link2', 'http://www.dustindiaz.com/', &quot;Dustin&#39;s Site&quot;]);
The same example using named parameters:var html = '&quot;{id}&quot; href=&quot;{url}&quot; class=&quot;nav&quot;&gt;{text}';

var tpl = new Ext.DomHelper.createTemplate(html);
tpl.append('blog-roll', {
    id: 'link1',
    url: 'http://www.jackslocum.com/',
    text: &quot;Jack&#39;s Site&quot;
});
tpl.append('blog-roll', {
    id: 'link2',
    url: 'http://www.dustindiaz.com/',
    text: &quot;Dustin&#39;s Site&quot;
});
Compiling Templates
Templates are applied using regular expressions. The performance is great, but if
you are adding a bunch of DOM elements using the same template, you can increase
performance even further by &quot;compiling&quot; the template.
The way &quot;compile()&quot; works is the template is parsed and
broken up at the different variable points and a dynamic function is created and eval'ed.
The generated function performs string concatenation of these parts and the passed
variables instead of using regular expressions.
var html = '&quot;{id}&quot; href=&quot;{url}&quot; class=&quot;nav&quot;&gt;{text}';

var tpl = new Ext.DomHelper.createTemplate(html);
tpl.compile();

//... use template like normal
Performance Boost
DomHelper will transparently create HTML fragments when it can. Using HTML fragments instead
of DOM can significantly boost performance.
Element creation specification parameters may also be strings. If useDom is false,
then the string is used as innerHTML. If useDom is true, a string specification
results in the creation of a text node. Usage:
Ext.DomHelper.useDom = true; // force it to use DOM; reduces performance</description><constructors/><properties/><methods><method name="append" scope="instance"><description>Creates new DOM element(s) and appends them to el.</description></method><method name="applyStyles" scope="instance"><description>Applies a style specification to an element.</description></method><method name="createDom" scope="instance"><description>Creates new DOM element(s) without inserting them to the document.</description></method><method name="createTemplate" scope="instance"><description>Creates a new Ext.Template from the DOM object spec.</description></method><method name="insertAfter" scope="instance"><description>Creates new DOM element(s) and inserts them after el.</description></method><method name="insertBefore" scope="instance"><description>Creates new DOM element(s) and inserts them before el.</description></method><method name="insertFirst" scope="instance"><description>Creates new DOM element(s) and inserts them as the first child of el.</description></method><method name="insertHtml" scope="instance"><description>Inserts an HTML fragment into the DOM.</description></method><method name="markup" scope="instance"><description>Returns the markup for the passed Element(s) config.</description></method><method name="overwrite" scope="instance"><description>Creates new DOM element(s) and overwrites the contents of el with them.</description></method></methods></class><class superclass="Ext.layout.boxOverflow.None" type="Ext.layout.boxOverflow.Menu"><description>Description</description><constructors/><properties/><methods/></class><class superclass="Ext.util.Observable" type="Ext.Direct"><description>Overview
Ext.Direct aims to streamline communication between the client and server
by providing a single interface that reduces the amount of common code
typically required to validate data and handle returned data packets
(reading data, error conditions, etc).
The Ext.direct namespace includes several classes for a closer integration
with the server-side. The Ext.data namespace also includes classes for working
with Ext.data.Stores which are backed by data from an Ext.Direct method.
Specification
For additional information consult the
Ext.Direct Specification.
Providers
Ext.Direct uses a provider architecture, where one or more providers are
used to transport data to and from the server. There are several providers
that exist in the core at the moment:
JsonProvider for simple JSON operations
PollingProvider for repeated requests
RemotingProvider exposes server side
on the client.

A provider does not need to be invoked directly, providers are added via
Ext.Direct.add.
Router
Ext.Direct utilizes a &quot;router&quot; on the server to direct requests from the client
to the appropriate server-side method. Because the Ext.Direct API is completely
platform-agnostic, you could completely swap out a Java based server solution
and replace it with one that uses C# without changing the client side JavaScript
at all.
Server side events
Custom events from the server may be handled by the client by adding
listeners, for example:
{&quot;type&quot;:&quot;event&quot;,&quot;name&quot;:&quot;message&quot;,&quot;data&quot;:&quot;Successfully polled at: 11:19:30 am&quot;}

// add a handler for a 'message' event sent by the server
Ext.Direct.on('message', function(e){
    out.append(String.format('&lt;p&gt;&lt;i&gt;{0}&lt;/i&gt;&lt;/p&gt;', e.data));
            out.el.scrollTo('t', 100000, true);
});</description><constructors/><properties/><methods><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="addProvider" scope="instance"><description>Adds an Ext.Direct Provider and creates the proxy or stub methods to execute server-side methods.
If the provider is not already connected, it will auto-connect.
var pollProv = new Ext.direct.PollingProvider({
    url: 'php/poll2.php'
});

Ext.Direct.addProvider(
    {
        &quot;type&quot;:&quot;remoting&quot;,       // create a Ext.direct.RemotingProvider
        &quot;url&quot;:&quot;php\/router.php&quot;, // url to connect to the Ext.Direct server-side router.
        &quot;actions&quot;:{              // each property within the actions object represents a Class
            &quot;TestAction&quot;:[       // array of methods within each server side Class
            {
                &quot;name&quot;:&quot;doEcho&quot;, // name of method
                &quot;len&quot;:1
            },{
                &quot;name&quot;:&quot;multiply&quot;,
                &quot;len&quot;:1
            },{
                &quot;name&quot;:&quot;doForm&quot;,
                &quot;formHandler&quot;:true, // handle form on server with Ext.Direct.Transaction
                &quot;len&quot;:1
            }]
        },
        &quot;namespace&quot;:&quot;myApplication&quot;,// namespace to create the Remoting Provider in
    },{
        type: 'polling', // create a Ext.direct.PollingProvider
        url:  'php/poll.php'
    },
    pollProv // reference to previously created instance
);</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="getProvider" scope="instance"><description>Retrieve a provider by the
id specified when the provider is
added.</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method></methods></class><class superclass="Ext.layout.boxOverflow.None" type="Ext.layout.boxOverflow.Scroller"><description>Description</description><constructors/><properties/><methods><method name="scrollToItem" scope="instance"><description>Scrolls to the given component.</description></method></methods></class><class superclass="Ext.layout.BoxLayout" type="Ext.layout.HBoxLayout"><description>A layout that arranges items horizontally across a Container. This layout optionally divides available horizontal
space between child items containing a numeric flex configuration.
This layout may also be used to set the heights of child items by configuring it with the align option.</description><constructors/><properties/><methods><method name="parseMargins" scope="instance"><description>Parses a number or string representing margin sizes into an object. Supports CSS-style margin declarations
(e.g. 10, &quot;10&quot;, &quot;10 10&quot;, &quot;10 10 10&quot; and &quot;10 10 10 10&quot; are all valid options and would return the same result)</description></method><method name="updateChildBoxes" scope="instance"><description>Resizes and repositions each child component</description></method></methods></class><class superclass="Ext.BoxComponent" type="Ext.Container"><description>Base class for any Ext.BoxComponent that may contain other Components. Containers handle the
basic behavior of containing items, namely adding, inserting and removing items.
The most commonly used Container classes are Ext.Panel, Ext.Window and Ext.TabPanel.
If you do not need the capabilities offered by the aforementioned classes you can create a lightweight
Container to be encapsulated by an HTML element to your specifications by using the
autoEl config option. This is a useful technique when creating
embedded column layouts inside FormPanels
for example.
The code below illustrates both how to explicitly create a Container, and how to implicitly
create one using the 'container' xtype:// explicitly create a Container
var embeddedColumns = new Ext.Container({
    autoEl: 'div',  // This is the default
    layout: 'column',
    defaults: {
        // implicitly create Container by specifying xtype
        xtype: 'container',
        autoEl: 'div', // This is the default.
        layout: 'form',
        columnWidth: 0.5,
        style: {
            padding: '10px'
        }
    },
//  The two items below will be Ext.Containers, each encapsulated by a &lt;DIV&gt; element.
    items: [{
        items: {
            xtype: 'datefield',
            name: 'startDate',
            fieldLabel: 'Start date'
        }
    }, {
        items: {
            xtype: 'datefield',
            name: 'endDate',
            fieldLabel: 'End date'
        }
    }]
});
Layout
Container classes delegate the rendering of child Components to a layout
manager class which must be configured into the Container using the
layout configuration property.
When either specifying child items of a Container,
or dynamically adding Components to a Container, remember to
consider how you wish the Container to arrange those child elements, and
whether those child elements need to be sized using one of Ext's built-in
layout schemes. By default, Containers use the
ContainerLayout scheme which only
renders child components, appending them one after the other inside the
Container, and does not apply any sizing at all.
A common mistake is when a developer neglects to specify a
layout (e.g. widgets like GridPanels or
TreePanels are added to Containers for which no layout
has been specified). If a Container is left to use the default
ContainerLayout scheme, none of its
child components will be resized, or changed in any way when the Container
is resized.
Certain layout managers allow dynamic addition of child components.
Those that do include Ext.layout.CardLayout,
Ext.layout.AnchorLayout, Ext.layout.FormLayout, and
Ext.layout.TableLayout. For example://  Create the GridPanel.
var myNewGrid = new Ext.grid.GridPanel({
    store: myStore,
    columns: myColumnModel,
    title: 'Results', // the title becomes the title of the tab
});

myTabPanel.add(myNewGrid); // Ext.TabPanel implicitly uses CardLayout
myTabPanel.setActiveTab(myNewGrid);
The example above adds a newly created GridPanel to a TabPanel. Note that
a TabPanel uses Ext.layout.CardLayout as its layout manager which
means all its child items are sized to fit
exactly into its client area.
Overnesting is a common problem.
An example of overnesting occurs when a GridPanel is added to a TabPanel
by wrapping the GridPanel inside a wrapping Panel (that has no
layout specified) and then add that wrapping Panel
to the TabPanel. The point to realize is that a GridPanel is a
Component which can be added directly to a Container. If the wrapping Panel
has no layout configuration, then the overnested
GridPanel will not be sized as expected.
Adding via remote configuration
A server side script can be used to add Components which are generated dynamically on the server.
An example of adding a GridPanel to a TabPanel where the GridPanel is generated by the server
based on certain parameters:
// execute an Ajax request to invoke server side script:
Ext.Ajax.request({
    url: 'gen-invoice-grid.php',
    // send additional parameters to instruct server script
    params: {
        startDate: Ext.getCmp('start-date').getValue(),
        endDate: Ext.getCmp('end-date').getValue()
    },
    // process the response object to add it to the TabPanel:
    success: function(xhr) {
        var newComponent = eval(xhr.responseText); // see discussion below
        myTabPanel.add(newComponent); // add the component to the TabPanel
        myTabPanel.setActiveTab(newComponent);
    },
    failure: function() {
        Ext.Msg.alert(&quot;Grid create failed&quot;, &quot;Server communication failure&quot;);
    }
});
The server script needs to return an executable Javascript statement which, when processed
using eval(), will return either a config object with an xtype,
or an instantiated Component. The server might return this for example:(function() {
    function formatDate(value){
        return value ? value.dateFormat('M d, Y') : '';
    };

    var store = new Ext.data.Store({
        url: 'get-invoice-data.php',
        baseParams: {
            startDate: '01/01/2008',
            endDate: '01/31/2008'
        },
        reader: new Ext.data.JsonReader({
            record: 'transaction',
            idProperty: 'id',
            totalRecords: 'total'
        }, [
           'customer',
           'invNo',
           {name: 'date', type: 'date', dateFormat: 'm/d/Y'},
           {name: 'value', type: 'float'}
        ])
    });

    var grid = new Ext.grid.GridPanel({
        title: 'Invoice Report',
        bbar: new Ext.PagingToolbar(store),
        store: store,
        columns: [
            {header: &quot;Customer&quot;, width: 250, dataIndex: 'customer', sortable: true},
            {header: &quot;Invoice Number&quot;, width: 120, dataIndex: 'invNo', sortable: true},
            {header: &quot;Invoice Date&quot;, width: 100, dataIndex: 'date', renderer: formatDate, sortable: true},
            {header: &quot;Value&quot;, width: 120, dataIndex: 'value', renderer: 'usMoney', sortable: true}
        ],
    });
    store.load();
    return grid;  // return instantiated component
})();
When the above code fragment is passed through the eval function in the success handler
of the Ajax request, the code is executed by the Javascript processor, and the anonymous function
runs, and returns the instantiated grid component.
Note: since the code above is generated by a server script, the baseParams for
the Store, the metadata to allow generation of the Record layout, and the ColumnModel
can all be generated into the code since these are all known on the server.</description><constructors/><properties/><methods><method name="add" scope="instance"><description>Adds Component(s) to this Container.
Description :

Fires the beforeadd event before adding
The Container's default config values will be applied
accordingly (see defaults for details).
Fires the add event after the component has been added.

Notes :

If the Container is already rendered when add
is called, you may need to call doLayout to refresh the view which causes
any unrendered child Components to be rendered. This is required so that you can
add multiple child components if needed while only refreshing the layout
once. For example:var tb = new Ext.Toolbar();
tb.render(document.body);  // toolbar is rendered
tb.add({text:'Button 1'}); // add multiple items (defaultType for Toolbar is 'button')
tb.add({text:'Button 2'});
tb.doLayout();             // refresh the layout
Warning: Containers directly managed by the BorderLayout layout manager
may not be removed or added.  See the Notes for BorderLayout
for more details.
</description></method><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cascade" scope="instance"><description>Cascades down the component/container heirarchy from this component (called first), calling the specified function with
each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the cascade is stopped on that branch.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="doLayout" scope="instance"><description>Force this container's layout to be recalculated. A call to this function is required after adding a new component
to an already rendered container, or possibly after changing sizing/position properties of child components.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="find" scope="instance"><description>Find a component under this container at any level by property</description></method><method name="findBy" scope="instance"><description>Find a component under this container at any level by a custom function. If the passed function returns
true, the component will be included in the results. The passed function is called with the arguments (component, this container).</description></method><method name="findById" scope="instance"><description>Find a component under this container at any level by id</description></method><method name="findByType" scope="instance"><description>Find a component under this container at any level by xtype or class</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="get" scope="instance"><description>Get a component contained by this container (alias for items.get(key))</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getComponent" scope="instance"><description>Examines this container's items property
and gets a direct child component of this container.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getLayout" scope="instance"><description>Returns the layout currently in use by the container.  If the container does not currently have a layout
set, a default Ext.layout.ContainerLayout will be created and set as the container's layout.</description></method><method name="getLayoutTarget" scope="instance"><description>Returns the Element to be used to contain the child Components of this Container.
An implementation is provided which returns the Container's Element, but
if there is a more complex structure to a Container, this may be overridden to return
the element into which the layout renders child Components.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="insert" scope="instance"><description>Inserts a Component into this Container at a specified index. Fires the
beforeadd event before inserting, then fires the add event after the
Component has been inserted.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="remove" scope="instance"><description>Removes a component from this container.  Fires the beforeremove event before removing, then fires
the remove event after the component has been removed.</description></method><method name="removeAll" scope="instance"><description>Removes all components from this container.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method></methods></class><class superclass="Ext.grid.AbstractSelectionModel" type="Ext.grid.CellSelectionModel"><description>This class provides the basic implementation for single cell selection in a grid.
The object stored as the selection contains the following properties:

cell : see getSelectedCell 
record : Ext.data.record The Record
which provides the data for the row containing the selection
</description><constructors/><properties/><methods><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="clearSelections" scope="instance"><description>If anything is selected, clears all selections and fires the selectionchange event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="getSelectedCell" scope="instance"><description>Returns an array containing the row and column indexes of the currently selected cell
(e.g., [0, 0]), or null if none selected. The array has elements:

rowIndex : NumberThe index of the selected row
cellIndex : NumberThe index of the selected cell. 
Due to possible column reordering, the cellIndex should not be used as an
index into the Record's data. Instead, use the cellIndex to determine the name
of the selected cell and use the field name to retrieve the data value from the record:// get name
var fieldName = grid.getColumnModel().getDataIndex(cellIndex);
// get data value based on name
var data = record.get(fieldName);
</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hasSelection" scope="instance"><description>Returns true if there is a selection.</description></method><method name="isLocked" scope="instance"><description>Returns true if the selections are locked.</description></method><method name="lock" scope="instance"><description>Locks the selections.</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="select" scope="instance"><description>Selects a cell.  Before selecting a cell, fires the
beforecellselect event.  If this check is satisfied the cell
will be selected and followed up by  firing the cellselect and
selectionchange events.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="unlock" scope="instance"><description>Unlocks the selections.</description></method></methods></class><class superclass="Ext.data.Connection" type="Ext.Ajax"><description>The global Ajax request class that provides a simple way to make Ajax requests
with maximum flexibility.
Since Ext.Ajax is a singleton, you can set common properties/events for it once
and override them at the request function level only if necessary.
Common Properties you may want to set are:
method
extraParams
url

// Default headers to pass in every request
Ext.Ajax.defaultHeaders = {
    'Powered-By': 'Ext'
};

Common Events you may want to set are:
beforerequest
requestcomplete
requestexception

// Example: show a spinner during all Ajax requests
Ext.Ajax.on('beforerequest', this.showSpinner, this);
Ext.Ajax.on('requestcomplete', this.hideSpinner, this);
Ext.Ajax.on('requestexception', this.hideSpinner, this);

An example request:
// Basic request
Ext.Ajax.request({
   url: 'foo.php',
   success: someFn,
   failure: otherFn,
   headers: {
       'my-header': 'foo'
   },
   params: { foo: 'bar' }
});

// Simple ajax form submission
Ext.Ajax.request({
    form: 'some-form',
    params: 'foo=bar'
});
</description><constructors/><properties/><methods><method name="abort" scope="instance"><description>Aborts any outstanding request.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="isLoading" scope="instance"><description>Determine whether this object has a request outstanding.</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="request" scope="instance"><description>Sends an HTTP request to a remote server.
Important: Ajax server requests are asynchronous, and this call will
return before the response has been received. Process any returned data
in a callback function.
Ext.Ajax.request({
   url: 'ajax_demo/sample.json',
   success: function(response, opts) {
      var obj = Ext.decode(response.responseText);
      console.dir(obj);
   },
   failure: function(response, opts) {
      console.log('server-side failure with status code ' + response.status);
   }
});
To execute a callback function in the correct scope, use the scope option.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="serializeForm" scope="instance"><description>Serialize the passed form into a url encoded string</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method></methods></class><class superclass="Ext.chart.CartesianSeries" type="Ext.chart.ColumnSeries"><description>ColumnSeries class for the charts widget.</description><constructors/><properties/><methods/></class><class superclass="Ext.grid.AbstractSelectionModel" type="Ext.grid.RowSelectionModel"><description>The default SelectionModel used by Ext.grid.GridPanel.
It supports multiple selections and keyboard selection/navigation. The objects stored
as selections and returned by getSelected, and getSelections are
the Records which provide the data for the selected rows.</description><constructors/><properties/><methods><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="clearSelections" scope="instance"><description>Clears all selections if the selection model
is not locked.</description></method><method name="deselectRange" scope="instance"><description>Deselects a range of rows if the selection model
is not locked.  
All rows in between startRow and endRow are also deselected.</description></method><method name="deselectRow" scope="instance"><description>Deselects a row.  Before deselecting a row, checks if the selection model
is locked.
If this check is satisfied the row will be deselected and followed up by
firing the rowdeselect and selectionchange events.</description></method><method name="each" scope="instance"><description>Calls the passed function with each selection. If the function returns
false, iteration is stopped and this function returns
false. Otherwise it returns true.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="getCount" scope="instance"><description>Gets the number of selected rows.</description></method><method name="getSelected" scope="instance"><description>Returns the first selected record.</description></method><method name="getSelections" scope="instance"><description>Returns the selected records</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hasNext" scope="instance"><description>Returns true if there is a next record to select</description></method><method name="hasPrevious" scope="instance"><description>Returns true if there is a previous record to select</description></method><method name="hasSelection" scope="instance"><description>Returns true if there is a selection.</description></method><method name="isIdSelected" scope="instance"><description>Returns true if the specified record id is selected.</description></method><method name="isLocked" scope="instance"><description>Returns true if the selections are locked.</description></method><method name="isSelected" scope="instance"><description>Returns true if the specified row is selected.</description></method><method name="lock" scope="instance"><description>Locks the selections.</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="selectAll" scope="instance"><description>Selects all rows if the selection model
is not locked.</description></method><method name="selectFirstRow" scope="instance"><description>Selects the first row in the grid.</description></method><method name="selectLastRow" scope="instance"><description>Select the last row.</description></method><method name="selectNext" scope="instance"><description>Selects the row immediately following the last selected row.</description></method><method name="selectPrevious" scope="instance"><description>Selects the row that precedes the last selected row.</description></method><method name="selectRange" scope="instance"><description>Selects a range of rows if the selection model
is not locked.
All rows in between startRow and endRow are also selected.</description></method><method name="selectRecords" scope="instance"><description>Select records.</description></method><method name="selectRow" scope="instance"><description>Selects a row.  Before selecting a row, checks if the selection model
is locked and fires the
beforerowselect event.  If these checks are satisfied the row
will be selected and followed up by  firing the rowselect and
selectionchange events.</description></method><method name="selectRows" scope="instance"><description>Selects multiple rows.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="unlock" scope="instance"><description>Unlocks the selections.</description></method></methods></class><class superclass="Object" type="Ext.dd.DragDrop"><description>Defines the interface and base operation of items that that can be
dragged or can be drop targets.  It was designed to be extended, overriding
the event handlers for startDrag, onDrag, onDragOver and onDragOut.
Up to three html elements can be associated with a DragDrop instance:

linked element: the element that is passed into the constructor.
This is the element which defines the boundaries for interaction with
other DragDrop objects.
handle element(s): The drag operation only occurs if the element that
was clicked matches a handle element.  By default this is the linked
element, but there are times that you will want only a portion of the
linked element to initiate the drag operation, and the setHandleElId()
method provides a way to define this.
drag element: this represents the element that would be moved along
with the cursor during a drag operation.  By default, this is the linked
element itself as in Ext.dd.DD.  setDragElId() lets you define
a separate element that would be moved, as in Ext.dd.DDProxy.


This class should not be instantiated until the onload event to ensure that
the associated elements are available.
The following would define a DragDrop obj that would interact with any
other DragDrop obj in the &quot;group1&quot; group:

dd = new Ext.dd.DragDrop(&quot;div1&quot;, &quot;group1&quot;);

Since none of the event handlers have been implemented, nothing would
actually happen if you were to run the code above.  Normally you would
override this class or one of the default implementations, but you can
also override the methods you want on an instance of the class...

dd.onDragDrop = function(e, id) {
   alert(&quot;dd was dropped on &quot; + id);
}
</description><constructors/><properties/><methods><method name="addInvalidHandleClass" scope="instance"><description>Lets you specify a css class of elements that will not initiate a drag</description></method><method name="addInvalidHandleId" scope="instance"><description>Lets you to specify an element id for a child of a drag handle
that should not initiate a drag</description></method><method name="addInvalidHandleType" scope="instance"><description>Allows you to specify a tag name that should not start a drag operation
when clicked.  This is designed to facilitate embedding links within a
drag handle that do something other than start the drag.</description></method><method name="addToGroup" scope="instance"><description>Add this instance to a group of related drag/drop objects.  All
instances belong to at least one group, and can belong to as many
groups as needed.</description></method><method name="applyConfig" scope="instance"><description>Applies the configuration parameters that were passed into the constructor.
This is supposed to happen at each level through the inheritance chain.  So
a DDProxy implentation will execute apply config on DDProxy, DD, and
DragDrop in order to get all of the parameters that are available in
each object.</description></method><method name="clearConstraints" scope="instance"><description>Clears any constraints applied to this instance.  Also clears ticks
since they can't exist independent of a constraint at this time.</description></method><method name="clearTicks" scope="instance"><description>Clears any tick interval defined for this instance</description></method><method name="constrainTo" scope="instance"><description>Initializes the drag drop object's constraints to restrict movement to a certain element.
Usage:
 var dd = new Ext.dd.DDProxy(&quot;dragDiv1&quot;, &quot;proxytest&quot;,
                { dragElId: &quot;existingProxyDiv&quot; });
 dd.startDrag = function(){
     this.constrainTo(&quot;parent-id&quot;);
 };
Or you can initalize it using the Ext.Element object:
 Ext.get(&quot;dragDiv1&quot;).initDDProxy(&quot;proxytest&quot;, {dragElId: &quot;existingProxyDiv&quot;}, {
     startDrag : function(){
         this.constrainTo(&quot;parent-id&quot;);
     }
 });</description></method><method name="endDrag" scope="instance"><description>Fired when we are done dragging the object</description></method><method name="getDragEl" scope="instance"><description>Returns a reference to the actual element to drag.  By default this is
the same as the html element, but it can be assigned to another
element. An example of this can be found in Ext.dd.DDProxy</description></method><method name="getEl" scope="instance"><description>Returns a reference to the linked element</description></method><method name="init" scope="instance"><description>Sets up the DragDrop object.  Must be called in the constructor of any
Ext.dd.DragDrop subclass</description></method><method name="initTarget" scope="instance"><description>Initializes Targeting functionality only... the object does not
get a mousedown handler.</description></method><method name="isLocked" scope="instance"><description>Returns true if this instance is locked, or the drag drop mgr is locked
(meaning that all drag/drop is disabled on the page.)</description></method><method name="isValidHandleChild" scope="instance"><description>Checks the tag exclusion list to see if this click should be ignored</description></method><method name="lock" scope="instance"><description>Lock this instance</description></method><method name="onAvailable" scope="instance"><description>Override the onAvailable method to do what is needed after the initial
position was determined.</description></method><method name="onDrag" scope="instance"><description>Abstract method called during the onMouseMove event while dragging an
object.</description></method><method name="onDragDrop" scope="instance"><description>Abstract method called when this item is dropped on another DragDrop
obj</description></method><method name="onDragEnter" scope="instance"><description>Abstract method called when this element fist begins hovering over
another DragDrop obj</description></method><method name="onDragOut" scope="instance"><description>Abstract method called when we are no longer hovering over an element</description></method><method name="onDragOver" scope="instance"><description>Abstract method called when this element is hovering over another
DragDrop obj</description></method><method name="onInvalidDrop" scope="instance"><description>Abstract method called when this item is dropped on an area with no
drop target</description></method><method name="onMouseDown" scope="instance"><description>Event handler that fires when a drag/drop obj gets a mousedown</description></method><method name="onMouseUp" scope="instance"><description>Event handler that fires when a drag/drop obj gets a mouseup</description></method><method name="removeFromGroup" scope="instance"><description>Remove's this instance from the supplied interaction group</description></method><method name="removeInvalidHandleClass" scope="instance"><description>Unsets an invalid css class</description></method><method name="removeInvalidHandleId" scope="instance"><description>Unsets an invalid handle id</description></method><method name="removeInvalidHandleType" scope="instance"><description>Unsets an excluded tag name set by addInvalidHandleType</description></method><method name="resetConstraints" scope="instance"><description>resetConstraints must be called if you manually reposition a dd element.</description></method><method name="setDragElId" scope="instance"><description>Allows you to specify that an element other than the linked element
will be moved with the cursor during a drag</description></method><method name="setHandleElId" scope="instance"><description>Allows you to specify a child of the linked element that should be
used to initiate the drag operation.  An example of this would be if
you have a content div with text and links.  Clicking anywhere in the
content area would normally start the drag operation.  Use this method
to specify that an element inside of the content div is the element
that starts the drag operation.</description></method><method name="setInitPosition" scope="instance"><description>Stores the initial placement of the linked element.</description></method><method name="setOuterHandleElId" scope="instance"><description>Allows you to set an element outside of the linked element as a drag
handle</description></method><method name="setPadding" scope="instance"><description>Configures the padding for the target zone in px.  Effectively expands
(or reduces) the virtual object size for targeting calculations.
Supports css-style shorthand; if only one parameter is passed, all sides
will have that padding, and if only two are passed, the top and bottom
will have the first param, the left and right the second.</description></method><method name="setXConstraint" scope="instance"><description>By default, the element can be dragged any place on the screen.  Use
this method to limit the horizontal travel of the element.  Pass in
0,0 for the parameters if you want to lock the drag to the y axis.</description></method><method name="setYConstraint" scope="instance"><description>By default, the element can be dragged any place on the screen.  Set
this to limit the vertical travel of the element.  Pass in 0,0 for the
parameters if you want to lock the drag to the x axis.</description></method><method name="startDrag" scope="instance"><description>Abstract method called after a drag/drop object is clicked
and the drag or mousedown time thresholds have beeen met.</description></method><method name="toString" scope="instance"><description>toString method</description></method><method name="unlock" scope="instance"><description>Unlock this instace</description></method><method name="unreg" scope="instance"><description>Remove all drag and drop hooks for this element</description></method></methods></class><class superclass="Ext.Component" type="Ext.grid.PivotAxis"><description>PivotAxis is a class that supports a Ext.grid.PivotGrid. Each PivotGrid contains two PivotAxis instances - the left
axis and the top axis. Each PivotAxis defines an ordered set of dimensions, each of which should correspond to a field in a
Store's Record (see Ext.grid.PivotGrid documentation for further explanation).
Developers should have little interaction with the PivotAxis instances directly as most of their management is performed by
the PivotGrid. An exception is the dynamic reconfiguration of axes at run time - to achieve this we use PivotAxis's 
setDimensions function and refresh the grid:
var pivotGrid = new Ext.grid.PivotGrid({
    //some PivotGrid config here
});

//change the left axis dimensions
pivotGrid.leftAxis.setDimensions([
    {
        dataIndex: 'person',
        direction: 'DESC',
        width    : 100
    },
    {
        dataIndex: 'product',
        direction: 'ASC',
        width    : 80
    }
]);

pivotGrid.view.refresh(true);
This clears the previous dimensions on the axis and redraws the grid with the new dimensions.</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setDimensions" scope="instance"><description>Updates the dimensions used by this axis</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method></methods></class><class superclass="Ext.direct.JsonProvider" type="Ext.direct.RemotingProvider"><description>The RemotingProvider exposes access to
server side methods on the client (a remote procedure call (RPC) type of
connection where the client can initiate a procedure on the server).
This allows for code to be organized in a fashion that is maintainable,
while providing a clear path between client and server, something that is
not always apparent when using URLs.
To accomplish this the server-side needs to describe what classes and methods
are available on the client-side. This configuration will typically be
outputted by the server-side Ext.Direct stack when the API description is built.</description><constructors/><properties/><methods><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="isConnected" scope="instance"><description>Returns whether or not the server-side is currently connected.
Abstract method for subclasses to implement.</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method></methods></class><class superclass="Ext.slider.MultiSlider" type="Ext.slider.SingleSlider"><description>Slider which supports vertical or horizontal orientation, keyboard adjustments,
configurable snapping, axis clicking and animation. Can be added as an item to
any container. Example usage:
new Ext.slider.SingleSlider({
    renderTo: Ext.getBody(),
    width: 200,
    value: 50,
    increment: 10,
    minValue: 0,
    maxValue: 100
});
The class Ext.slider.SingleSlider is aliased to Ext.Slider for backwards compatibility.</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="addThumb" scope="instance"><description>Creates a new thumb and adds it to the slider</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getValue" scope="instance"><description>Returns the current value of the slider</description></method><method name="getValues" scope="instance"><description>Returns an array of values - one for the location of each thumb</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setMaxValue" scope="instance"><description>Sets the maximum value for the slider instance. If the current value is more than the
maximum value, the current value will be changed.</description></method><method name="setMinValue" scope="instance"><description>Sets the minimum value for the slider instance. If the current value is less than the
minimum value, the current value will be changed.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setValue" scope="instance"><description>Programmatically sets the value of the Slider. Ensures that the value is constrained within
the minValue and maxValue.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="syncThumb" scope="instance"><description>Synchronizes the thumb position to the proper proportion of the total component width based
on the current slider value.  This will be called automatically when the Slider
is resized by a layout, but if it is rendered auto width, this method can be called from
another resize handler to sync the Slider if necessary.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method></methods></class><class superclass="Ext.util.Observable" type="Ext.data.Node"><description/><constructors/><properties/><methods><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="appendChild" scope="instance"><description>Insert node(s) as the last child node of this node.</description></method><method name="bubble" scope="instance"><description>Bubbles up the tree from this node, calling the specified function with each node. The arguments to the function
will be the args provided or the current node. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cascade" scope="instance"><description>Cascades down the tree from this node, calling the specified function with each node. The arguments to the function
will be the args provided or the current node. If the function returns false at any point,
the cascade is stopped on that branch.</description></method><method name="contains" scope="instance"><description>Returns true if this node is an ancestor (at any point) of the passed node.</description></method><method name="destroy" scope="instance"><description>Destroys the node.</description></method><method name="eachChild" scope="instance"><description>Interates the child nodes of this node, calling the specified function with each node. The arguments to the function
will be the args provided or the current node. If the function returns false at any point,
the iteration stops.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findChild" scope="instance"><description>Finds the first child that has the attribute with the specified value.</description></method><method name="findChildBy" scope="instance"><description>Finds the first child by a custom function. The child matches if the function passed returns true.</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="getDepth" scope="instance"><description>Returns depth of this node (the root node has a depth of 0)</description></method><method name="getOwnerTree" scope="instance"><description>Returns the tree this node is in.</description></method><method name="getPath" scope="instance"><description>Returns the path for this node. The path can be used to expand or select this node programmatically.</description></method><method name="hasChildNodes" scope="instance"><description>Returns true if this node has one or more child nodes, else false.</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="indexOf" scope="instance"><description>Returns the index of a child node</description></method><method name="insertBefore" scope="instance"><description>Inserts the first node before the second node in this nodes childNodes collection.</description></method><method name="isAncestor" scope="instance"><description>Returns true if the passed node is an ancestor (at any point) of this node.</description></method><method name="isExpandable" scope="instance"><description>Returns true if this node has one or more child nodes, or if the expandable
node attribute is explicitly specified as true (see attributes), otherwise returns false.</description></method><method name="isFirst" scope="instance"><description>Returns true if this node is the first child of its parent</description></method><method name="isLast" scope="instance"><description>Returns true if this node is the last child of its parent</description></method><method name="isLeaf" scope="instance"><description>Returns true if this node is a leaf</description></method><method name="item" scope="instance"><description>Returns the child node at the specified index.</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="remove" scope="instance"><description>Removes this node from its parent</description></method><method name="removeAll" scope="instance"><description>Removes all child nodes from this node.</description></method><method name="removeChild" scope="instance"><description>Removes a child node from this node.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="replaceChild" scope="instance"><description>Replaces one child node in this node with another.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setId" scope="instance"><description>Changes the id of this node.</description></method><method name="sort" scope="instance"><description>Sorts this nodes children using the supplied sort function.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method></methods></class><class superclass="Object" type="Ext.dd.DragDropMgr"><description>DragDropMgr is a singleton that tracks the element interaction for
all DragDrop items in the window.  Generally, you will not call
this class directly, but it does have helper methods that could
be useful in your DragDrop implementations.</description><constructors/><properties/><methods><method name="getBestMatch" scope="instance"><description>Helper function for getting the best match from the list of drag
and drop objects returned by the drag and drop events when we are
in INTERSECT mode.  It returns either the first object that the
cursor is over, or the object that has the greatest overlap with
the dragged element.</description></method><method name="getCss" scope="instance"><description>Returns the style property for the DOM element (i.e.,
document.getElById(id).style)</description></method><method name="getDDById" scope="instance"><description>Returns the DragDrop instance for a given id</description></method><method name="getElement" scope="instance"><description>Returns the actual DOM element</description></method><method name="getLocation" scope="instance"><description>Returns a Region object containing the drag and drop element's position
and size, including the padding configured for it</description></method><method name="getRelated" scope="instance"><description>Returns the drag and drop instances that are in all groups the
passed in instance belongs to.</description></method><method name="isDragDrop" scope="instance"><description>Utility function to determine if a given element has been
registered as a drag drop item.</description></method><method name="isHandle" scope="instance"><description>Utility function to determine if a given element has been
registered as a drag drop handle for the given Drag Drop object.</description></method><method name="isLegalTarget" scope="instance"><description>Returns true if the specified dd target is a legal target for
the specifice drag obj</description></method><method name="isLocked" scope="instance"><description>Is drag and drop locked?</description></method><method name="isTypeOfDD" scope="instance"><description>My goal is to be able to transparently determine if an object is
typeof DragDrop, and the exact subclass of DragDrop.  typeof
returns &quot;object&quot;, oDD.constructor.toString() always returns
&quot;DragDrop&quot; and not the name of the subclass.  So for now it just
evaluates a well-known variable in DragDrop.</description></method><method name="lock" scope="instance"><description>Lock all drag and drop functionality</description></method><method name="refreshCache" scope="instance"><description>Refreshes the cache of the top-left and bottom-right points of the
drag and drop objects in the specified group(s).  This is in the
format that is stored in the drag and drop instance, so typical
usage is:
Ext.dd.DragDropMgr.refreshCache(ddinstance.groups);
Alternatively:
Ext.dd.DragDropMgr.refreshCache({group1:true, group2:true});
</description></method><method name="regDragDrop" scope="instance"><description>Each DragDrop instance must be registered with the DragDropMgr.
This is executed in DragDrop.init()</description></method><method name="regHandle" scope="instance"><description>Each DragDrop handle element must be registered.  This is done
automatically when executing DragDrop.setHandleElId()</description></method><method name="startDrag" scope="instance"><description>Fired when either the drag pixel threshol or the mousedown hold
time threshold has been met.</description></method><method name="stopEvent" scope="instance"><description>Utility to stop event propagation and event default, if these
features are turned on.</description></method><method name="unlock" scope="instance"><description>Unlock all drag and drop functionality</description></method><method name="verifyEl" scope="instance"><description>This checks to make sure an element exists and is in the DOM.  The
main purpose is to handle cases where innerHTML is used to remove
drag and drop objects from the DOM.  IE provides an 'unspecified
error' when trying to access the offsetParent of such an element</description></method></methods></class><class superclass="Ext.layout.AnchorLayout" type="Ext.layout.AbsoluteLayout"><description>This is a layout that inherits the anchoring of Ext.layout.AnchorLayout and adds the
ability for x/y positioning using the standard x and y component config options.
This class is intended to be extended or created via the layout
configuration property.  See Ext.Container.layout for additional details.
Example usage:
var form = new Ext.form.FormPanel({
    title: 'Absolute Layout',
    layout:'absolute',
    layoutConfig: {
        // layout-specific configs go here
        extraCls: 'x-abs-layout-item',
    },
    baseCls: 'x-plain',
    url:'save-form.php',
    defaultType: 'textfield',
    items: [{
        x: 0,
        y: 5,
        xtype:'label',
        text: 'Send To:'
    },{
        x: 60,
        y: 0,
        name: 'to',
        anchor:'100%'  // anchor width by percentage
    },{
        x: 0,
        y: 35,
        xtype:'label',
        text: 'Subject:'
    },{
        x: 60,
        y: 30,
        name: 'subject',
        anchor: '100%'  // anchor width by percentage
    },{
        x:0,
        y: 60,
        xtype: 'textarea',
        name: 'msg',
        anchor: '100% 100%'  // anchor width and height
    }]
});</description><constructors/><properties/><methods><method name="parseMargins" scope="instance"><description>Parses a number or string representing margin sizes into an object. Supports CSS-style margin declarations
(e.g. 10, &quot;10&quot;, &quot;10 10&quot;, &quot;10 10 10&quot; and &quot;10 10 10 10&quot; are all valid options and would return the same result)</description></method></methods></class><class superclass="Object" type="Ext.QuickTips"><description>Provides attractive and customizable tooltips for any element. The QuickTips
singleton is used to configure and manage tooltips globally for multiple elements
in a generic manner.  To create individual tooltips with maximum customizability,
you should consider either Ext.Tip or Ext.ToolTip.
Quicktips can be configured via tag attributes directly in markup, or by
registering quick tips programmatically via the register method.
The singleton's instance of Ext.QuickTip is available via
getQuickTip, and supports all the methods, and all the all the
configuration properties of Ext.QuickTip. These settings will apply to all
tooltips shown by the singleton.
Below is the summary of the configuration properties which can be used.
For detailed descriptions see the config options for the QuickTip class
QuickTips singleton configs (all are optional)
dismissDelay
hideDelay
maxWidth
minWidth
showDelay
trackMouse
Target element configs (optional unless otherwise noted)
autoHide
cls
dismissDelay (overrides singleton value)
target (required)
text (required)
title
width
Here is an example showing how some of these config options could be used:
// Init the singleton.  Any tag-based quick tips will start working.
Ext.QuickTips.init();

// Apply a set of config properties to the singleton
Ext.apply(Ext.QuickTips.getQuickTip(), {
    maxWidth: 200,
    minWidth: 100,
    showDelay: 50,      // Show 50ms after entering target
    trackMouse: true
});

// Manually register a quick tip for a specific element
Ext.QuickTips.register({
    target: 'my-div',
    title: 'My Tooltip',
    text: 'This tooltip was added in code',
    width: 100,
    dismissDelay: 10000 // Hide after 10 seconds hover
});
To register a quick tip in markup, you simply add one or more of the valid QuickTip attributes prefixed with
the ext: namespace.  The HTML element itself is automatically set as the quick tip target. Here is the summary
of supported attributes (optional unless otherwise noted):
hide: Specifying &quot;user&quot; is equivalent to setting autoHide = false.  Any other value will be the
same as autoHide = true.
qclass: A CSS class to be applied to the quick tip (equivalent to the 'cls' target element config).
qtip (required): The quick tip text (equivalent to the 'text' target element config).
qtitle: The quick tip title (equivalent to the 'title' target element config).
qwidth: The quick tip width (equivalent to the 'width' target element config).
Here is an example of configuring an HTML element to display a tooltip from markup:
// Add a quick tip to an HTML button
&lt;input type=&quot;button&quot; value=&quot;OK&quot; ext:qtitle=&quot;OK Button&quot; ext:qwidth=&quot;100&quot;
     ext:qtip=&quot;This is a quick tip from markup!&quot;&gt;&lt;/input&gt;</description><constructors/><properties/><methods><method name="disable" scope="instance"><description>Disable quick tips globally.</description></method><method name="enable" scope="instance"><description>Enable quick tips globally.</description></method><method name="getQuickTip" scope="instance"><description>Gets the single QuickTip instance used to show tips from all registered elements.</description></method><method name="init" scope="instance"><description>Initialize the global QuickTips instance and prepare any quick tips.</description></method><method name="isEnabled" scope="instance"><description>Returns true if quick tips are enabled, else false.</description></method><method name="register" scope="instance"><description>Configures a new quick tip instance and assigns it to a target element.  See
Ext.QuickTip.register for details.</description></method><method name="tips" scope="instance"><description>Alias of register.</description></method><method name="unregister" scope="instance"><description>Removes any registered quick tip from the target element and destroys it.</description></method></methods></class><class superclass="Object" type="Ext.tree.TreeNodeUI"><description>This class provides the default UI implementation for Ext TreeNodes.
The TreeNode UI implementation is separate from the
tree implementation, and allows customizing of the appearance of
tree nodes.

If you are customizing the Tree's user interface, you
may need to extend this class, but you should never need to instantiate this class.

This class provides access to the user interface components of an Ext TreeNode, through
Ext.tree.TreeNode.getUI</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds one or more CSS classes to the node's UI element.
Duplicate classes are automatically filtered out.</description></method><method name="getAnchor" scope="instance"><description>Returns the &lt;a&gt; element that provides focus for the node's UI.</description></method><method name="getEl" scope="instance"><description>Returns the element which encapsulates this node.</description></method><method name="getIconEl" scope="instance"><description>Returns the icon &lt;img&gt; element.</description></method><method name="getTextEl" scope="instance"><description>Returns the text node.</description></method><method name="hide" scope="instance"><description>Hides this node.</description></method><method name="isChecked" scope="instance"><description>Returns the checked status of the node. If the node was rendered with no
checkbox, it returns false.</description></method><method name="removeClass" scope="instance"><description>Removes one or more CSS classes from the node's UI element.</description></method><method name="show" scope="instance"><description>Shows this node.</description></method><method name="toggleCheck" scope="instance"><description>Sets the checked status of the tree node to the passed value, or, if no value was passed,
toggles the checked status. If the node was rendered with no checkbox, this has no effect.</description></method></methods></class><class superclass="Ext.grid.Column" type="Ext.grid.BooleanColumn"><description>A Column definition class which renders boolean data fields.  See the xtype
config option of Ext.grid.Column for more details.</description><constructors/><properties/><methods><method name="getCellEditor" scope="instance"><description>Returns the editor defined for this column that was created to wrap the Field
used to edit the cell.</description></method><method name="setEditor" scope="instance"><description>Sets a new editor for this column.</description></method></methods></class><class superclass="Ext.util.Observable" type="Ext.util.MixedCollection"><description>A Collection class that maintains both numeric indexes and keys and exposes events.</description><constructors/><properties/><methods><method name="add" scope="instance"><description>Adds an item to the collection. Fires the add event when complete.</description></method><method name="addAll" scope="instance"><description>Adds all elements of an Array or an Object to the collection.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="clear" scope="instance"><description>Removes all items from the collection.  Fires the clear event when complete.</description></method><method name="clone" scope="instance"><description>Creates a shallow copy of this collection</description></method><method name="contains" scope="instance"><description>Returns true if the collection contains the passed Object as an item.</description></method><method name="containsKey" scope="instance"><description>Returns true if the collection contains the passed Object as a key.</description></method><method name="each" scope="instance"><description>Executes the specified function once for every item in the collection, passing the following arguments:

item : MixedThe collection item
index : NumberThe item's index
length : NumberThe total number of items in the collection

The function should return a boolean value. Returning false from the function will stop the iteration.</description></method><method name="eachKey" scope="instance"><description>Executes the specified function once for every key in the collection, passing each
key, and its associated item as the first two parameters.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="filter" scope="instance"><description>Filter the objects in this collection by a specific property.
Returns a new collection that has been filtered.</description></method><method name="filterBy" scope="instance"><description>Filter by a function. Returns a new collection that has been filtered.
The passed function will be called with each object in the collection.
If the function returns true, the value is included otherwise it is filtered.</description></method><method name="find" scope="instance"><description>Returns the first item in the collection which elicits a true return value from the
passed selection function.</description></method><method name="findIndex" scope="instance"><description>Finds the index of the first matching object in this collection by a specific property/value.</description></method><method name="findIndexBy" scope="instance"><description>Find the index of the first matching object in this collection by a function.
If the function returns true it is considered a match.</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="first" scope="instance"><description>Returns the first item in the collection.</description></method><method name="get" scope="instance"><description>This method calls item().
Returns the item associated with the passed key OR index. Key has priority
over index.  This is the equivalent of calling key first, then if
nothing matched calling itemAt.</description></method><method name="getCount" scope="instance"><description>Returns the number of items in the collection.</description></method><method name="getKey" scope="instance"><description>MixedCollection has a generic way to fetch keys if you implement getKey.  The default implementation
simply returns item.id but you can provide your own implementation
to return a different value as in the following examples:// normal way
var mc = new Ext.util.MixedCollection();
mc.add(someEl.dom.id, someEl);
mc.add(otherEl.dom.id, otherEl);
//and so on

// using getKey
var mc = new Ext.util.MixedCollection();
mc.getKey = function(el){
   return el.dom.id;
};
mc.add(someEl);
mc.add(otherEl);

// or via the constructor
var mc = new Ext.util.MixedCollection(false, function(el){
   return el.dom.id;
});
mc.add(someEl);
mc.add(otherEl);</description></method><method name="getRange" scope="instance"><description>Returns a range of items in this collection</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="indexOf" scope="instance"><description>Returns index within the collection of the passed Object.</description></method><method name="indexOfKey" scope="instance"><description>Returns index within the collection of the passed key.</description></method><method name="insert" scope="instance"><description>Inserts an item at the specified index in the collection. Fires the add event when complete.</description></method><method name="item" scope="instance"><description>Returns the item associated with the passed key OR index.
Key has priority over index.  This is the equivalent
of calling key first, then if nothing matched calling itemAt.</description></method><method name="itemAt" scope="instance"><description>Returns the item at the specified index.</description></method><method name="key" scope="instance"><description>Returns the item associated with the passed key.</description></method><method name="keySort" scope="instance"><description>Sorts this collection by keys.</description></method><method name="last" scope="instance"><description>Returns the last item in the collection.</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="remove" scope="instance"><description>Remove an item from the collection.</description></method><method name="removeAt" scope="instance"><description>Remove an item from a specified index in the collection. Fires the remove event when complete.</description></method><method name="removeKey" scope="instance"><description>Removed an item associated with the passed key fom the collection.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="reorder" scope="instance"><description>Reorders each of the items based on a mapping from old index to new index. Internally this
just translates into a sort. The 'sort' event is fired whenever reordering has occured.</description></method><method name="replace" scope="instance"><description>Replaces an item in the collection. Fires the replace event when complete.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="sort" scope="instance"><description>Sorts this collection by item value with the passed comparison function.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method></methods></class><class superclass="Ext.data.DataReader" type="Ext.data.XmlReader"><description>Data reader class to create an Array of Ext.data.Record objects from an XML document
based on mappings in a provided Ext.data.Record constructor.
Note: that in order for the browser to parse a returned XML document, the Content-Type
header in the HTTP response must be set to &quot;text/xml&quot; or &quot;application/xml&quot;.
Example code:
var Employee = Ext.data.Record.create([
   {name: 'name', mapping: 'name'},     // &quot;mapping&quot; property not needed if it is the same as &quot;name&quot;
   {name: 'occupation'}                 // This field will use &quot;occupation&quot; as the mapping.
]);
var myReader = new Ext.data.XmlReader({
   totalProperty: &quot;results&quot;, // The element which contains the total dataset size (optional)
   record: &quot;row&quot;,           // The repeated element which contains row information
   idProperty: &quot;id&quot;         // The element within the row that provides an ID for the record (optional)
   messageProperty: &quot;msg&quot;   // The element within the response that provides a user-feedback message (optional)
}, Employee);

This would consume an XML file like this:
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;dataset&gt;
 &lt;results&gt;2&lt;/results&gt;
 &lt;row&gt;
   &lt;id&gt;1&lt;/id&gt;
   &lt;name&gt;Bill&lt;/name&gt;
   &lt;occupation&gt;Gardener&lt;/occupation&gt;
 &lt;/row&gt;
 &lt;row&gt;
   &lt;id&gt;2&lt;/id&gt;
   &lt;name&gt;Ben&lt;/name&gt;
   &lt;occupation&gt;Horticulturalist&lt;/occupation&gt;
 &lt;/row&gt;
&lt;/dataset&gt;</description><constructors/><properties/><methods><method name="isData" scope="instance"><description>Returns true if the supplied data-hash looks and quacks like data.  Checks to see if it has a key
corresponding to idProperty defined in your DataReader config containing non-empty pk.</description></method><method name="read" scope="instance"><description>This method is only used by a DataProxy which has retrieved data from a remote server.</description></method><method name="readRecords" scope="instance"><description>Create a data block containing Ext.data.Records from an XML document.</description></method><method name="readResponse" scope="instance"><description>Decode an XML response from server.</description></method><method name="realize" scope="instance"><description>Used for un-phantoming a record after a successful database insert.  Sets the records pk along with new data from server.
You must return at least the database pk using the idProperty defined in your DataReader configuration.  The incoming
data from server will be merged with the data in the local record.
In addition, you must return record-data from the server in the same order received.
Will perform a commit as well, un-marking dirty-fields.  Store's &quot;update&quot; event will be suppressed.</description></method><method name="update" scope="instance"><description>Used for updating a non-phantom or &quot;real&quot; record's data with fresh data from server after remote-save.
If returning data from multiple-records after a batch-update, you must return record-data from the server in
the same order received.  Will perform a commit as well, un-marking dirty-fields.  Store's &quot;update&quot; event will be
suppressed as the record receives fresh new data-hash</description></method></methods></class><class superclass="Ext.Component" type="Ext.DatePicker"><description>A popup date picker. This class is used by the DateField class
to allow browsing and selection of valid dates.
All the string values documented below may be overridden by including an Ext locale file in
your page.</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getValue" scope="instance"><description>Gets the current selected value of the date field</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setDisabledDates" scope="instance"><description>Replaces any existing disabled dates with new values and refreshes the DatePicker.</description></method><method name="setDisabledDays" scope="instance"><description>Replaces any existing disabled days (by index, 0-6) with new values and refreshes the DatePicker.</description></method><method name="setMaxDate" scope="instance"><description>Replaces any existing maxDate with the new value and refreshes the DatePicker.</description></method><method name="setMinDate" scope="instance"><description>Replaces any existing minDate with the new value and refreshes the DatePicker.</description></method><method name="setValue" scope="instance"><description>Sets the value of the date field</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method></methods></class><class superclass="Ext.util.Observable" type="Ext.form.BasicForm"><description>Encapsulates the DOM &lt;form&gt; element at the heart of the FormPanel class, and provides
input field management, validation, submission, and form loading services.
By default, Ext Forms are submitted through Ajax, using an instance of Ext.form.Action.Submit.
To enable normal browser submission of an Ext Form, use the standardSubmit config option.
File Uploads
File uploads are not performed using Ajax submission, that
is they are not performed using XMLHttpRequests. Instead the form is submitted in the standard
manner with the DOM &lt;form&gt; element temporarily modified to have its
target set to refer
to a dynamically generated, hidden &lt;iframe&gt; which is inserted into the document
but removed after the return data has been gathered.
The server response is parsed by the browser to create the document for the IFRAME. If the
server is using JSON to send the return object, then the
Content-Type header
must be set to &quot;text/html&quot; in order to tell the browser to insert the text unchanged into the document body.
Characters which are significant to an HTML parser must be sent as HTML entities, so encode
&quot;&lt;&quot; as &quot;&amp;lt;&quot;, &quot;&amp;&quot; as &quot;&amp;amp;&quot; etc.
The response text is retrieved from the document, and a fake XMLHttpRequest object
is created containing a responseText property in order to conform to the
requirements of event handlers and callbacks.
Be aware that file upload packets are sent with the content type multipart/form
and some server technologies (notably JEE) may require some custom processing in order to
retrieve parameter names and parameter values from the packet content.</description><constructors/><properties/><methods><method name="add" scope="instance"><description>Add Ext.form Components to this form's Collection. This does not result in rendering of
the passed Component, it just enables the form to validate Fields, and distribute values to
Fields.
You will not usually call this function. In order to be rendered, a Field must be added
to a Container, usually an FormPanel.
The FormPanel to which the field is added takes care of adding the Field to the BasicForm's
collection.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyIfToFields" scope="instance"><description>Calls Ext.applyIf for all field in this form with the passed object.</description></method><method name="applyToFields" scope="instance"><description>Calls Ext.apply for all fields in this form with the passed object.</description></method><method name="cleanDestroyed" scope="instance"><description>Removes all fields from the collection that have been destroyed.</description></method><method name="clearInvalid" scope="instance"><description>Clears all invalid messages in this form.</description></method><method name="doAction" scope="instance"><description>Performs a predefined action (Ext.form.Action.Submit or
Ext.form.Action.Load) or a custom extension of Ext.form.Action
to perform application-specific processing.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findField" scope="instance"><description>Find a Ext.form.Field in this form.</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="getEl" scope="instance"><description>Get the HTML form Element</description></method><method name="getFieldValues" scope="instance"><description>Retrieves the fields in the form as a set of key/value pairs, using the getValue() method.
If multiple fields exist with the same name they are returned as an array.</description></method><method name="getValues" scope="instance"><description>Returns the fields in this form as an object with key/value pairs as they would be submitted using a standard form submit.
If multiple fields exist with the same name they are returned as an array.
Note: The values are collected from all enabled HTML input elements within the form, not from
the Ext Field objects. This means that all returned values are Strings (or Arrays of Strings) and that the
value can potentially be the emptyText of a field.</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="isDirty" scope="instance"><description>Returns true if any fields in this form have changed from their original values.
Note that if this BasicForm was configured with trackResetOnLoad then the
Fields' original values are updated when the values are loaded by setValues
or loadRecord.</description></method><method name="isValid" scope="instance"><description>Returns true if client-side validation on the form is successful.</description></method><method name="load" scope="instance"><description>Shortcut to do a load action.</description></method><method name="loadRecord" scope="instance"><description>Loads an Ext.data.Record into this form by calling setValues with the
record data.
See also trackResetOnLoad.</description></method><method name="markInvalid" scope="instance"><description>Mark fields in this form invalid in bulk.</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="remove" scope="instance"><description>Removes a field from the items collection (does NOT remove its markup).</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Iterates through the Fields which have been added to this BasicForm,
checks them for an id attribute, and calls Ext.form.Field.applyToMarkup on the existing dom element with that id.</description></method><method name="reset" scope="instance"><description>Resets this form.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setValues" scope="instance"><description>Set values for fields in this form in bulk.</description></method><method name="submit" scope="instance"><description>Shortcut to do a submit action.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="updateRecord" scope="instance"><description>Persists the values in this form into the passed Ext.data.Record object in a beginEdit/endEdit block.</description></method></methods></class><class superclass="Object" type="Ext.util.DelayedTask"><description> The DelayedTask class provides a convenient way to &quot;buffer&quot; the execution of a method,
performing setTimeout where a new timeout cancels the old timeout. When called, the
task will wait the specified time period before executing. If durng that time period,
the task is called again, the original call will be cancelled. This continues so that
the function is only called a single time for each iteration.
This method is especially useful for things like detecting whether a user has finished
typing in a text field. An example would be performing validation on a keypress. You can
use this class to buffer the keypress events for a certain number of milliseconds, and
perform only if they stop for that amount of time.  Usage:var task = new Ext.util.DelayedTask(function(){
    alert(Ext.getDom('myInputField').value.length);
});
// Wait 500ms before calling our function. If the user presses another key 
// during that 500ms, it will be cancelled and we'll wait another 500ms.
Ext.get('myInputField').on('keypress', function(){
    task.delay(500); 
}); 
Note that we are using a DelayedTask here to illustrate a point. The configuration
option buffer for addListener/on will
also setup a delayed task for you to buffer events.</description><constructors/><properties/><methods><method name="cancel" scope="instance"><description>Cancel the last queued timeout</description></method><method name="delay" scope="instance"><description>Cancels any pending timeout and queues a new one</description></method></methods></class><class superclass="Ext.util.Observable" type="Ext.list.Sorter"><description>Supporting Class for Ext.list.ListView</description><constructors/><properties/><methods><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method></methods></class><class superclass="Ext.data.Node" type="Ext.tree.TreeNode"><description/><constructors/><properties/><methods><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="appendChild" scope="instance"><description>Insert node(s) as the last child node of this node.</description></method><method name="bubble" scope="instance"><description>Bubbles up the tree from this node, calling the specified function with each node. The arguments to the function
will be the args provided or the current node. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cascade" scope="instance"><description>Cascades down the tree from this node, calling the specified function with each node. The arguments to the function
will be the args provided or the current node. If the function returns false at any point,
the cascade is stopped on that branch.</description></method><method name="collapse" scope="instance"><description>Collapse this node.</description></method><method name="collapseChildNodes" scope="instance"><description>Collapse all child nodes</description></method><method name="contains" scope="instance"><description>Returns true if this node is an ancestor (at any point) of the passed node.</description></method><method name="destroy" scope="instance"><description>Destroys the node.</description></method><method name="disable" scope="instance"><description>Disables this node</description></method><method name="eachChild" scope="instance"><description>Interates the child nodes of this node, calling the specified function with each node. The arguments to the function
will be the args provided or the current node. If the function returns false at any point,
the iteration stops.</description></method><method name="enable" scope="instance"><description>Enables this node</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="ensureVisible" scope="instance"><description>Ensures all parent nodes are expanded, and if necessary, scrolls
the node into view.</description></method><method name="expand" scope="instance"><description>Expand this node.</description></method><method name="expandChildNodes" scope="instance"><description>Expand all child nodes</description></method><method name="findChild" scope="instance"><description>Finds the first child that has the attribute with the specified value.</description></method><method name="findChildBy" scope="instance"><description>Finds the first child by a custom function. The child matches if the function passed returns true.</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="getDepth" scope="instance"><description>Returns depth of this node (the root node has a depth of 0)</description></method><method name="getOwnerTree" scope="instance"><description>Returns the tree this node is in.</description></method><method name="getPath" scope="instance"><description>Returns the path for this node. The path can be used to expand or select this node programmatically.</description></method><method name="getUI" scope="instance"><description>Returns the UI object for this node.</description></method><method name="hasChildNodes" scope="instance"><description>Returns true if this node has one or more child nodes, else false.</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="indexOf" scope="instance"><description>Returns the index of a child node</description></method><method name="insertBefore" scope="instance"><description>Inserts the first node before the second node in this nodes childNodes collection.</description></method><method name="isAncestor" scope="instance"><description>Returns true if the passed node is an ancestor (at any point) of this node.</description></method><method name="isExpandable" scope="instance"><description>Returns true if this node has one or more child nodes, or if the expandable
node attribute is explicitly specified as true (see attributes), otherwise returns false.</description></method><method name="isExpanded" scope="instance"><description>Returns true if this node is expanded</description></method><method name="isFirst" scope="instance"><description>Returns true if this node is the first child of its parent</description></method><method name="isLast" scope="instance"><description>Returns true if this node is the last child of its parent</description></method><method name="isLeaf" scope="instance"><description>Returns true if this node is a leaf</description></method><method name="isSelected" scope="instance"><description>Returns true if this node is selected</description></method><method name="item" scope="instance"><description>Returns the child node at the specified index.</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="remove" scope="instance"><description>Removes this node from its parent</description></method><method name="removeAll" scope="instance"><description>Removes all child nodes from this node.</description></method><method name="removeChild" scope="instance"><description>Removes a child node from this node.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="replaceChild" scope="instance"><description>Replaces one child node in this node with another.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="select" scope="instance"><description>Triggers selection of this node</description></method><method name="setCls" scope="instance"><description>Sets the class on this node.</description></method><method name="setHref" scope="instance"><description>Sets the href for the node.</description></method><method name="setIcon" scope="instance"><description>Sets the icon for this node.</description></method><method name="setIconCls" scope="instance"><description>Sets the icon class for this node.</description></method><method name="setId" scope="instance"><description>Changes the id of this node.</description></method><method name="setText" scope="instance"><description>Sets the text for this node</description></method><method name="setTooltip" scope="instance"><description>Sets the tooltip for this node.</description></method><method name="sort" scope="instance"><description>Sorts this nodes children using the supplied sort function.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="toggle" scope="instance"><description>Toggles expanded/collapsed state of the node</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="unselect" scope="instance"><description>Triggers deselection of this node</description></method></methods></class><class superclass="Ext.util.MixedCollection" type="Ext.StoreMgr"><description>The default global group of stores.</description><constructors/><properties/><methods><method name="add" scope="instance"><description>Adds an item to the collection. Fires the add event when complete.</description></method><method name="addAll" scope="instance"><description>Adds all elements of an Array or an Object to the collection.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="clear" scope="instance"><description>Removes all items from the collection.  Fires the clear event when complete.</description></method><method name="clone" scope="instance"><description>Creates a shallow copy of this collection</description></method><method name="contains" scope="instance"><description>Returns true if the collection contains the passed Object as an item.</description></method><method name="containsKey" scope="instance"><description>Returns true if the collection contains the passed Object as a key.</description></method><method name="each" scope="instance"><description>Executes the specified function once for every item in the collection, passing the following arguments:

item : MixedThe collection item
index : NumberThe item's index
length : NumberThe total number of items in the collection

The function should return a boolean value. Returning false from the function will stop the iteration.</description></method><method name="eachKey" scope="instance"><description>Executes the specified function once for every key in the collection, passing each
key, and its associated item as the first two parameters.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="filter" scope="instance"><description>Filter the objects in this collection by a specific property.
Returns a new collection that has been filtered.</description></method><method name="filterBy" scope="instance"><description>Filter by a function. Returns a new collection that has been filtered.
The passed function will be called with each object in the collection.
If the function returns true, the value is included otherwise it is filtered.</description></method><method name="find" scope="instance"><description>Returns the first item in the collection which elicits a true return value from the
passed selection function.</description></method><method name="findIndex" scope="instance"><description>Finds the index of the first matching object in this collection by a specific property/value.</description></method><method name="findIndexBy" scope="instance"><description>Find the index of the first matching object in this collection by a function.
If the function returns true it is considered a match.</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="first" scope="instance"><description>Returns the first item in the collection.</description></method><method name="get" scope="instance"><description>This method calls item().
Returns the item associated with the passed key OR index. Key has priority
over index.  This is the equivalent of calling key first, then if
nothing matched calling itemAt.</description></method><method name="getCount" scope="instance"><description>Returns the number of items in the collection.</description></method><method name="getKey" scope="instance"><description>MixedCollection has a generic way to fetch keys if you implement getKey.  The default implementation
simply returns item.id but you can provide your own implementation
to return a different value as in the following examples:// normal way
var mc = new Ext.util.MixedCollection();
mc.add(someEl.dom.id, someEl);
mc.add(otherEl.dom.id, otherEl);
//and so on

// using getKey
var mc = new Ext.util.MixedCollection();
mc.getKey = function(el){
   return el.dom.id;
};
mc.add(someEl);
mc.add(otherEl);

// or via the constructor
var mc = new Ext.util.MixedCollection(false, function(el){
   return el.dom.id;
});
mc.add(someEl);
mc.add(otherEl);</description></method><method name="getRange" scope="instance"><description>Returns a range of items in this collection</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="indexOf" scope="instance"><description>Returns index within the collection of the passed Object.</description></method><method name="indexOfKey" scope="instance"><description>Returns index within the collection of the passed key.</description></method><method name="insert" scope="instance"><description>Inserts an item at the specified index in the collection. Fires the add event when complete.</description></method><method name="item" scope="instance"><description>Returns the item associated with the passed key OR index.
Key has priority over index.  This is the equivalent
of calling key first, then if nothing matched calling itemAt.</description></method><method name="itemAt" scope="instance"><description>Returns the item at the specified index.</description></method><method name="key" scope="instance"><description>Returns the item associated with the passed key.</description></method><method name="keySort" scope="instance"><description>Sorts this collection by keys.</description></method><method name="last" scope="instance"><description>Returns the last item in the collection.</description></method><method name="lookup" scope="instance"><description>Gets a registered Store by id</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="register" scope="instance"><description>Registers one or more Stores with the StoreMgr. You do not normally need to register stores
manually.  Any store initialized with a Ext.data.Store.storeId will be auto-registered.</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="remove" scope="instance"><description>Remove an item from the collection.</description></method><method name="removeAt" scope="instance"><description>Remove an item from a specified index in the collection. Fires the remove event when complete.</description></method><method name="removeKey" scope="instance"><description>Removed an item associated with the passed key fom the collection.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="reorder" scope="instance"><description>Reorders each of the items based on a mapping from old index to new index. Internally this
just translates into a sort. The 'sort' event is fired whenever reordering has occured.</description></method><method name="replace" scope="instance"><description>Replaces an item in the collection. Fires the replace event when complete.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="sort" scope="instance"><description>Sorts this collection by item value with the passed comparison function.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="unregister" scope="instance"><description>Unregisters one or more Stores with the StoreMgr</description></method></methods></class><class superclass="Ext.Component" type="Ext.BoxComponent"><description>Base class for any Component that is to be sized as a box, using width and height.
BoxComponent provides automatic box model adjustments for sizing and positioning and will work correctly
within the Component rendering model.
A BoxComponent may be created as a custom Component which encapsulates any HTML element, either a pre-existing
element, or one that is created to your specifications at render time. Usually, to participate in layouts,
a Component will need to be a BoxComponent in order to have its width and height managed.
To use a pre-existing element as a BoxComponent, configure it so that you preset the el property to the
element to reference:var pageHeader = new Ext.BoxComponent({
    el: 'my-header-div'
});
This may then be added to a Container as a child item.
To create a BoxComponent based around a HTML element to be created at render time, use the
autoEl config option which takes the form of a
DomHelper specification:var myImage = new Ext.BoxComponent({
    autoEl: {
        tag: 'img',
        src: '/images/my-image.jpg'
    }
});</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method></methods></class><class superclass="Object" type="Ext.DomQuery"><description>Provides high performance selector/xpath processing by compiling queries into reusable functions. New pseudo classes and matchers can be plugged. It works on HTML and XML documents (if a content node is passed in).

DomQuery supports most of the CSS3 selectors spec, along with some custom selectors and basic XPath.


All selectors, attribute filters and pseudos below can be combined infinitely in any order. For example &quot;div.foo:nth-child(odd)[@foo=bar].bar:first&quot; would be a perfectly valid selector. Node filters are processed in the order in which they appear, which allows you to optimize your queries for your document structure.

Element Selectors:

     * any element
     E an element with the tag E
     E F All descendent elements of E that have the tag F
     E &gt; F or E/F all direct children elements of E that have the tag F
     E + F all elements with the tag F that are immediately preceded by an element with the tag E
     E ~ F all elements with the tag F that are preceded by a sibling element with the tag E

Attribute Selectors:
The use of &#64; and quotes are optional. For example, div[&#64;foo='bar'] is also a valid attribute selector.

     E[foo] has an attribute &quot;foo&quot;
     E[foo=bar] has an attribute &quot;foo&quot; that equals &quot;bar&quot;
     E[foo^=bar] has an attribute &quot;foo&quot; that starts with &quot;bar&quot;
     E[foo$=bar] has an attribute &quot;foo&quot; that ends with &quot;bar&quot;
     E[foo*=bar] has an attribute &quot;foo&quot; that contains the substring &quot;bar&quot;
     E[foo%=2] has an attribute &quot;foo&quot; that is evenly divisible by 2
     E[foo!=bar] attribute &quot;foo&quot; does not equal &quot;bar&quot;

Pseudo Classes:

     E:first-child E is the first child of its parent
     E:last-child E is the last child of its parent
     E:nth-child(n) E is the nth child of its parent (1 based as per the spec)
     E:nth-child(odd) E is an odd child of its parent
     E:nth-child(even) E is an even child of its parent
     E:only-child E is the only child of its parent
     E:checked E is an element that is has a checked attribute that is true (e.g. a radio or checkbox) 
     E:first the first E in the resultset
     E:last the last E in the resultset
     E:nth(n) the nth E in the resultset (1 based)
     E:odd shortcut for :nth-child(odd)
     E:even shortcut for :nth-child(even)
     E:contains(foo) E's innerHTML contains the substring &quot;foo&quot;
     E:nodeValue(foo) E contains a textNode with a nodeValue that equals &quot;foo&quot;
     E:not(S) an E element that does not match simple selector S
     E:has(S) an E element that has a descendent that matches simple selector S
     E:next(S) an E element whose next sibling matches simple selector S
     E:prev(S) an E element whose previous sibling matches simple selector S
     E:any(S1|S2|S2) an E element which matches any of the simple selectors S1, S2 or S3//\\

CSS Value Selectors:

     E{display=none} css value &quot;display&quot; that equals &quot;none&quot;
     E{display^=none} css value &quot;display&quot; that starts with &quot;none&quot;
     E{display$=none} css value &quot;display&quot; that ends with &quot;none&quot;
     E{display*=none} css value &quot;display&quot; that contains the substring &quot;none&quot;
     E{display%=2} css value &quot;display&quot; that is evenly divisible by 2
     E{display!=none} css value &quot;display&quot; that does not equal &quot;none&quot;
</description><constructors/><properties/><methods><method name="compile" scope="instance"><description>Compiles a selector/xpath query into a reusable function. The returned function
takes one parameter &quot;root&quot; (optional), which is the context node from where the query should start.</description></method><method name="filter" scope="instance"><description>Filters an array of elements to only include matches of a simple selector (e.g. div.some-class or span:first-child)</description></method><method name="is" scope="instance"><description>Returns true if the passed element(s) match the passed simple selector (e.g. div.some-class or span:first-child)</description></method><method name="jsSelect" scope="instance"><description>Selects a group of elements.</description></method><method name="operators" scope="instance"><description>Collection of operator comparison functions. The default operators are =, !=, ^=, $=, *=, %=, |= and ~=.
New operators can be added as long as the match the format c= where c is any character other than space, &gt; &lt;.</description></method><method name="selectNode" scope="instance"><description>Selects a single element.</description></method><method name="selectNumber" scope="instance"><description>Selects the value of a node, parsing integers and floats. Returns the defaultValue, or 0 if none is specified.</description></method><method name="selectValue" scope="instance"><description>Selects the value of a node, optionally replacing null with the defaultValue.</description></method></methods></class><class superclass="Ext.Panel" type="Ext.TabPanel"><description>A basic tab container. TabPanels can be used exactly like a standard Ext.Panel
for layout purposes, but also have special support for containing child Components
(items) that are managed using a
CardLayout layout manager, and displayed as separate tabs.
Note: By default, a tab's close tool destroys the child tab Component
and all its descendants. This makes the child tab Component, and all its descendants unusable. To enable
re-use of a tab, configure the TabPanel with autoDestroy: false.
TabPanel header/footer elements
TabPanels use their header or footer element
(depending on the tabPosition configuration) to accommodate the tab selector buttons.
This means that a TabPanel will not display any configured title, and will not display any
configured header tools.
To display a header, embed the TabPanel in a Panel which uses
layout:'fit'.
Tab Events
There is no actual tab class &amp;mdash; each tab is simply a Component
such as a Panel. However, when rendered in a TabPanel, each child Component
can fire additional events that only exist for tabs and are not available from other Components.
These events are:

activate : Fires when this Component becomes
the active tab.
deactivate : Fires when the Component that
was the active tab becomes deactivated.
beforeclose : Fires when the user clicks on the close tool of a closeable tab.
May be vetoed by returning false from a handler.
close : Fires a closeable tab has been closed by the user.

Creating TabPanels from Code
TabPanels can be created and rendered completely in code, as in this example:
var tabs = new Ext.TabPanel({
    renderTo: Ext.getBody(),
    activeTab: 0,
    items: [{
        title: 'Tab 1',
        html: 'A simple tab'
    },{
        title: 'Tab 2',
        html: 'Another one'
    }]
});
Creating TabPanels from Existing Markup
TabPanels can also be rendered from pre-existing markup in a couple of ways.

Pre-Structured Markup

A container div with one or more nested tab divs with class 'x-tab' can be rendered entirely
from existing markup (See the autoTabs example).

Un-Structured Markup

A TabPanel can also be rendered from markup that is not strictly structured by simply specifying by id
which elements should be the container and the tabs. Using this method tab content can be pulled from different
elements within the page by id regardless of page structure. For example:
var tabs = new Ext.TabPanel({
    renderTo: 'my-tabs',
    activeTab: 0,
    items:[
        {contentEl:'tab1', title:'Tab 1'},
        {contentEl:'tab2', title:'Tab 2'}
    ]
});

// Note that the tabs do not have to be nested within the container (although they can be)
&lt;div id=&quot;my-tabs&quot;&gt;&lt;/div&gt;
&lt;div id=&quot;tab1&quot; class=&quot;x-hide-display&quot;&gt;A simple tab&lt;/div&gt;
&lt;div id=&quot;tab2&quot; class=&quot;x-hide-display&quot;&gt;Another one&lt;/div&gt;
Note that the tab divs in this example contain the class 'x-hide-display' so that they can be rendered
deferred without displaying outside the tabs. You could alternately set deferredRender = false 
to render all content tabs on page load.

</description><constructors/><properties/><methods><method name="activate" scope="instance"><description>See setActiveTab. Sets the specified tab as the active tab. This method fires
the beforetabchange event which can return false to cancel the tab change.</description></method><method name="add" scope="instance"><description>Adds Component(s) to this Container.
Description :

Fires the beforeadd event before adding
The Container's default config values will be applied
accordingly (see defaults for details).
Fires the add event after the component has been added.

Notes :

If the Container is already rendered when add
is called, you may need to call doLayout to refresh the view which causes
any unrendered child Components to be rendered. This is required so that you can
add multiple child components if needed while only refreshing the layout
once. For example:var tb = new Ext.Toolbar();
tb.render(document.body);  // toolbar is rendered
tb.add({text:'Button 1'}); // add multiple items (defaultType for Toolbar is 'button')
tb.add({text:'Button 2'});
tb.doLayout();             // refresh the layout
Warning: Containers directly managed by the BorderLayout layout manager
may not be removed or added.  See the Notes for BorderLayout
for more details.
</description></method><method name="addButton" scope="instance"><description>Adds a button to this panel.  Note that this method must be called prior to rendering.  The preferred
approach is to add buttons via the buttons config.</description></method><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="beginUpdate" scope="instance"><description>Suspends any internal calculations or scrolling while doing a bulk operation. See endUpdate</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cascade" scope="instance"><description>Cascades down the component/container heirarchy from this component (called first), calling the specified function with
each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the cascade is stopped on that branch.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="collapse" scope="instance"><description>Collapses the panel body so that it becomes hidden.  Fires the beforecollapse event which will
cancel the collapse action if it returns false.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="doLayout" scope="instance"><description>Force this container's layout to be recalculated. A call to this function is required after adding a new component
to an already rendered container, or possibly after changing sizing/position properties of child components.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="endUpdate" scope="instance"><description>Resumes calculations and scrolling at the end of a bulk operation. See beginUpdate</description></method><method name="expand" scope="instance"><description>Expands the panel body so that it becomes visible.  Fires the beforeexpand event which will
cancel the expand action if it returns false.</description></method><method name="find" scope="instance"><description>Find a component under this container at any level by property</description></method><method name="findBy" scope="instance"><description>Find a component under this container at any level by a custom function. If the passed function returns
true, the component will be included in the results. The passed function is called with the arguments (component, this container).</description></method><method name="findById" scope="instance"><description>Find a component under this container at any level by id</description></method><method name="findByType" scope="instance"><description>Find a component under this container at any level by xtype or class</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="get" scope="instance"><description>Get a component contained by this container (alias for items.get(key))</description></method><method name="getActiveTab" scope="instance"><description>Returns the Component which is the currently active tab. Note that before the TabPanel
first activates a child Component, this method will return whatever was configured in the
activeTab config option.</description></method><method name="getBottomToolbar" scope="instance"><description>Returns the toolbar from the bottom (bbar) section of the panel.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getComponent" scope="instance"><description>Examines this container's items property
and gets a direct child component of this container.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getFooterToolbar" scope="instance"><description>Returns the toolbar from the footer (fbar) section of the panel.</description></method><method name="getFrameHeight" scope="instance"><description>Returns the height in pixels of the framing elements of this panel (including any top and bottom bars and
header and footer elements, but not including the body height).  To retrieve the body height see getInnerHeight.</description></method><method name="getFrameWidth" scope="instance"><description>Returns the width in pixels of the framing elements of this panel (not including the body width).  To
retrieve the body width see getInnerWidth.</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getInnerHeight" scope="instance"><description>Returns the height in pixels of the body element (not including the height of any framing elements).
For the frame height see getFrameHeight.</description></method><method name="getInnerWidth" scope="instance"><description>Returns the width in pixels of the body element (not including the width of any framing elements).
For the frame width see getFrameWidth.</description></method><method name="getItem" scope="instance"><description>Gets the specified tab by id.</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getLayout" scope="instance"><description>Returns the layout currently in use by the container.  If the container does not currently have a layout
set, a default Ext.layout.ContainerLayout will be created and set as the container's layout.</description></method><method name="getLayoutTarget" scope="instance"><description>Returns the Element to be used to contain the child Components of this Container.
An implementation is provided which returns the Container's Element, but
if there is a more complex structure to a Container, this may be overridden to return
the element into which the layout renders child Components.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getTabEl" scope="instance"><description>Gets the DOM element for the tab strip item which activates the child panel with the specified
ID. Access this to change the visual treatment of the item, for example by changing the CSS class name.</description></method><method name="getTemplateArgs" scope="instance"><description>Provides template arguments for rendering a tab selector item in the tab strip.
This method returns an object hash containing properties used by the TabPanel's itemTpl
to create a formatted, clickable tab selector element. The properties which must be returned
are:
id : StringA unique identifier which links to the item
text : StringThe text to display
cls : StringThe CSS class name
iconCls : StringA CSS class to provide appearance for an icon.
</description></method><method name="getTool" scope="instance"><description>Retrieve a tool by id.</description></method><method name="getTopToolbar" scope="instance"><description>Returns the toolbar from the top (tbar) section of the panel.</description></method><method name="getUpdater" scope="instance"><description>Get the Ext.Updater for this panel. Enables you to perform Ajax updates of this panel's body.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="hideTabStripItem" scope="instance"><description>Hides the tab strip item for the passed tab</description></method><method name="insert" scope="instance"><description>Inserts a Component into this Container at a specified index. Fires the
beforeadd event before inserting, then fires the add event after the
Component has been inserted.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="load" scope="instance"><description>Loads this content panel immediately with content returned from an XHR call.</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="readTabs" scope="instance"><description>True to scan the markup in this tab panel for autoTabs using the
autoTabSelector</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="remove" scope="instance"><description>Removes a component from this container.  Fires the beforeremove event before removing, then fires
the remove event after the component has been removed.</description></method><method name="removeAll" scope="instance"><description>Removes all components from this container.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="scrollToTab" scope="instance"><description>Scrolls to a particular tab if tab scrolling is enabled</description></method><method name="setActiveTab" scope="instance"><description>Sets the specified tab as the active tab. This method fires the beforetabchange event which
can return false to cancel the tab change.</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setIconClass" scope="instance"><description>Sets the CSS class that provides the icon image for this panel.  This method will replace any existing
icon class if one has already been set and fire the iconchange event after completion.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setTitle" scope="instance"><description>Sets the title text for the panel and optionally the icon class.
In order to be able to set the title, a header element must have been created
for the Panel. This is triggered either by configuring the Panel with a non-blank title,
or configuring it with header: true.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="toggleCollapse" scope="instance"><description>Shortcut for performing an expand or collapse based on the current state of the panel.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="unhideTabStripItem" scope="instance"><description>Unhides the tab strip item for the passed tab</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method></methods></class><class superclass="Object" type="Ext"><description>Ext core utilities and functions.</description><constructors/><properties/><methods><method name="addBehaviors" scope="instance"><description>Applies event listeners to elements by selectors when the document is ready.
The event name is specified with an &#64; suffix.
Ext.addBehaviors({
    // add a listener for click on all anchors in element with id foo
    '#foo a&#64;click' : function(e, t){
        // do something
    },

    // add the same listener to multiple selectors (separated by comma BEFORE the &#64;)
    '#foo a, #bar span.some-class&#64;mouseover' : function(){
        // do something
    }
});</description></method><method name="apply" scope="instance"><description>Copies all the properties of config to obj.</description></method><method name="applyIf" scope="instance"><description>Copies all the properties of config to obj if they don't already exist.</description></method><method name="clean" scope="instance"><description>Creates a copy of the passed Array with falsy values removed.</description></method><method name="copyTo" scope="instance"><description>Copies a set of named properties fom the source object to the destination object.
example:ImageComponent = Ext.extend(Ext.BoxComponent, {
    initComponent: function() {
        this.autoEl = { tag: 'img' };
        MyComponent.superclass.initComponent.apply(this, arguments);
        this.initialBox = Ext.copyTo({}, this.initialConfig, 'x,y,width,height');
    }
});</description></method><method name="create" scope="instance"><description>Shorthand for Ext.ComponentMgr.create
Creates a new Component from the specified config object using the
config object's xtype to determine the class to instantiate.</description></method><method name="decode" scope="instance"><description>Shorthand for Ext.util.JSON.decode</description></method><method name="defer" scope="instance"><description>Shorthand for Ext.util.Functions.createDelegate</description></method><method name="destroy" scope="instance"><description>Attempts to destroy any objects passed to it by removing all event listeners, removing them from the
DOM (if applicable) and calling their destroy functions (if available).  This method is primarily
intended for arguments of type Ext.Element and Ext.Component, but any subclass of
Ext.util.Observable can be passed in.  Any number of elements and/or components can be
passed into this function in a single call as separate arguments.</description></method><method name="destroyMembers" scope="instance"><description>Attempts to destroy and then remove a set of named properties of the passed object.</description></method><method name="each" scope="instance"><description>Iterates an array calling the supplied function.</description></method><method name="encode" scope="instance"><description>Shorthand for Ext.util.JSON.encode</description></method><method name="escapeRe" scope="instance"><description>Escapes the passed string for use in a regular expression</description></method><method name="extend" scope="instance"><description>Extends one class to create a subclass and optionally overrides members with the passed literal. This method
also adds the function &quot;override()&quot; to the subclass that can be used to override members of the class.
For example, to create a subclass of Ext GridPanel:
MyGridPanel = Ext.extend(Ext.grid.GridPanel, {
    constructor: function(config) {

//      Create configuration for this Grid.
        var store = new Ext.data.Store({...});
        var colModel = new Ext.grid.ColumnModel({...});

//      Create a new config object containing our computed properties
//      *plus* whatever was in the config parameter.
        config = Ext.apply({
            store: store,
            colModel: colModel
        }, config);

        MyGridPanel.superclass.constructor.call(this, config);

//      Your postprocessing here
    },

    yourMethod: function() {
        // etc.
    }
});
This function also supports a 3-argument call in which the subclass's constructor is
passed as an argument. In this form, the parameters are as follows:

subclass : Function The subclass constructor.
superclass : Function The constructor of class being extended
overrides : Object A literal with members which are copied into the subclass's
prototype, and are therefore shared among all instances of the new class.
</description></method><method name="flatten" scope="instance"><description>Recursively flattens into 1-d Array. Injects Arrays inline.</description></method><method name="fly" scope="instance"><description>Gets the globally shared flyweight Element, with the passed node as the active element. Do not store a reference to this element -
the dom node can be overwritten by other code. Shorthand of Ext.Element.fly
Use this to make one-time references to DOM elements which are not going to be accessed again either by
application code, or by Ext's classes. If accessing an element which will be processed regularly, then Ext.get
will be more appropriate to take advantage of the caching provided by the Ext.Element class.</description></method><method name="get" scope="instance"><description>Retrieves Ext.Element objects.
This method does not retrieve Components. This method
retrieves Ext.Element objects which encapsulate DOM elements. To retrieve a Component by
its ID, use Ext.ComponentMgr.get.
Uses simple caching to consistently return the same object. Automatically fixes if an
object was recreated with the same id via AJAX or DOM.
Shorthand of Ext.Element.get</description></method><method name="getBody" scope="instance"><description>Returns the current document body as an Ext.Element.</description></method><method name="getCmp" scope="instance"><description>This is shorthand reference to Ext.ComponentMgr.get.
Looks up an existing Component by id</description></method><method name="getDoc" scope="instance"><description>Returns the current HTML document object as an Ext.Element.</description></method><method name="getDom" scope="instance"><description>Return the dom node for the passed String (id), dom node, or Ext.Element.
Optional 'strict' flag is needed for IE since it can return 'name' and
'id' elements by using getElementById.
Here are some examples:
// gets dom node based on id
var elDom = Ext.getDom('elId');
// gets dom node based on the dom node
var elDom1 = Ext.getDom(elDom);

// If we don&#39;t know if we are working with an
// Ext.Element or a dom node use Ext.getDom
function(el){
    var dom = Ext.getDom(el);
    // do something with the dom node
}
Note: the dom node to be found actually needs to exist (be rendered, etc)
when this method is called to be successful.</description></method><method name="getHead" scope="instance"><description>Returns the current document body as an Ext.Element.</description></method><method name="getScrollBarWidth" scope="instance"><description>Utility method for getting the width of the browser scrollbar. This can differ depending on
operating system settings, such as the theme or font size.</description></method><method name="id" scope="instance"><description>Generates unique ids. If the element already has an id, it is unchanged</description></method><method name="invoke" scope="instance"><description>Invokes a method on each item in an Array.
// Example:
Ext.invoke(Ext.query(&quot;p&quot;), &quot;getAttribute&quot;, &quot;id&quot;);
// [el1.getAttribute(&quot;id&quot;), el2.getAttribute(&quot;id&quot;), ..., elN.getAttribute(&quot;id&quot;)]</description></method><method name="isArray" scope="instance"><description>Returns true if the passed value is a JavaScript array, otherwise false.</description></method><method name="isBoolean" scope="instance"><description>Returns true if the passed value is a boolean.</description></method><method name="isDate" scope="instance"><description>Returns true if the passed object is a JavaScript date object, otherwise false.</description></method><method name="isDefined" scope="instance"><description>Returns true if the passed value is not undefined.</description></method><method name="isElement" scope="instance"><description>Returns true if the passed value is an HTMLElement</description></method><method name="isEmpty" scope="instance"><description>Returns true if the passed value is empty.
The value is deemed to be empty if it is
null
undefined
an empty array
a zero length string (Unless the allowBlank parameter is true)
</description></method><method name="isFunction" scope="instance"><description>Returns true if the passed value is a JavaScript Function, otherwise false.</description></method><method name="isNumber" scope="instance"><description>Returns true if the passed value is a number. Returns false for non-finite numbers.</description></method><method name="isObject" scope="instance"><description>Returns true if the passed value is a JavaScript Object, otherwise false.</description></method><method name="isPrimitive" scope="instance"><description>Returns true if the passed value is a JavaScript 'primitive', a string, number or boolean.</description></method><method name="isString" scope="instance"><description>Returns true if the passed value is a string.</description></method><method name="iterate" scope="instance"><description>Iterates either the elements in an array, or each of the properties in an object.
Note: If you are only iterating arrays, it is better to call each.</description></method><method name="max" scope="instance"><description>Returns the maximum value in the Array</description></method><method name="mean" scope="instance"><description>Calculates the mean of the Array</description></method><method name="min" scope="instance"><description>Returns the minimum value in the Array.</description></method><method name="namespace" scope="instance"><description>Creates namespaces to be used for scoping variables and classes so that they are not global.
Specifying the last node of a namespace implicitly creates all other nodes. Usage:
Ext.namespace('Company', 'Company.data');
Ext.namespace('Company.data'); // equivalent and preferable to above syntax
Company.Widget = function() { ... }
Company.data.CustomStore = function(config) { ... }</description></method><method name="ns" scope="instance"><description>Creates namespaces to be used for scoping variables and classes so that they are not global.
Specifying the last node of a namespace implicitly creates all other nodes. Usage:
Ext.namespace('Company', 'Company.data');
Ext.namespace('Company.data'); // equivalent and preferable to above syntax
Company.Widget = function() { ... }
Company.data.CustomStore = function(config) { ... }</description></method><method name="num" scope="instance"><description>Utility method for validating that a value is numeric, returning the specified default value if it is not.</description></method><method name="onReady" scope="instance"><description>Adds a listener to be notified when the document is ready (before onload and before images are loaded). Shorthand of Ext.EventManager.onDocumentReady.</description></method><method name="override" scope="instance"><description>Adds a list of functions to the prototype of an existing class, overwriting any existing methods with the same name.
Usage:Ext.override(MyClass, {
    newMethod1: function(){
        // etc.
    },
    newMethod2: function(foo){
        // etc.
    }
});</description></method><method name="partition" scope="instance"><description>Partitions the set into two sets: a true set and a false set.
Example:
Example2:
// Example 1:
Ext.partition([true, false, true, true, false]); // [[true, true, true], [false, false]]

// Example 2:
Ext.partition(
    Ext.query(&quot;p&quot;),
    function(val){
        return val.className == &quot;class1&quot;
    }
);
// true are those paragraph elements with a className of &quot;class1&quot;,
// false set are those that do not have that className.</description></method><method name="pluck" scope="instance"><description>Plucks the value of a property from each item in the Array
// Example:
Ext.pluck(Ext.query(&quot;p&quot;), &quot;className&quot;); // [el1.className, el2.className, ..., elN.className]</description></method><method name="preg" scope="instance"><description>Shorthand for Ext.ComponentMgr.registerPlugin</description></method><method name="query" scope="instance"><description>Selects an array of DOM nodes by CSS/XPath selector. Shorthand of Ext.DomQuery.select</description></method><method name="reg" scope="instance"><description>Shorthand for Ext.ComponentMgr.registerType</description></method><method name="removeNode" scope="instance"><description>Removes this element from the document, removes all DOM event listeners, and deletes the cache reference.
All DOM event listeners are removed from this element. If Ext.enableNestedListenerRemoval is
true, then DOM event listeners are also removed from all child nodes. The body node
will be ignored if passed in.</description></method><method name="select" scope="instance"><description>Selects elements based on the passed CSS selector to enable Element methods
to be applied to many related elements in one statement through the returned CompositeElement or
CompositeElementLite object.</description></method><method name="sum" scope="instance"><description>Calculates the sum of the Array</description></method><method name="toArray" scope="instance"><description>Converts any iterable (numeric indices and a length property) into a true array
Don't use this on strings. IE doesn't support &quot;abc&quot;[0] which this implementation depends on.
For strings, use this instead: &quot;abc&quot;.match(/./g) =&gt; [a,b,c];</description></method><method name="type" scope="instance"><description>Returns the type of object that is passed in. If the object passed in is null or undefined it
return false otherwise it returns one of the following values:
string: If the object passed is a string
number: If the object passed is a number
boolean: If the object passed is a boolean value
date: If the object passed is a Date object
function: If the object passed is a function reference
object: If the object passed is an object
array: If the object passed is an array
regexp: If the object passed is a regular expression
element: If the object passed is a DOM Element
nodelist: If the object passed is a DOM NodeList
textnode: If the object passed is a DOM text node and contains something other than whitespace
whitespace: If the object passed is a DOM text node and contains only whitespace
</description></method><method name="unique" scope="instance"><description>Creates a copy of the passed Array, filtered to contain only unique values.</description></method><method name="urlAppend" scope="instance"><description>Appends content to the query string of a URL, handling logic for whether to place
a question mark or ampersand.</description></method><method name="urlDecode" scope="instance"><description>Takes an encoded URL and and converts it to an object. Example: Ext.urlDecode(&quot;foo=1&amp;bar=2&quot;); // returns {foo: &quot;1&quot;, bar: &quot;2&quot;}
Ext.urlDecode(&quot;foo=1&amp;bar=2&amp;bar=3&amp;bar=4&quot;, false); // returns {foo: &quot;1&quot;, bar: [&quot;2&quot;, &quot;3&quot;, &quot;4&quot;]}</description></method><method name="urlEncode" scope="instance"><description>Takes an object and converts it to an encoded URL. e.g. Ext.urlEncode({foo: 1, bar: 2}); would return &quot;foo=1&amp;bar=2&quot;.  Optionally, property values can be arrays, instead of keys and the resulting string that's returned will contain a name/value pair for each array value.</description></method><method name="value" scope="instance"><description>Utility method for returning a default value if the passed value is empty.
The value is deemed to be empty if it is
null
undefined
an empty array
a zero length string (Unless the allowBlank parameter is true)
</description></method><method name="zip" scope="instance"><description>Zips N sets together.
// Example 1:
Ext.zip([1,2,3],[4,5,6]); // [[1,4],[2,5],[3,6]]
// Example 2:
Ext.zip(
    [ &quot;+&quot;, &quot;-&quot;, &quot;+&quot;],
    [  12,  10,  22],
    [  43,  15,  96],
    function(a, b, c){
        return &quot;$&quot; + a + &quot;&quot; + b + &quot;.&quot; + c
    }
); // [&quot;$+12.43&quot;, &quot;$-10.15&quot;, &quot;$+22.96&quot;]</description></method></methods></class><class superclass="Ext.data.DataProxy" type="Ext.data.MemoryProxy"><description>An implementation of Ext.data.DataProxy that simply passes the data specified in its constructor
to the Reader when its load method is called.</description><constructors/><properties/><methods><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="destroy" scope="instance"><description>Destroys the proxy by purging any event listeners and cancelling any active requests.</description></method><method name="doRequest" scope="instance"><description>MemoryProxy implementation of DataProxy#doRequest</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="isApiAction" scope="instance"><description>Returns true if the specified action is defined as a unique action in the api-config.
request.  If all API-actions are routed to unique urls, the xaction parameter is unecessary.  However, if no api is defined
and all Proxy actions are routed to DataProxy#url, the server-side will require the xaction parameter to perform a switch to
the corresponding code for CRUD action.</description></method><method name="load" scope="instance"><description>Deprecated load method using old method signature. See {@doRequest} for preferred method.</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="request" scope="instance"><description>All proxy actions are executed through this method.  Automatically fires the &quot;before&quot; + action event</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setApi" scope="instance"><description>Redefines the Proxy's API or a single action of an API. Can be called with two method signatures.
If called with an object as the only parameter, the object should redefine the entire API, e.g.:proxy.setApi({
    read    : '/users/read',
    create  : '/users/create',
    update  : '/users/update',
    destroy : '/users/destroy'
});
If called with two parameters, the first parameter should be a string specifying the API action to
redefine and the second parameter should be the URL (or function if using DirectProxy) to call for that action, e.g.:proxy.setApi(Ext.data.Api.actions.read, '/users/new_load_url');</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method></methods></class><class superclass="Ext.BoxComponent" type="Ext.Button"><description>Simple Button class</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getPressed" scope="instance"><description>Gets the pressed button in the passed group or null</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getTemplateArgs" scope="instance"><description>This method returns an Array which provides substitution parameters for the Template used
to create this Button's DOM structure.
Instances or subclasses which use a different Template to create a different DOM structure may need to provide their
own implementation of this method.
The default implementation which provides data for the default template returns an Array containing the
following items:
The &lt;button&gt;'s type
A CSS class name applied to the Button's main &lt;tbody&gt; element which determines the button's scale and icon alignment.
A CSS class to determine the presence and position of an arrow icon. ('x-btn-arrow' or 'x-btn-arrow-bottom' or '')
The cls CSS class name applied to the button's wrapping &lt;table&gt; element.
The Component id which is applied to the button's wrapping &lt;table&gt; element.
</description></method><method name="getText" scope="instance"><description>Gets the text for this Button</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hasVisibleMenu" scope="instance"><description>Returns true if the button has a menu and it is visible</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="hideMenu" scope="instance"><description>Hide this button's menu (if it has one)</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHandler" scope="instance"><description>Assigns this Button's click handler</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setIcon" scope="instance"><description>Sets the background image (inline style) of the button.  This method also changes
the value of the icon config internally.</description></method><method name="setIconClass" scope="instance"><description>Sets the CSS class that provides a background image to use as the button's icon.  This method also changes
the value of the iconCls config internally.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setText" scope="instance"><description>Sets this Button's text</description></method><method name="setTooltip" scope="instance"><description>Sets the tooltip for this Button.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="showMenu" scope="instance"><description>Show this button's menu (if it has one)</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="toggle" scope="instance"><description>If a state it passed, it becomes the pressed state otherwise the current state is toggled.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method></methods></class><class superclass="Object" type="Ext.dd.StatusProxy"><description>A specialized drag proxy that supports a drop status icon, Ext.Layer styles and auto-repair.  This is the
default drag proxy used by all Ext.dd components.</description><constructors/><properties/><methods><method name="getEl" scope="instance"><description>Returns the underlying proxy Ext.Layer</description></method><method name="getGhost" scope="instance"><description>Returns the ghost element</description></method><method name="hide" scope="instance"><description>Hides the proxy</description></method><method name="repair" scope="instance"><description>Causes the proxy to return to its position of origin via an animation.  Should be called after an
invalid drop operation by the item being dragged.</description></method><method name="reset" scope="instance"><description>Resets the status indicator to the default dropNotAllowed value</description></method><method name="setStatus" scope="instance"><description>Updates the proxy's visual element to indicate the status of whether or not drop is allowed
over the current target element.</description></method><method name="show" scope="instance"><description>Displays this proxy</description></method><method name="stop" scope="instance"><description>Stops the repair animation if it's currently running</description></method><method name="sync" scope="instance"><description>Force the Layer to sync its shadow and shim positions to the element</description></method><method name="update" scope="instance"><description>Updates the contents of the ghost element</description></method></methods></class><class superclass="Ext.grid.EditorGridPanel" type="Ext.grid.PropertyGrid"><description>A specialized grid implementation intended to mimic the traditional property grid as typically seen in
development IDEs.  Each row in the grid represents a property of some object, and the data is stored
as a set of name/value pairs in Ext.grid.PropertyRecords.  Example usage:
var grid = new Ext.grid.PropertyGrid({
    title: 'Properties Grid',
    autoHeight: true,
    width: 300,
    renderTo: 'grid-ct',
    source: {
        &quot;(name)&quot;: &quot;My Object&quot;,
        &quot;Created&quot;: new Date(Date.parse('10/15/2006')),
        &quot;Available&quot;: false,
        &quot;Version&quot;: .01,
        &quot;Description&quot;: &quot;A test object&quot;
    }
});</description><constructors/><properties/><methods><method name="addButton" scope="instance"><description>Adds a button to this panel.  Note that this method must be called prior to rendering.  The preferred
approach is to add buttons via the buttons config.</description></method><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="collapse" scope="instance"><description>Collapses the panel body so that it becomes hidden.  Fires the beforecollapse event which will
cancel the collapse action if it returns false.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="expand" scope="instance"><description>Expands the panel body so that it becomes visible.  Fires the beforeexpand event which will
cancel the expand action if it returns false.</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="get" scope="instance"><description>Get a component contained by this container (alias for items.get(key))</description></method><method name="getBottomToolbar" scope="instance"><description>Returns the toolbar from the bottom (bbar) section of the panel.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getColumnModel" scope="instance"><description>Returns the grid's ColumnModel.</description></method><method name="getDragDropText" scope="instance"><description>Called to get grid's drag proxy text, by default returns this.ddText.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getFooterToolbar" scope="instance"><description>Returns the toolbar from the footer (fbar) section of the panel.</description></method><method name="getFrameHeight" scope="instance"><description>Returns the height in pixels of the framing elements of this panel (including any top and bottom bars and
header and footer elements, but not including the body height).  To retrieve the body height see getInnerHeight.</description></method><method name="getFrameWidth" scope="instance"><description>Returns the width in pixels of the framing elements of this panel (not including the body width).  To
retrieve the body width see getInnerWidth.</description></method><method name="getGridEl" scope="instance"><description>Returns the grid's underlying element.</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getInnerHeight" scope="instance"><description>Returns the height in pixels of the body element (not including the height of any framing elements).
For the frame height see getFrameHeight.</description></method><method name="getInnerWidth" scope="instance"><description>Returns the width in pixels of the body element (not including the width of any framing elements).
For the frame width see getFrameWidth.</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getLayoutTarget" scope="instance"><description>Returns the Element to be used to contain the child Components of this Container.
An implementation is provided which returns the Container's Element, but
if there is a more complex structure to a Container, this may be overridden to return
the element into which the layout renders child Components.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSelectionModel" scope="instance"><description>Returns the grid's selection model configured by the selModel
configuration option. If no selection model was configured, this will create
and return a RowSelectionModel.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getSource" scope="instance"><description>Gets the source data object containing the property data.  See setSource for details regarding the
format of the data object.</description></method><method name="getStore" scope="instance"><description>Returns the grid's data store.</description></method><method name="getTool" scope="instance"><description>Retrieve a tool by id.</description></method><method name="getTopToolbar" scope="instance"><description>Returns the toolbar from the top (tbar) section of the panel.</description></method><method name="getView" scope="instance"><description>Returns the grid's GridView object.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="reconfigure" scope="instance"><description>Reconfigures the grid to use a different Store and Column Model
and fires the 'reconfigure' event. The View will be bound to the new
objects and refreshed.
Be aware that upon reconfiguring a GridPanel, certain existing settings may become
invalidated. For example the configured autoExpandColumn may no longer exist in the
new ColumnModel. Also, an existing PagingToolbar will still be bound
to the old Store, and will need rebinding. Any plugins might also need reconfiguring
with the new data.</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeAll" scope="instance"><description>Removes all components from this container.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="removeProperty" scope="instance"><description>Removes a property from the grid.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setIconClass" scope="instance"><description>Sets the CSS class that provides the icon image for this panel.  This method will replace any existing
icon class if one has already been set and fire the iconchange event after completion.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setProperty" scope="instance"><description>Sets the value of a property.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setSource" scope="instance"><description>Sets the source data object containing the property data.  The data object can contain one or more name/value
pairs representing all of the properties of an object to display in the grid, and this data will automatically
be loaded into the grid's store.  The values should be supplied in the proper data type if needed,
otherwise string type will be assumed.  If the grid already contains data, this method will replace any
existing data.  See also the source config value.  Example usage:
grid.setSource({
    &quot;(name)&quot;: &quot;My Object&quot;,
    &quot;Created&quot;: new Date(Date.parse('10/15/2006')),  // date type
    &quot;Available&quot;: false,  // boolean type
    &quot;Version&quot;: .01,      // decimal type
    &quot;Description&quot;: &quot;A test object&quot;
});</description></method><method name="setTitle" scope="instance"><description>Sets the title text for the panel and optionally the icon class.
In order to be able to set the title, a header element must have been created
for the Panel. This is triggered either by configuring the Panel with a non-blank title,
or configuring it with header: true.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="startEditing" scope="instance"><description>Starts editing the specified for the specified row/column</description></method><method name="stopEditing" scope="instance"><description>Stops any active editing</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="toggleCollapse" scope="instance"><description>Shortcut for performing an expand or collapse based on the current state of the panel.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method></methods></class><class superclass="Ext.form.Action.Load" type="Ext.form.Action.DirectLoad"><description>Provides Ext.direct support for loading form data.
This example illustrates usage of Ext.Direct to load a form through Ext.Direct.
var myFormPanel = new Ext.form.FormPanel({
    // configs for FormPanel
    title: 'Basic Information',
    renderTo: document.body,
    width: 300, height: 160,
    padding: 10,

    // configs apply to child items
    defaults: {anchor: '100%'},
    defaultType: 'textfield',
    items: [{
        fieldLabel: 'Name',
        name: 'name'
    },{
        fieldLabel: 'Email',
        name: 'email'
    },{
        fieldLabel: 'Company',
        name: 'company'
    }],

    // configs for BasicForm
    api: {
        // The server-side method to call for load() requests
        load: Profile.getBasicInfo,
        // The server-side must mark the submit handler as a 'formHandler'
        submit: Profile.updateBasicInfo
    },
    // specify the order for the passed params
    paramOrder: ['uid', 'foo']
});

// load the form
myFormPanel.getForm().load({
    // pass 2 arguments to server side getBasicInfo method (len=2)
    params: {
        foo: 'bar',
        uid: 34
    }
});
The data packet sent to the server will resemble something like:
[
    {
        &quot;action&quot;:&quot;Profile&quot;,&quot;method&quot;:&quot;getBasicInfo&quot;,&quot;type&quot;:&quot;rpc&quot;,&quot;tid&quot;:2,
        &quot;data&quot;:[34,&quot;bar&quot;] // note the order of the params
    }
]
The form will process a data packet returned by the server that is similar
to the following format:
[
    {
        &quot;action&quot;:&quot;Profile&quot;,&quot;method&quot;:&quot;getBasicInfo&quot;,&quot;type&quot;:&quot;rpc&quot;,&quot;tid&quot;:2,
        &quot;result&quot;:{
            &quot;success&quot;:true,
            &quot;data&quot;:{
                &quot;name&quot;:&quot;Fred Flintstone&quot;,
                &quot;company&quot;:&quot;Slate Rock and Gravel&quot;,
                &quot;email&quot;:&quot;fred.flintstone@slaterg.com&quot;
            }
        }
    }
]</description><constructors/><properties/><methods/></class><class superclass="Ext.data.DataProxy" type="Ext.data.ScriptTagProxy"><description>An implementation of Ext.data.DataProxy that reads a data object from a URL which may be in a domain
other than the originating domain of the running page.

Note that if you are retrieving data from a page that is in a domain that is NOT the same as the originating domain
of the running page, you must use this class, rather than HttpProxy.

The content passed back from a server resource requested by a ScriptTagProxy must be executable JavaScript
source code because it is used as the source inside a &lt;script&gt; tag.

In order for the browser to process the returned data, the server must wrap the data object
with a call to a callback function, the name of which is passed as a parameter by the ScriptTagProxy.
Below is a Java example for a servlet which returns data for either a ScriptTagProxy, or an HttpProxy
depending on whether the callback name was passed:

boolean scriptTag = false;
String cb = request.getParameter(&quot;callback&quot;);
if (cb != null) {
    scriptTag = true;
    response.setContentType(&quot;text/javascript&quot;);
} else {
    response.setContentType(&quot;application/x-json&quot;);
}
Writer out = response.getWriter();
if (scriptTag) {
    out.write(cb + &quot;(&quot;);
}
out.print(dataBlock.toJsonString());
if (scriptTag) {
    out.write(&quot;);&quot;);
}
Below is a PHP example to do the same thing:$callback = $_REQUEST['callback'];

// Create the output object.
$output = array('a' =&gt; 'Apple', 'b' =&gt; 'Banana');

//start output
if ($callback) {
    header('Content-Type: text/javascript');
    echo $callback . '(' . json_encode($output) . ');';
} else {
    header('Content-Type: application/x-json');
    echo json_encode($output);
}
Below is the ASP.Net code to do the same thing:String jsonString = &quot;{success: true}&quot;;
String cb = Request.Params.Get(&quot;callback&quot;);
String responseString = &quot;&quot;;
if (!String.IsNullOrEmpty(cb)) {
    responseString = cb + &quot;(&quot; + jsonString + &quot;)&quot;;
} else {
    responseString = jsonString;
}
Response.Write(responseString);</description><constructors/><properties/><methods><method name="abort" scope="instance"><description>Abort the current server request.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="destroy" scope="instance"><description>Destroys the proxy by purging any event listeners and cancelling any active requests.</description></method><method name="doRequest" scope="instance"><description>HttpProxy implementation of DataProxy#doRequest</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="isApiAction" scope="instance"><description>Returns true if the specified action is defined as a unique action in the api-config.
request.  If all API-actions are routed to unique urls, the xaction parameter is unecessary.  However, if no api is defined
and all Proxy actions are routed to DataProxy#url, the server-side will require the xaction parameter to perform a switch to
the corresponding code for CRUD action.</description></method><method name="load" scope="instance"><description>Deprecated load method using old method signature. See {@doRequest} for preferred method.</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="onRead" scope="instance"><description>Callback for read actions</description></method><method name="onWrite" scope="instance"><description>Callback for write actions</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="request" scope="instance"><description>All proxy actions are executed through this method.  Automatically fires the &quot;before&quot; + action event</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setApi" scope="instance"><description>Redefines the Proxy's API or a single action of an API. Can be called with two method signatures.
If called with an object as the only parameter, the object should redefine the entire API, e.g.:proxy.setApi({
    read    : '/users/read',
    create  : '/users/create',
    update  : '/users/update',
    destroy : '/users/destroy'
});
If called with two parameters, the first parameter should be a string specifying the API action to
redefine and the second parameter should be the URL (or function if using DirectProxy) to call for that action, e.g.:proxy.setApi(Ext.data.Api.actions.read, '/users/new_load_url');</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method></methods></class><class superclass="Ext.layout.ContainerLayout" type="Ext.layout.FitLayout"><description>This is a base class for layouts that contain a single item that automatically expands to fill the layout's
container.  This class is intended to be extended or created via the layout:'fit' Ext.Container.layout
config, and should generally not need to be created directly via the new keyword.
FitLayout does not have any direct config options (other than inherited ones).  To fit a panel to a container
using FitLayout, simply set layout:'fit' on the container and add a single panel to it.  If the container has
multiple panels, only the first one will be displayed.  Example usage:
var p = new Ext.Panel({
    title: 'Fit Layout',
    layout:'fit',
    items: {
        title: 'Inner Panel',
        html: '&lt;p&gt;This is the inner panel content&lt;/p&gt;',
        border: false
    }
});</description><constructors/><properties/><methods><method name="parseMargins" scope="instance"><description>Parses a number or string representing margin sizes into an object. Supports CSS-style margin declarations
(e.g. 10, &quot;10&quot;, &quot;10 10&quot;, &quot;10 10 10&quot; and &quot;10 10 10 10&quot; are all valid options and would return the same result)</description></method></methods></class><class superclass="Ext.Component" type="Ext.menu.BaseItem"><description>The base class for all items that render into menus.  BaseItem provides default rendering, activated state
management and base configuration options shared by all menu components.</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHandler" scope="instance"><description>Sets the function that will handle click events for this item (equivalent to passing in the handler
config property).  If an existing handler is already registered, it will be unregistered for you.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method></methods></class><class superclass="Ext.chart.CartesianChart" type="Ext.chart.StackedColumnChart"><description/><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bindStore" scope="instance"><description>Changes the data store bound to this chart and refreshes it.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setSeriesStyles" scope="instance"><description>Sets the styles on all series in the Chart.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setStyle" scope="instance"><description>Sets a single style value on the Chart instance.</description></method><method name="setStyles" scope="instance"><description>Resets all styles on the Chart instance.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method></methods></class><class superclass="Ext.data.DataReader" type="Ext.data.JsonReader"><description>Data reader class to create an Array of Ext.data.Record objects
from a JSON packet based on mappings in a provided Ext.data.Record
constructor.
Example code:
var myReader = new Ext.data.JsonReader({
    // metadata configuration options:
    idProperty: 'id'
    root: 'rows',
    totalProperty: 'results',
    Ext.data.DataReader.messageProperty: &quot;msg&quot;  // The element within the response that provides a user-feedback message (optional)

    // the fields config option will internally create an Ext.data.Record
    // constructor that provides mapping for reading the record data objects
    fields: [
        // map Record&#39;s 'firstname' field to data object&#39;s key of same name
        {name: 'name', mapping: 'firstname'},
        // map Record&#39;s 'job' field to data object&#39;s 'occupation' key
        {name: 'job', mapping: 'occupation'}
    ]
});
This would consume a JSON data object of the form:{
    results: 2000, // Reader&#39;s configured totalProperty
    rows: [        // Reader&#39;s configured root
        // record data objects:
        { id: 1, firstname: 'Bill', occupation: 'Gardener' },
        { id: 2, firstname: 'Ben' , occupation: 'Horticulturalist' },
        ...
    ]
}
Automatic configuration using metaData
It is possible to change a JsonReader's metadata at any time by including
a metaData property in the JSON data object. If the JSON data
object has a metaData property, a Store
object using this Reader will reconfigure itself to use the newly provided
field definition and fire its metachange
event. The metachange event handler may interrogate the metaData
property to perform any configuration required.
Note that reconfiguring a Store potentially invalidates objects which may
refer to Fields or Records which no longer exist.
To use this facility you would create the JsonReader like this:var myReader = new Ext.data.JsonReader();
The first data packet from the server would configure the reader by
containing a metaData property and the data. For
example, the JSON data object might take the form:{
    metaData: {
        &quot;idProperty&quot;: &quot;id&quot;,
        &quot;root&quot;: &quot;rows&quot;,
        &quot;totalProperty&quot;: &quot;results&quot;
        &quot;successProperty&quot;: &quot;success&quot;,
        &quot;fields&quot;: [
            {&quot;name&quot;: &quot;name&quot;},
            {&quot;name&quot;: &quot;job&quot;, &quot;mapping&quot;: &quot;occupation&quot;}
        ],
        // used by store to set its sortInfo
        &quot;sortInfo&quot;:{
           &quot;field&quot;: &quot;name&quot;,
           &quot;direction&quot;: &quot;ASC&quot;
        },
        // paging data (if applicable)
        &quot;start&quot;: 0,
        &quot;limit&quot;: 2,
        // custom property
        &quot;foo&quot;: &quot;bar&quot;
    },
    // Reader&#39;s configured successProperty
    &quot;success&quot;: true,
    // Reader&#39;s configured totalProperty
    &quot;results&quot;: 2000,
    // Reader&#39;s configured root
    // (this data simulates 2 results per page)
    &quot;rows&quot;: [ // *Note: this must be an Array
        { &quot;id&quot;: 1, &quot;name&quot;: &quot;Bill&quot;, &quot;occupation&quot;: &quot;Gardener&quot; },
        { &quot;id&quot;: 2, &quot;name&quot;:  &quot;Ben&quot;, &quot;occupation&quot;: &quot;Horticulturalist&quot; }
    ]
}
The metaData property in the JSON data object should contain:

any of the configuration options for this class
a fields property which
the JsonReader will use as an argument to the
data Record create method in order to
configure the layout of the Records it will produce.
a sortInfo property
which the JsonReader will use to set the Ext.data.Store's
sortInfo property
any custom properties needed
</description><constructors/><properties/><methods><method name="isData" scope="instance"><description>Returns true if the supplied data-hash looks and quacks like data.  Checks to see if it has a key
corresponding to idProperty defined in your DataReader config containing non-empty pk.</description></method><method name="read" scope="instance"><description>This method is only used by a DataProxy which has retrieved data from a remote server.</description></method><method name="readRecords" scope="instance"><description>Create a data block containing Ext.data.Records from a JSON object.</description></method><method name="readResponse" scope="instance"><description>Decode a JSON response from server.</description></method><method name="realize" scope="instance"><description>Used for un-phantoming a record after a successful database insert.  Sets the records pk along with new data from server.
You must return at least the database pk using the idProperty defined in your DataReader configuration.  The incoming
data from server will be merged with the data in the local record.
In addition, you must return record-data from the server in the same order received.
Will perform a commit as well, un-marking dirty-fields.  Store's &quot;update&quot; event will be suppressed.</description></method><method name="update" scope="instance"><description>Used for updating a non-phantom or &quot;real&quot; record's data with fresh data from server after remote-save.
If returning data from multiple-records after a batch-update, you must return record-data from the server in
the same order received.  Will perform a commit as well, un-marking dirty-fields.  Store's &quot;update&quot; event will be
suppressed as the record receives fresh new data-hash</description></method></methods></class><class superclass="Object" type="Ext.util.Observable"><description>Base class that provides a common interface for publishing events. Subclasses are expected to
to have a property &quot;events&quot; with all the events defined, and, optionally, a property &quot;listeners&quot;
with configured listeners defined.
For example:
Employee = Ext.extend(Ext.util.Observable, {
    constructor: function(config){
        this.name = config.name;
        this.addEvents({
            &quot;fired&quot; : true,
            &quot;quit&quot; : true
        });

        // Copy configured listeners into *this* object so that the base class&#39;s
        // constructor will add them.
        this.listeners = config.listeners;

        // Call our superclass constructor to complete construction process.
        Employee.superclass.constructor.call(this, config)
    }
});
This could then be used like this:var newEmployee = new Employee({
    name: employeeName,
    listeners: {
        quit: function() {
            // By default, &quot;this&quot; will be the object that fired the event.
            alert(this.name + &quot; has quit!&quot;);
        }
    }
});</description><constructors/><properties/><methods><method name="Observable.capture" scope="instance"><description>Starts capture on the specified Observable. All events will be passed
to the supplied function with the event name + standard signature of the event
before the event is fired. If the supplied function returns false,
the event will not fire.</description></method><method name="Observable.observeClass" scope="instance"><description>Sets observability on the passed class constructor.
This makes any event fired on any instance of the passed class also fire a single event through
the class allowing for central handling of events on many instances at once.
Usage:Ext.util.Observable.observeClass(Ext.data.Connection);
Ext.data.Connection.on('beforerequest', function(con, options) {
    console.log('Ajax request made to ' + options.url);
});</description></method><method name="Observable.releaseCapture" scope="instance"><description>Removes all added captures from the Observable.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method></methods></class><class superclass="Object" type="Ext.list.Column"><description>This class encapsulates column configuration data to be used in the initialization of a
ListView.
While subclasses are provided to render data in different ways, this class renders a passed
data field unchanged and is usually used for textual columns.</description><constructors/><properties/><methods/></class><class superclass="Ext.Panel" type="Ext.tree.TreePanel"><description>The TreePanel provides tree-structured UI representation of tree-structured data.
TreeNodes added to the TreePanel may each contain metadata
used by your application in their attributes property.
A TreePanel must have a root node before it is rendered. This may either be
specified using the root config option, or using the setRootNode method.
An example of tree rendered to an existing div:var tree = new Ext.tree.TreePanel({
    renderTo: 'tree-div',
    useArrows: true,
    autoScroll: true,
    animate: true,
    enableDD: true,
    containerScroll: true,
    border: false,
    // auto create TreeLoader
    dataUrl: 'get-nodes.php',

    root: {
        nodeType: 'async',
        text: 'Ext JS',
        draggable: false,
        id: 'source'
    }
});

tree.getRootNode().expand();
The example above would work with a data packet similar to this:[{
    &quot;text&quot;: &quot;adapter&quot;,
    &quot;id&quot;: &quot;source\/adapter&quot;,
    &quot;cls&quot;: &quot;folder&quot;
}, {
    &quot;text&quot;: &quot;dd&quot;,
    &quot;id&quot;: &quot;source\/dd&quot;,
    &quot;cls&quot;: &quot;folder&quot;
}, {
    &quot;text&quot;: &quot;debug.js&quot;,
    &quot;id&quot;: &quot;source\/debug.js&quot;,
    &quot;leaf&quot;: true,
    &quot;cls&quot;: &quot;file&quot;
}]
An example of tree within a Viewport:new Ext.Viewport({
    layout: 'border',
    items: [{
        region: 'west',
        collapsible: true,
        title: 'Navigation',
        xtype: 'treepanel',
        width: 200,
        autoScroll: true,
        split: true,
        loader: new Ext.tree.TreeLoader(),
        root: new Ext.tree.AsyncTreeNode({
            expanded: true,
            children: [{
                text: 'Menu Option 1',
                leaf: true
            }, {
                text: 'Menu Option 2',
                leaf: true
            }, {
                text: 'Menu Option 3',
                leaf: true
            }]
        }),
        rootVisible: false,
        listeners: {
            click: function(n) {
                Ext.Msg.alert('Navigation Tree Click', 'You clicked: &quot;' + n.attributes.text + '&quot;');
            }
        }
    }, {
        region: 'center',
        xtype: 'tabpanel',
        // remaining code not shown ...
    }]
});</description><constructors/><properties/><methods><method name="add" scope="instance"><description>Adds Component(s) to this Container.
Description :

Fires the beforeadd event before adding
The Container's default config values will be applied
accordingly (see defaults for details).
Fires the add event after the component has been added.

Notes :

If the Container is already rendered when add
is called, you may need to call doLayout to refresh the view which causes
any unrendered child Components to be rendered. This is required so that you can
add multiple child components if needed while only refreshing the layout
once. For example:var tb = new Ext.Toolbar();
tb.render(document.body);  // toolbar is rendered
tb.add({text:'Button 1'}); // add multiple items (defaultType for Toolbar is 'button')
tb.add({text:'Button 2'});
tb.doLayout();             // refresh the layout
Warning: Containers directly managed by the BorderLayout layout manager
may not be removed or added.  See the Notes for BorderLayout
for more details.
</description></method><method name="addButton" scope="instance"><description>Adds a button to this panel.  Note that this method must be called prior to rendering.  The preferred
approach is to add buttons via the buttons config.</description></method><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="collapse" scope="instance"><description>Collapses the panel body so that it becomes hidden.  Fires the beforecollapse event which will
cancel the collapse action if it returns false.</description></method><method name="collapseAll" scope="instance"><description>Collapse all nodes</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="expand" scope="instance"><description>Expands the panel body so that it becomes visible.  Fires the beforeexpand event which will
cancel the expand action if it returns false.</description></method><method name="expandAll" scope="instance"><description>Expand all nodes</description></method><method name="expandPath" scope="instance"><description>Expands a specified path in this TreePanel. A path can be retrieved from a node with Ext.data.Node.getPath</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="get" scope="instance"><description>Get a component contained by this container (alias for items.get(key))</description></method><method name="getBottomToolbar" scope="instance"><description>Returns the toolbar from the bottom (bbar) section of the panel.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getChecked" scope="instance"><description>Retrieve an array of checked nodes, or an array of a specific attribute of checked nodes (e.g. 'id')</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getFooterToolbar" scope="instance"><description>Returns the toolbar from the footer (fbar) section of the panel.</description></method><method name="getFrameHeight" scope="instance"><description>Returns the height in pixels of the framing elements of this panel (including any top and bottom bars and
header and footer elements, but not including the body height).  To retrieve the body height see getInnerHeight.</description></method><method name="getFrameWidth" scope="instance"><description>Returns the width in pixels of the framing elements of this panel (not including the body width).  To
retrieve the body width see getInnerWidth.</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getInnerHeight" scope="instance"><description>Returns the height in pixels of the body element (not including the height of any framing elements).
For the frame height see getFrameHeight.</description></method><method name="getInnerWidth" scope="instance"><description>Returns the width in pixels of the body element (not including the width of any framing elements).
For the frame width see getFrameWidth.</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getLayoutTarget" scope="instance"><description>Returns the Element to be used to contain the child Components of this Container.
An implementation is provided which returns the Container's Element, but
if there is a more complex structure to a Container, this may be overridden to return
the element into which the layout renders child Components.</description></method><method name="getLoader" scope="instance"><description>Returns the default Ext.tree.TreeLoader for this TreePanel.</description></method><method name="getNodeById" scope="instance"><description>Gets a node in this tree by its id</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getRootNode" scope="instance"><description>Returns this root node for this tree</description></method><method name="getSelectionModel" scope="instance"><description>Returns the selection model used by this TreePanel.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getTool" scope="instance"><description>Retrieve a tool by id.</description></method><method name="getTopToolbar" scope="instance"><description>Returns the toolbar from the top (tbar) section of the panel.</description></method><method name="getTreeEl" scope="instance"><description>Returns the underlying Element for this tree</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="selectPath" scope="instance"><description>Selects the node in this tree at the specified path. A path can be retrieved from a node with Ext.data.Node.getPath</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setIconClass" scope="instance"><description>Sets the CSS class that provides the icon image for this panel.  This method will replace any existing
icon class if one has already been set and fire the iconchange event after completion.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setRootNode" scope="instance"><description>Sets the root node for this tree. If the TreePanel has already rendered a root node, the
previous root node (and all of its descendants) are destroyed before the new root node is rendered.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setTitle" scope="instance"><description>Sets the title text for the panel and optionally the icon class.
In order to be able to set the title, a header element must have been created
for the Panel. This is triggered either by configuring the Panel with a non-blank title,
or configuring it with header: true.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="toggleCollapse" scope="instance"><description>Shortcut for performing an expand or collapse based on the current state of the panel.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method></methods></class><class superclass="Object" type="Ext.grid.Column"><description>This class encapsulates column configuration data to be used in the initialization of a
ColumnModel.
While subclasses are provided to render data in different ways, this class renders a passed
data field unchanged and is usually used for textual columns.</description><constructors/><properties/><methods><method name="getCellEditor" scope="instance"><description>Returns the editor defined for this column that was created to wrap the Field
used to edit the cell.</description></method><method name="setEditor" scope="instance"><description>Sets a new editor for this column.</description></method></methods></class><class superclass="Ext.Container" type="Ext.menu.Menu"><description>A menu object.  This is the container to which you may add menu items.  Menu can also serve as a base class
when you want a specialized menu based off of another component (like Ext.menu.DateMenu for example).
Menus may contain either menu items, or general Components.
To make a contained general Component line up with other menu items
specify iconCls: 'no-icon'.  This reserves a space for an icon, and indents the Component in line
with the other menu items.  See Ext.form.ComboBox.getListParent
for an example.
By default, Menus are absolutely positioned, floating Components. By configuring a Menu with
floating:false, a Menu may be used as child of a Container.</description><constructors/><properties/><methods><method name="add" scope="instance"><description>Adds Component(s) to this Container.
Description :

Fires the beforeadd event before adding
The Container's default config values will be applied
accordingly (see defaults for details).
Fires the add event after the component has been added.

Notes :

If the Container is already rendered when add
is called, you may need to call doLayout to refresh the view which causes
any unrendered child Components to be rendered. This is required so that you can
add multiple child components if needed while only refreshing the layout
once. For example:var tb = new Ext.Toolbar();
tb.render(document.body);  // toolbar is rendered
tb.add({text:'Button 1'}); // add multiple items (defaultType for Toolbar is 'button')
tb.add({text:'Button 2'});
tb.doLayout();             // refresh the layout
Warning: Containers directly managed by the BorderLayout layout manager
may not be removed or added.  See the Notes for BorderLayout
for more details.
</description></method><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addElement" scope="instance"><description>Adds an Ext.Element object to the menu</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addItem" scope="instance"><description>Adds an existing object based on Ext.menu.BaseItem to the menu</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="addMenuItem" scope="instance"><description>Creates a new Ext.menu.Item based an the supplied config object and adds it to the menu</description></method><method name="addSeparator" scope="instance"><description>Adds a separator bar to the menu</description></method><method name="addText" scope="instance"><description>Creates a new Ext.menu.TextItem with the supplied text and adds it to the menu</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cascade" scope="instance"><description>Cascades down the component/container heirarchy from this component (called first), calling the specified function with
each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the cascade is stopped on that branch.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="doLayout" scope="instance"><description>Force this container's layout to be recalculated. A call to this function is required after adding a new component
to an already rendered container, or possibly after changing sizing/position properties of child components.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="find" scope="instance"><description>Find a component under this container at any level by property</description></method><method name="findBy" scope="instance"><description>Find a component under this container at any level by a custom function. If the passed function returns
true, the component will be included in the results. The passed function is called with the arguments (component, this container).</description></method><method name="findById" scope="instance"><description>Find a component under this container at any level by id</description></method><method name="findByType" scope="instance"><description>Find a component under this container at any level by xtype or class</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="get" scope="instance"><description>Get a component contained by this container (alias for items.get(key))</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getComponent" scope="instance"><description>Examines this container's items property
and gets a direct child component of this container.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getLayout" scope="instance"><description>Returns the layout currently in use by the container.  If the container does not currently have a layout
set, a default Ext.layout.ContainerLayout will be created and set as the container's layout.</description></method><method name="getLayoutTarget" scope="instance"><description>Returns the Element to be used to contain the child Components of this Container.
An implementation is provided which returns the Container's Element, but
if there is a more complex structure to a Container, this may be overridden to return
the element into which the layout renders child Components.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hides this menu and optionally all parent menus</description></method><method name="insert" scope="instance"><description>Inserts a Component into this Container at a specified index. Fires the
beforeadd event before inserting, then fires the add event after the
Component has been inserted.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="remove" scope="instance"><description>Removes a component from this container.  Fires the beforeremove event before removing, then fires
the remove event after the component has been removed.</description></method><method name="removeAll" scope="instance"><description>Removes all components from this container.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>If floating=true, shows this menu relative to
another element using showat, otherwise uses Ext.Component.show.</description></method><method name="showAt" scope="instance"><description>Displays this menu at a specific xy position and fires the 'show' event if a
handler for the 'beforeshow' event does not return false cancelling the operation.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method></methods></class><class superclass="Ext.layout.ContainerLayout" type="Ext.layout.MenuLayout"><description>Layout manager used by Ext.menu.Menu. Generally this class should not need to be used directly.</description><constructors/><properties/><methods><method name="parseMargins" scope="instance"><description>Parses a number or string representing margin sizes into an object. Supports CSS-style margin declarations
(e.g. 10, &quot;10&quot;, &quot;10 10&quot;, &quot;10 10 10&quot; and &quot;10 10 10 10&quot; are all valid options and would return the same result)</description></method></methods></class><class superclass="Ext.grid.Column" type="Ext.grid.DateColumn"><description>A Column definition class which renders a passed date according to the default locale, or a configured
format. See the xtype config option of Ext.grid.Column
for more details.</description><constructors/><properties/><methods><method name="getCellEditor" scope="instance"><description>Returns the editor defined for this column that was created to wrap the Field
used to edit the cell.</description></method><method name="setEditor" scope="instance"><description>Sets a new editor for this column.</description></method></methods></class><class superclass="Ext.grid.GridPanel" type="Ext.grid.PivotGrid"><description>The PivotGrid component enables rapid summarization of large data sets. It provides a way to reduce a large set of
data down into a format where trends and insights become more apparent. A classic example is in sales data; a company
will often have a record of all sales it makes for a given period - this will often encompass thousands of rows of
data. The PivotGrid allows you to see how well each salesperson performed, which cities generate the most revenue, 
how products perform between cities and so on.
A PivotGrid is composed of two axes (left and top), one measure and one aggregation
function. Each axis can contain one or more dimension, which are ordered into a hierarchy. Dimensions on the 
left axis can also specify a width. Each dimension in each axis can specify its sort ordering, defaulting to &quot;ASC&quot;, 
and must specify one of the fields in the Record used by the PivotGrid's 
Store.
// This is the record representing a single sale
var SaleRecord = Ext.data.Record.create([
    {name: 'person',   type: 'string'},
    {name: 'product',  type: 'string'},
    {name: 'city',     type: 'string'},
    {name: 'state',    type: 'string'},
    {name: 'year',     type: 'int'},
    {name: 'value',    type: 'int'}
]);

// A simple store that loads SaleRecord data from a url
var myStore = new Ext.data.Store({
    url: 'data.json',
    autoLoad: true,
    reader: new Ext.data.JsonReader({
        root: 'rows',
        idProperty: 'id'
    }, SaleRecord)
});

// Create the PivotGrid itself, referencing the store
var pivot = new Ext.grid.PivotGrid({
    store     : myStore,
    aggregator: 'sum',
    measure   : 'value',

    leftAxis: [
        {
            width: 60,
            dataIndex: 'product'
        },
        {
            width: 120,
            dataIndex: 'person',
            direction: 'DESC'
        }
    ],

    topAxis: [
        {
            dataIndex: 'year'
        }
    ]
});
The specified measure is the field from SaleRecord that is extracted from each combination
of product and person (on the left axis) and year on the top axis. There may be several SaleRecords in the 
data set that share this combination, so an array of measure fields is produced. This array is then 
aggregated using the aggregator function.
The default aggregator function is sum, which simply adds up all of the extracted measure values. Other
built-in aggregator functions are count, avg, min and max. In addition, you can specify your own function.
In this example we show the code used to sum the measures, but you can return any value you like. See
aggregator for more details.
new Ext.grid.PivotGrid({
    aggregator: function(records, measure) {
        var length = records.length,
            total  = 0,
            i;

        for (i = 0; i return total;
    },
    
    renderer: function(value) {
        return Math.round(value);
    },
    
    //your normal config here
});
Renderers
PivotGrid optionally accepts a renderer function which can modify the data in each cell before it
is rendered. The renderer is passed the value that would usually be placed in the cell and is expected to return
the new value. For example let's imagine we had height data expressed as a decimal - here's how we might use a
renderer to display the data in feet and inches notation:
new Ext.grid.PivotGrid({
    //in each case the value is a decimal number of feet
    renderer  : function(value) {
        var feet   = Math.floor(value),
            inches = Math.round((value - feet) * 12);

        return String.format(&quot;{0}' {1}\&quot;&quot;, feet, inches);
    },
    //normal config here
});
Reconfiguring
All aspects PivotGrid's configuration can be updated at runtime. It is easy to change the measure, 
aggregation function, left and top axes and refresh the grid.
In this case we reconfigure the PivotGrid to have city and year as the top axis dimensions, rendering the average sale
value into the cells:
//the left axis can also be changed
pivot.topAxis.setDimensions([
    {dataIndex: 'city', direction: 'DESC'},
    {dataIndex: 'year', direction: 'ASC'}
]);

pivot.setMeasure('value');
pivot.setAggregator('avg');

pivot.view.refresh(true);
See the PivotAxis documentation for further detail on reconfiguring axes.</description><constructors/><properties/><methods><method name="addButton" scope="instance"><description>Adds a button to this panel.  Note that this method must be called prior to rendering.  The preferred
approach is to add buttons via the buttons config.</description></method><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="collapse" scope="instance"><description>Collapses the panel body so that it becomes hidden.  Fires the beforecollapse event which will
cancel the collapse action if it returns false.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="expand" scope="instance"><description>Expands the panel body so that it becomes visible.  Fires the beforeexpand event which will
cancel the expand action if it returns false.</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="get" scope="instance"><description>Get a component contained by this container (alias for items.get(key))</description></method><method name="getAggregator" scope="instance"><description>Returns the function currently used to aggregate the records in each Pivot cell</description></method><method name="getBottomToolbar" scope="instance"><description>Returns the toolbar from the bottom (bbar) section of the panel.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getColumnModel" scope="instance"><description>Returns the grid's ColumnModel.</description></method><method name="getDragDropText" scope="instance"><description>Called to get grid's drag proxy text, by default returns this.ddText.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getFooterToolbar" scope="instance"><description>Returns the toolbar from the footer (fbar) section of the panel.</description></method><method name="getFrameHeight" scope="instance"><description>Returns the height in pixels of the framing elements of this panel (including any top and bottom bars and
header and footer elements, but not including the body height).  To retrieve the body height see getInnerHeight.</description></method><method name="getFrameWidth" scope="instance"><description>Returns the width in pixels of the framing elements of this panel (not including the body width).  To
retrieve the body width see getInnerWidth.</description></method><method name="getGridEl" scope="instance"><description>Returns the grid's underlying element.</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getInnerHeight" scope="instance"><description>Returns the height in pixels of the body element (not including the height of any framing elements).
For the frame height see getFrameHeight.</description></method><method name="getInnerWidth" scope="instance"><description>Returns the width in pixels of the body element (not including the width of any framing elements).
For the frame width see getFrameWidth.</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getLayoutTarget" scope="instance"><description>Returns the Element to be used to contain the child Components of this Container.
An implementation is provided which returns the Container's Element, but
if there is a more complex structure to a Container, this may be overridden to return
the element into which the layout renders child Components.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSelectionModel" scope="instance"><description>Returns the grid's selection model configured by the selModel
configuration option. If no selection model was configured, this will create
and return a RowSelectionModel.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getStore" scope="instance"><description>Returns the grid's data store.</description></method><method name="getTool" scope="instance"><description>Retrieve a tool by id.</description></method><method name="getTopToolbar" scope="instance"><description>Returns the toolbar from the top (tbar) section of the panel.</description></method><method name="getView" scope="instance"><description>Returns the grid's GridView object.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="reconfigure" scope="instance"><description>Reconfigures the grid to use a different Store and Column Model
and fires the 'reconfigure' event. The View will be bound to the new
objects and refreshed.
Be aware that upon reconfiguring a GridPanel, certain existing settings may become
invalidated. For example the configured autoExpandColumn may no longer exist in the
new ColumnModel. Also, an existing PagingToolbar will still be bound
to the old Store, and will need rebinding. Any plugins might also need reconfiguring
with the new data.</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeAll" scope="instance"><description>Removes all components from this container.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setAggregator" scope="instance"><description>Sets the function to use when aggregating data for each cell.</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setIconClass" scope="instance"><description>Sets the CSS class that provides the icon image for this panel.  This method will replace any existing
icon class if one has already been set and fire the iconchange event after completion.</description></method><method name="setLeftAxis" scope="instance"><description>Sets the left axis of this pivot grid. Optionally refreshes the grid afterwards.</description></method><method name="setMeasure" scope="instance"><description>Sets the field name to use as the Measure in this Pivot Grid</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setTitle" scope="instance"><description>Sets the title text for the panel and optionally the icon class.
In order to be able to set the title, a header element must have been created
for the Panel. This is triggered either by configuring the Panel with a non-blank title,
or configuring it with header: true.</description></method><method name="setTopAxis" scope="instance"><description>Sets the top axis of this pivot grid. Optionally refreshes the grid afterwards.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="toggleCollapse" scope="instance"><description>Shortcut for performing an expand or collapse based on the current state of the panel.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method></methods></class><class superclass="Ext.data.Store" type="Ext.data.DirectStore"><description>Small helper class to create an Ext.data.Store configured with an
Ext.data.DirectProxy and Ext.data.JsonReader to make interacting
with an Ext.Direct Server-side Provider easier.
To create a different proxy/reader combination create a basic Ext.data.Store
configured as needed.
*Note: Although they are not listed, this class inherits all of the config options of:

Store


JsonReader

root
idProperty
totalProperty

DirectProxy

directFn
paramOrder
paramsAsHash

</description><constructors/><properties/><methods><method name="add" scope="instance"><description>Add Records to the Store and fires the add event.  To add Records
to the store from a remote source use load({add:true}).
See also recordType and insert.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="addSorted" scope="instance"><description>(Local sort only) Inserts the passed Record into the Store at the index where it
should go based on the current sort information.</description></method><method name="clearFilter" scope="instance"><description>Revert to a view of the Record cache with no filtering applied.</description></method><method name="collect" scope="instance"><description>Collects unique values for a particular dataIndex from this store.</description></method><method name="commitChanges" scope="instance"><description>Commit all Records with outstanding changes. To handle updates for changes,
subscribe to the Store's update event, and perform updating when the third parameter is
Ext.data.Record.COMMIT.</description></method><method name="destroy" scope="instance"><description>Destroys the store.</description></method><method name="each" scope="instance"><description>Calls the specified function for each of the Records in the cache.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="filter" scope="instance"><description>Filter the records by a specified property. Alternatively, pass an array of filter
options to filter by more than one property.
Single filter example:
store.filter('name', 'Ed', true, true); //finds all records containing the substring 'Ed'
Multiple filter example:
store.filter([
{
property     : 'name',
value        : 'Ed',
anyMatch     : true, //optional, defaults to true
caseSensitive: true  //optional, defaults to true
},
//filter functions can also be passed
{
fn   : function(record) {
return record.get('age') == 24
},
scope: this
}
]);</description></method><method name="filterBy" scope="instance"><description>Filter by a function. The specified function will be called for each
Record in this Store. If the function returns true the Record is included,
otherwise it is filtered out.</description></method><method name="find" scope="instance"><description>Finds the index of the first matching Record in this store by a specific field value.</description></method><method name="findBy" scope="instance"><description>Find the index of the first matching Record in this Store by a function.
If the function returns true it is considered a match.</description></method><method name="findExact" scope="instance"><description>Finds the index of the first matching Record in this store by a specific field value.</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="getAt" scope="instance"><description>Get the Record at the specified index.</description></method><method name="getById" scope="instance"><description>Get the Record with the specified id.</description></method><method name="getCount" scope="instance"><description>Gets the number of cached records.
If using paging, this may not be the total size of the dataset. If the data object
used by the Reader contains the dataset size, then the getTotalCount function returns
the dataset size.  Note: see the Important note in load.</description></method><method name="getModifiedRecords" scope="instance"><description>Gets all records modified since the last commit.  Modified records are
persisted across load operations (e.g., during paging). Note: deleted records are not
included.  See also pruneModifiedRecords and
Ext.data.RecordmarkDirty..</description></method><method name="getRange" scope="instance"><description>Returns a range of Records between specified indices.</description></method><method name="getSortState" scope="instance"><description>Returns an object describing the current sort state of this Store.</description></method><method name="getTotalCount" scope="instance"><description>Gets the total number of records in the dataset as returned by the server.
If using paging, for this to be accurate, the data object used by the Reader
must contain the dataset size. For remote data sources, the value for this property
(totalProperty for JsonReader,
totalRecords for XmlReader) shall be returned by a query on the server.
Note: see the Important note in load.</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="indexOf" scope="instance"><description>Get the index within the cache of the passed Record.</description></method><method name="indexOfId" scope="instance"><description>Get the index within the cache of the Record with the passed id.</description></method><method name="insert" scope="instance"><description>Inserts Records into the Store at the given index and fires the add event.
See also add and addSorted.</description></method><method name="isFiltered" scope="instance"><description>Returns true if this store is currently filtered</description></method><method name="load" scope="instance"><description>Loads the Record cache from the configured proxy using the configured reader.
Notes:
Important: loading is asynchronous! This call will return before the new data has been
loaded. To perform any post-processing where information from the load call is required, specify
the callback function to be called, or use a a 'load' event handler.
If using remote paging, the first load call must specify the start and limit
properties in the options.params property to establish the initial position within the
dataset, and the number of Records to cache on each read from the Proxy.
If using remote sorting, the configured sortInfo
will be automatically included with the posted parameters according to the specified
paramNames.
</description></method><method name="loadData" scope="instance"><description>Loads data from a passed data block and fires the load event. A Reader
which understands the format of the data must have been configured in the constructor.</description></method><method name="multiSort" scope="instance"><description>Sorts the contents of this store by multiple field/direction sorters. This is called internally by sort
and would not usually be called manually.
Multi sorting only currently applies to local datasets - multiple sort data is not currently sent to a proxy
if remoteSort is used.</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="query" scope="instance"><description>Query the records by a specified property.</description></method><method name="queryBy" scope="instance"><description>Query the cached records in this Store using a filtering function. The specified function
will be called with each record in this Store. If the function returns true the record is
included in the results.</description></method><method name="rejectChanges" scope="instance"><description>Reject outstanding changes on all modified records.</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="reload" scope="instance"><description>Reloads the Record cache from the configured Proxy using the configured
Reader and the options from the last load operation
performed.
Note: see the Important note in load.</description></method><method name="remove" scope="instance"><description>Remove Records from the Store and fires the remove event.</description></method><method name="removeAll" scope="instance"><description>Remove all Records from the Store and fires the clear event.</description></method><method name="removeAt" scope="instance"><description>Remove a Record from the Store at the specified index. Fires the remove event.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="save" scope="instance"><description>Saves all pending changes to the store.  If the commensurate Ext.data.Api.actions action is not configured, then
the configured url will be used.

change            url
---------------   --------------------
removed records   Ext.data.Api.actions.destroy
phantom records   Ext.data.Api.actions.create
modified records  Ext.data.Api.actions.update
</description></method><method name="setBaseParam" scope="instance"><description>Set the value for a property name in this store's baseParams.  Usage:myStore.setBaseParam('foo', {bar:3});</description></method><method name="setDefaultSort" scope="instance"><description>Sets the default sort column and order to be used by the next load operation.</description></method><method name="singleSort" scope="instance"><description>Sorts the store contents by a single field and direction. This is called internally by sort and would
not usually be called manually</description></method><method name="sort" scope="instance"><description>Sort the Records.
If remote sorting is used, the sort is performed on the server, and the cache is reloaded. If local
sorting is used, the cache is sorted internally. See also remoteSort and paramNames.
This function accepts two call signatures - pass in a field name as the first argument to sort on a single
field, or pass in an array of sort configuration objects to sort by multiple fields.
Single sort example:
store.sort('name', 'ASC');
Multi sort example:
store.sort([
{
field    : 'name',
direction: 'ASC'
},
{
field    : 'salary',
direction: 'DESC'
}
], 'ASC');
In this second form, the sort configs are applied in order, with later sorters sorting within earlier sorters' results.
For example, if two records with the same name are present they will also be sorted by salary if given the sort configs
above. Any number of sort configs can be added.</description></method><method name="sum" scope="instance"><description>Sums the value of property for each record between start
and end and returns the result.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method></methods></class><class superclass="Object" type="Ext.tree.TreeSorter"><description>Provides sorting of nodes in a Ext.tree.TreePanel.  The TreeSorter automatically monitors events on the
associated TreePanel that might affect the tree's sort order (beforechildrenrendered, append, insert and textchange).
Example usage:
new Ext.tree.TreeSorter(myTree, {
    folderSort: true,
    dir: &quot;desc&quot;,
    sortType: function(node) {
        // sort by a custom, typed attribute:
        return parseInt(node.id, 10);
    }
});</description><constructors/><properties/><methods/></class><class superclass="Ext.chart.Axis" type="Ext.chart.CategoryAxis"><description>A type of axis that displays items in categories.</description><constructors/><properties/><methods/></class><class superclass="Ext.form.ComboBox" type="Ext.form.TimeField"><description>Provides a time input field with a time dropdown and automatic time validation.  Example usage:
new Ext.form.TimeField({
    minValue: '9:00 AM',
    maxValue: '6:00 PM',
    increment: 30
});</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="clearInvalid" scope="instance"><description>Clear any invalid styles/messages for this field</description></method><method name="clearValue" scope="instance"><description>Clears any text/value currently set in the field</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="collapse" scope="instance"><description>Hides the dropdown list if it is currently expanded. Fires the collapse event on completion.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="doQuery" scope="instance"><description>Execute a query to filter the dropdown list.  Fires the beforequery event prior to performing the
query allowing the query action to be canceled if needed.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="expand" scope="instance"><description>Expands the dropdown list if it is currently hidden. Fires the expand event on completion.</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getActiveError" scope="instance"><description>Gets the active error message for this field.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getErrors" scope="instance"><description>Validates a value according to the field's validation rules and returns an array of errors
for any failing validations. Validation rules are processed in the following order:

1. Field specific validator

A validator offers a way to customize and reuse a validation specification.
If a field is configured with a validator
function, it will be passed the current field value.  The validator
function is expected to return either:

Boolean true if the value is valid (validation continues).
a String to represent the invalid message if invalid (validation halts).


2. Basic Validation

If the validator has not halted validation,
basic validation proceeds as follows:

allowBlank : (Invalid message =
emptyText)
Depending on the configuration of allowBlank, a
blank field will cause validation to halt at this step and return
Boolean true or false accordingly.  

minLength : (Invalid message =
minLengthText)
If the passed value does not satisfy the minLength
specified, validation halts.

maxLength : (Invalid message =
maxLengthText)
If the passed value does not satisfy the maxLength
specified, validation halts.



3. Preconfigured Validation Types (VTypes)

If none of the prior validation steps halts validation, a field
configured with a vtype will utilize the
corresponding VTypes validation function.
If invalid, either the field's vtypeText or
the VTypes vtype Text property will be used for the invalid message.
Keystrokes on the field will be filtered according to the VTypes
vtype Mask property.

4. Field specific regex test

If none of the prior validation steps halts validation, a field's
configured regex test will be processed.
The invalid message for this test is configured with
regexText.
</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getListParent" scope="instance"><description>Returns the element used to house this ComboBox's pop-up list. Defaults to the document body.
A custom implementation may be provided as a configuration option if the floating list needs to be rendered
to a different Element. An example might be rendering the list inside a Menu so that clicking
the list does not hide the Menu:var store = new Ext.data.ArrayStore({
    autoDestroy: true,
    fields: ['initials', 'fullname'],
    data : [
        ['FF', 'Fred Flintstone'],
        ['BR', 'Barney Rubble']
    ]
});

var combo = new Ext.form.ComboBox({
    store: store,
    displayField: 'fullname',
    emptyText: 'Select a name...',
    forceSelection: true,
    getListParent: function() {
        return this.el.up('.x-menu');
    },
    iconCls: 'no-icon', //use iconCls if placing within menu to shift to right side of menu
    mode: 'local',
    selectOnFocus: true,
    triggerAction: 'all',
    typeAhead: true,
    width: 135
});

var menu = new Ext.menu.Menu({
    id: 'mainMenu',
    items: [
        combo // A Field in a Menu
    ]
});</description></method><method name="getName" scope="instance"><description>Returns the name or hiddenName
attribute of the field if available.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getRawValue" scope="instance"><description>Returns the raw data value which may or may not be a valid, defined value.  To return a normalized value see getValue.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getStore" scope="instance"><description>Returns the store associated with this combo.</description></method><method name="getValue" scope="instance"><description>Returns the currently selected field value or empty string if no value is set.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isDirty" scope="instance"><description>Returns true if the value of this Field has been changed from its original value.
Will return false if the field is disabled or has not been rendered yet.
Note that if the owning form was configured with
Ext.form.BasicForm.trackResetOnLoad
then the original value is updated when the values are loaded by
Ext.form.BasicForm.setValues.</description></method><method name="isExpanded" scope="instance"><description>Returns true if the dropdown list is expanded, else false.</description></method><method name="isValid" scope="instance"><description>Returns whether or not the field value is currently valid by
validating the processed value
of the field. Note: disabled fields are ignored.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="markInvalid" scope="instance"><description>Display an error message associated with this field, using msgTarget to determine how to
display the message and applying invalidClass to the field's UI element.
Note: this method does not cause the Field's validate method to return false
if the value does pass validation. So simply marking a Field as invalid will not prevent
submission of forms submitted with the Ext.form.Action.Submit.clientValidation option set.
invalid.</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="processValue" scope="instance"><description>This method should only be overridden if necessary to prepare raw values
for validation (see validate and isValid).  This method
is expected to return the processed value for the field which will
be used for validation (see validateValue method).</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="reset" scope="instance"><description>Resets the current field value to the originally-loaded value and clears any validation messages.
Also adds emptyText and emptyClass if the
original value was blank.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="select" scope="instance"><description>Select an item in the dropdown list by its numeric index in the list. This function does NOT cause the select event to fire.
The store must be loaded and the list expanded for this function to work, otherwise use setValue.</description></method><method name="selectByValue" scope="instance"><description>Select an item in the dropdown list by its data value. This function does NOT cause the select event to fire.
The store must be loaded and the list expanded for this function to work, otherwise use setValue.</description></method><method name="selectText" scope="instance"><description>Selects text in this field</description></method><method name="setActiveError" scope="instance"><description>Sets the current activeError to the given string. Fires the 'invalid' event.
This does not set up the error icon, only sets the message and fires the event. To show the error icon,
use markInvalid instead, which calls this method internally</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setEditable" scope="instance"><description>Allow or prevent the user from directly editing the field text.  If false is passed,
the user will only be able to modify the field using the trigger.  Will also add
a click event to the text field which will call the trigger. This method
is the runtime equivalent of setting the editable config option at config time.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setHideTrigger" scope="instance"><description>Changes the hidden status of the trigger.</description></method><method name="setMaxValue" scope="instance"><description>Replaces any existing maxValue with the new time and refreshes the store.</description></method><method name="setMinValue" scope="instance"><description>Replaces any existing minValue with the new time and refreshes the store.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setRawValue" scope="instance"><description>Sets the underlying DOM field's value directly, bypassing validation.  To set the value with validation see setValue.</description></method><method name="setReadOnly" scope="instance"><description>Setting this to true will supersede settings editable and hideTrigger.
Setting this to false will defer back to editable and hideTrigger. This method
is the runtime equivalent of setting the readOnly config option at config time.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setValue" scope="instance"><description>Sets the specified value into the field.  If the value finds a match, the corresponding record text
will be displayed in the field.  If the value does not match the data value of an existing item,
and the valueNotFoundText config option is defined, it will be displayed as the default field text.
Otherwise the field will be blank (although the value will still be set).</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="unsetActiveError" scope="instance"><description>Clears the activeError and fires the 'valid' event. This is called internally by clearInvalid and would not
usually need to be called manually</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method><method name="validate" scope="instance"><description>Validates the field value</description></method><method name="validateValue" scope="instance"><description>Uses getErrors to build an array of validation errors. If any errors are found, markInvalid is called
with the first and false is returned, otherwise true is returned. Previously, subclasses were invited
to provide an implementation of this to process validations - from 3.2 onwards getErrors should be
overridden instead.</description></method></methods></class><class superclass="Object" type="Ext.Action"><description>An Action is a piece of reusable functionality that can be abstracted out of any particular component so that it
can be usefully shared among multiple components.  Actions let you share handlers, configuration options and UI
updates across any components that support the Action interface (primarily Ext.Toolbar, Ext.Button
and Ext.menu.Menu components).
Aside from supporting the config object interface, any component that needs to use Actions must also support
the following method list, as these will be called as needed by the Action class: setText(string), setIconCls(string),
setDisabled(boolean), setVisible(boolean) and setHandler(function).
Example usage:
// Define the shared action.  Each component below will have the same
// display text and icon, and will display the same message on click.
var action = new Ext.Action({
    text: 'Do something',
    handler: function(){
        Ext.Msg.alert('Click', 'You did something.');
    },
    iconCls: 'do-something',
    itemId: 'myAction'
});

var panel = new Ext.Panel({
    title: 'Actions',
    width: 500,
    height: 300,
    tbar: [
        // Add the action directly to a toolbar as a menu button
        action,
        {
            text: 'Action Menu',
            // Add the action to a menu as a text item
            menu: [action]
        }
    ],
    items: [
        // Add the action to the panel body as a standard button
        new Ext.Button(action)
    ],
    renderTo: Ext.getBody()
});

// Change the text for all components using the action
action.setText('Something else');

// Reference an action through a container using the itemId
var btn = panel.getComponent('myAction');
var aRef = btn.baseAction;
aRef.setText('New text');</description><constructors/><properties/><methods><method name="disable" scope="instance"><description>Disables all components using this action.</description></method><method name="each" scope="instance"><description>Executes the specified function once for each Component currently tied to this action.  The function passed
in should accept a single argument that will be an object that supports the basic Action config/method interface.</description></method><method name="enable" scope="instance"><description>Enables all components using this action.</description></method><method name="execute" scope="instance"><description>Executes this action manually using the handler function specified in the original config object
or the handler function set with setHandler.  Any arguments passed to this
function will be passed on to the handler function.</description></method><method name="getIconClass" scope="instance"><description>Gets the icon CSS class currently used by all components using this action.</description></method><method name="getText" scope="instance"><description>Gets the text currently displayed by all components using this action.</description></method><method name="hide" scope="instance"><description>Hides all components using this action.</description></method><method name="isDisabled" scope="instance"><description>Returns true if the components using this action are currently disabled, else returns false.</description></method><method name="isHidden" scope="instance"><description>Returns true if the components using this action are currently hidden, else returns false.</description></method><method name="setDisabled" scope="instance"><description>Sets the disabled state of all components using this action.  Shortcut method
for enable and disable.</description></method><method name="setHandler" scope="instance"><description>Sets the function that will be called by each Component using this action when its primary event is triggered.</description></method><method name="setHidden" scope="instance"><description>Sets the hidden state of all components using this action.  Shortcut method
for hide and show.</description></method><method name="setIconClass" scope="instance"><description>Sets the icon CSS class for all components using this action.  The class should supply
a background image that will be used as the icon image.</description></method><method name="setText" scope="instance"><description>Sets the text to be displayed by all components using this action.</description></method><method name="show" scope="instance"><description>Shows all components using this action.</description></method></methods></class><class superclass="Ext.layout.FitLayout" type="Ext.layout.CardLayout"><description>This layout manages multiple child Components, each fitted to the Container, where only a single child Component can be
visible at any given time.  This layout style is most commonly used for wizards, tab implementations, etc.
This class is intended to be extended or created via the layout:'card' Ext.Container.layout config,
and should generally not need to be created directly via the new keyword.
The CardLayout's focal method is setActiveItem.  Since only one panel is displayed at a time,
the only way to move from one Component to the next is by calling setActiveItem, passing the id or index of
the next panel to display.  The layout itself does not provide a user interface for handling this navigation,
so that functionality must be provided by the developer.
In the following example, a simplistic wizard setup is demonstrated.  A button bar is added
to the footer of the containing panel to provide navigation buttons.  The buttons will be handled by a
common navigation routine -- for this example, the implementation of that routine has been ommitted since
it can be any type of custom logic.  Note that other uses of a CardLayout (like a tab control) would require a
completely different implementation.  For serious implementations, a better approach would be to extend
CardLayout to provide the custom functionality needed.  Example usage:
var navHandler = function(direction){
    // This routine could contain business logic required to manage the navigation steps.
    // It would call setActiveItem as needed, manage navigation button state, handle any
    // branching logic that might be required, handle alternate actions like cancellation
    // or finalization, etc.  A complete wizard implementation could get pretty
    // sophisticated depending on the complexity required, and should probably be
    // done as a subclass of CardLayout in a real-world implementation.
};

var card = new Ext.Panel({
    title: 'Example Wizard',
    layout:'card',
    activeItem: 0, // make sure the active item is set on the container config!
    bodyStyle: 'padding:15px',
    defaults: {
        // applied to each contained panel
        border:false
    },
    // just an example of one possible navigation scheme, using buttons
    bbar: [
        {
            id: 'move-prev',
            text: 'Back',
            handler: navHandler.createDelegate(this, [-1]),
            disabled: true
        },
        '-&gt;', // greedy spacer so that the buttons are aligned to each side
        {
            id: 'move-next',
            text: 'Next',
            handler: navHandler.createDelegate(this, [1])
        }
    ],
    // the panels (or &quot;cards&quot;) within the layout
    items: [{
        id: 'card-0',
        html: '&lt;h1&gt;Welcome to the Wizard!&lt;/h1&gt;&lt;p&gt;Step 1 of 3&lt;/p&gt;'
    },{
        id: 'card-1',
        html: '&lt;p&gt;Step 2 of 3&lt;/p&gt;'
    },{
        id: 'card-2',
        html: '&lt;h1&gt;Congratulations!&lt;/h1&gt;&lt;p&gt;Step 3 of 3 - Complete&lt;/p&gt;'
    }]
});</description><constructors/><properties/><methods><method name="parseMargins" scope="instance"><description>Parses a number or string representing margin sizes into an object. Supports CSS-style margin declarations
(e.g. 10, &quot;10&quot;, &quot;10 10&quot;, &quot;10 10 10&quot; and &quot;10 10 10 10&quot; are all valid options and would return the same result)</description></method><method name="setActiveItem" scope="instance"><description>Sets the active (visible) item in the layout.</description></method></methods></class><class superclass="Object" type="Ext.layout.AutoLayout"><description>The AutoLayout is the default layout manager delegated by Ext.Container to
render any child Components when no layout is configured into
a Container..  AutoLayout provides only a passthrough of any layout calls
to any child containers.</description><constructors/><properties/><methods/></class><class superclass="Ext.grid.GridView" type="Ext.grid.PivotGridView"><description>Specialised GridView for rendering Pivot Grid components. Config can be passed to the PivotGridView via the PivotGrid constructor's
viewConfig option:
new Ext.grid.PivotGrid({
    viewConfig: {
        title: 'My Pivot Grid',
        getCellCls: function(value) {
            return value &gt; 10 'red' : 'green';
        }
    }
});
Currently title and getCellCls are the only configuration options accepted by PivotGridView. All other 
interaction is performed via the PivotGrid class.</description><constructors/><properties/><methods><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findCellIndex" scope="instance"><description>Return the index of the grid column which contains the passed HTMLElement.
See also findRowIndex</description></method><method name="findRow" scope="instance"><description>Return the HtmlElement representing the grid row which contains the passed element.</description></method><method name="findRowBody" scope="instance"><description>Return the HtmlElement representing the grid row body which contains the passed element.</description></method><method name="findRowIndex" scope="instance"><description>Return the index of the grid row which contains the passed HTMLElement.
See also findCellIndex</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focusCell" scope="instance"><description>Focuses the specified cell.</description></method><method name="focusRow" scope="instance"><description>Focuses the specified row.</description></method><method name="getCell" scope="instance"><description>Returns the grid's &lt;td&gt; HtmlElement at the specified coordinates.</description></method><method name="getColumnHeaders" scope="instance"><description>Returns the headers to be rendered at the top of the grid. Should be a 2-dimensional array, where each item specifies the number
of columns it groups (column in this case refers to normal grid columns). In the example below we have 5 city groups, which are
each part of a continent supergroup. The colspan for each city group refers to the number of normal grid columns that group spans,
so in this case the grid would be expected to have a total of 12 columns:
[
    {
        items: [
            {header: 'England',   colspan: 5},
            {header: 'USA',       colspan: 3}
        ]
    },
    {
        items: [
            {header: 'London',    colspan: 2},
            {header: 'Cambridge', colspan: 3},
            {header: 'Palo Alto', colspan: 3}
        ]
    }
]
In the example above we have cities nested under countries. The nesting could be deeper if desired - e.g. Continent -&gt; Country -&gt;
State -&gt; City, or any other structure. The only constaint is that the same depth must be used throughout the structure.</description></method><method name="getGridInnerWidth" scope="instance"><description>Returns the total internal width available to the grid, taking the scrollbar into account</description></method><method name="getHeaderCell" scope="instance"><description>Return the &lt;td&gt; HtmlElement which represents the Grid's header cell for the specified column index.</description></method><method name="getRow" scope="instance"><description>Return the &lt;div&gt; HtmlElement which represents a Grid row for the specified index.</description></method><method name="getRowClass" scope="instance"><description>Override this function to apply custom CSS classes to rows during rendering.  You can also supply custom
parameters to the row template for the current row to customize how it is rendered using the rowParams
parameter.  This function should return the CSS class name (or empty string '' for none) that will be added
to the row's wrapping div.  To apply multiple class names, simply return them space-delimited within the string
(e.g., 'my-class another-class'). Example usage:
    viewConfig: {
    forceFit: true,
    showPreview: true, // custom property
    enableRowBody: true, // required to create a second, full-width row to show expanded Record data
    getRowClass: function(record, rowIndex, rp, ds){ // rp = rowParams
        if(this.showPreview){
            rp.body = '&lt;p&gt;'+record.data.excerpt+'&lt;/p&gt;';
            return 'x-grid3-row-expanded';
        }
        return 'x-grid3-row-collapsed';
    }
},</description></method><method name="getRowHeaders" scope="instance"><description>Returns the headers to be rendered on the left of the grid. Should be a 2-dimensional array, where each item specifies the number
of rows it groups. In the example below we have 5 city groups, which are each part of a continent supergroup. The rowspan for each 
city group refers to the number of normal grid columns that group spans, so in this case the grid would be expected to have a 
total of 12 rows:
[
    {
        width: 90,
        items: [
            {header: 'England',   rowspan: 5},
            {header: 'USA',       rowspan: 3}
        ]
    },
    {
        width: 50,
        items: [
            {header: 'London',    rowspan: 2},
            {header: 'Cambridge', rowspan: 3},
            {header: 'Palo Alto', rowspan: 3}
        ]
    }
]
In the example above we have cities nested under countries. The nesting could be deeper if desired - e.g. Continent -&gt; Country -&gt;
State -&gt; City, or any other structure. The only constaint is that the same depth must be used throughout the structure.</description></method><method name="getTotalRowHeaderWidth" scope="instance"><description>Returns the total width of all row headers as specified by getRowHeaders</description></method><method name="handleHdMenuClickDefault" scope="instance"><description>Called by handleHdMenuClick if any button except a sort ASC/DESC button was clicked. The default implementation provides
the column hide/show functionality based on the check state of the menu item. A different implementation can be provided
if needed.</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="refresh" scope="instance"><description>Refreshs the grid UI</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="scrollToTop" scope="instance"><description>Scrolls the grid to the top</description></method><method name="setTitle" scope="instance"><description>Sets the title text in the top left segment of the PivotGridView</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method></methods></class><class superclass="Ext.form.CheckboxGroup" type="Ext.form.RadioGroup"><description>A grouping container for Ext.form.Radio controls.</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="clearInvalid" scope="instance"><description>Clear any invalid styles/messages for this field</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getActiveError" scope="instance"><description>Gets the active error message for this field.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getErrors" scope="instance"><description>Runs CheckboxGroup's validations and returns an array of any errors. The only error by default
is if allowBlank is set to true and no items are checked.</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getName" scope="instance"><description>Returns the name or hiddenName
attribute of the field if available.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getValue" scope="instance"><description>Gets the selected Ext.form.Radio in the group, if it exists.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isDirty" scope="instance"><description>Returns true if the value of this Field has been changed from its original value.
Will return false if the field is disabled or has not been rendered yet.
Note that if the owning form was configured with
Ext.form.BasicForm.trackResetOnLoad
then the original value is updated when the values are loaded by
Ext.form.BasicForm.setValues.</description></method><method name="isValid" scope="instance"><description>Returns whether or not the field value is currently valid by
validating the processed value
of the field. Note: disabled fields are ignored.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="markInvalid" scope="instance"><description>Display an error message associated with this field, using msgTarget to determine how to
display the message and applying invalidClass to the field's UI element.
Note: this method does not cause the Field's validate method to return false
if the value does pass validation. So simply marking a Field as invalid will not prevent
submission of forms submitted with the Ext.form.Action.Submit.clientValidation option set.
invalid.</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="onSetValue" scope="instance"><description>Sets the checked radio in the group.</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="processValue" scope="instance"><description>This method should only be overridden if necessary to prepare raw values
for validation (see validate and isValid).  This method
is expected to return the processed value for the field which will
be used for validation (see validateValue method).</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="reset" scope="instance"><description>Resets the current field value to the originally loaded value and clears any validation messages.
See Ext.form.BasicForm.trackResetOnLoad</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setActiveError" scope="instance"><description>Sets the current activeError to the given string. Fires the 'invalid' event.
This does not set up the error icon, only sets the message and fires the event. To show the error icon,
use markInvalid instead, which calls this method internally</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setReadOnly" scope="instance"><description>Sets the read only state of this field.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setValue" scope="instance"><description>Set the value(s) of an item or items
in the group. Examples illustrating how this method may be called:
// call with name and value
myCheckboxGroup.setValue('cb-col-1', true);
// call with an array of boolean values
myCheckboxGroup.setValue([true, false, false]);
// call with an object literal specifying item:value pairs
myCheckboxGroup.setValue({
    'cb-col-2': false,
    'cb-col-3': true
});
// use comma separated string to set items with name to true (checked)
myCheckboxGroup.setValue('cb-col-1,cb-col-3');
See Ext.form.Checkbox.setValue for additional information.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="unsetActiveError" scope="instance"><description>Clears the activeError and fires the 'valid' event. This is called internally by clearInvalid and would not
usually need to be called manually</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method><method name="validate" scope="instance"><description>Validates the field value</description></method><method name="validateValue" scope="instance"><description>Uses getErrors to build an array of validation errors. If any errors are found, markInvalid is called
with the first and false is returned, otherwise true is returned. Previously, subclasses were invited
to provide an implementation of this to process validations - from 3.2 onwards getErrors should be
overridden instead.</description></method></methods></class><class superclass="Object" type="Ext.MessageBox"><description>Utility class for generating different styles of message boxes.  The alias Ext.Msg can also be used.
Note that the MessageBox is asynchronous.  Unlike a regular JavaScript alert (which will halt
browser execution), showing a MessageBox will not cause the code to stop.  For this reason, if you have code
that should only run after some user feedback from the MessageBox, you must use a callback function
(see the function parameter for show for more details).
Example usage:
// Basic alert:
Ext.Msg.alert('Status', 'Changes saved successfully.');

// Prompt for user data and process the result using a callback:
Ext.Msg.prompt('Name', 'Please enter your name:', function(btn, text){
    if (btn == 'ok'){
        // process text value and close...
    }
});

// Show a dialog using config options:
Ext.Msg.show({
   title:'Save Changes?',
   msg: 'You are closing a tab that has unsaved changes. Would you like to save your changes?',
   buttons: Ext.Msg.YESNOCANCEL,
   fn: processResult,
   animEl: 'elId',
   icon: Ext.MessageBox.QUESTION
});</description><constructors/><properties/><methods><method name="alert" scope="instance"><description>Displays a standard read-only message box with an OK button (comparable to the basic JavaScript alert prompt).
If a callback function is passed it will be called after the user clicks the button, and the
id of the button that was clicked will be passed as the only parameter to the callback
(could also be the top-right close button).</description></method><method name="confirm" scope="instance"><description>Displays a confirmation message box with Yes and No buttons (comparable to JavaScript's confirm).
If a callback function is passed it will be called after the user clicks either button,
and the id of the button that was clicked will be passed as the only parameter to the callback
(could also be the top-right close button).</description></method><method name="getDialog" scope="instance"><description>Returns a reference to the underlying Ext.Window element</description></method><method name="hide" scope="instance"><description>Hides the message box if it is displayed</description></method><method name="isVisible" scope="instance"><description>Returns true if the message box is currently displayed</description></method><method name="progress" scope="instance"><description>Displays a message box with a progress bar.  This message box has no buttons and is not closeable by
the user.  You are responsible for updating the progress bar as needed via Ext.MessageBox.updateProgress
and closing the message box when the process is complete.</description></method><method name="prompt" scope="instance"><description>Displays a message box with OK and Cancel buttons prompting the user to enter some text (comparable to JavaScript's prompt).
The prompt can be a single-line or multi-line textbox.  If a callback function is passed it will be called after the user
clicks either button, and the id of the button that was clicked (could also be the top-right
close button) and the text that was entered will be passed as the two parameters to the callback.</description></method><method name="setIcon" scope="instance"><description>Adds the specified icon to the dialog.  By default, the class 'ext-mb-icon' is applied for default
styling, and the class passed in is expected to supply the background image url. Pass in empty string ('')
to clear any existing icon. This method must be called before the MessageBox is shown.
The following built-in icon classes are supported, but you can also pass in a custom class name:

Ext.MessageBox.INFO
Ext.MessageBox.WARNING
Ext.MessageBox.QUESTION
Ext.MessageBox.ERROR
</description></method><method name="show" scope="instance"><description>Displays a new message box, or reinitializes an existing message box, based on the config options
passed in. All display functions (e.g. prompt, alert, etc.) on MessageBox call this function internally,
although those calls are basic shortcuts and do not support all of the config options allowed here.</description></method><method name="updateProgress" scope="instance"><description>Updates a progress-style message box's text and progress bar. Only relevant on message boxes
initiated via Ext.MessageBox.progress or Ext.MessageBox.wait,
or by calling Ext.MessageBox.show with progress: true.</description></method><method name="updateText" scope="instance"><description>Updates the message box body text</description></method><method name="wait" scope="instance"><description>Displays a message box with an infinitely auto-updating progress bar.  This can be used to block user
interaction while waiting for a long-running process to complete that does not have defined intervals.
You are responsible for closing the message box when the process is complete.</description></method></methods></class><class superclass="Ext.Tip" type="Ext.ToolTip"><description>A standard tooltip implementation for providing additional information when hovering over a target element.</description><constructors/><properties/><methods><method name="add" scope="instance"><description>Adds Component(s) to this Container.
Description :

Fires the beforeadd event before adding
The Container's default config values will be applied
accordingly (see defaults for details).
Fires the add event after the component has been added.

Notes :

If the Container is already rendered when add
is called, you may need to call doLayout to refresh the view which causes
any unrendered child Components to be rendered. This is required so that you can
add multiple child components if needed while only refreshing the layout
once. For example:var tb = new Ext.Toolbar();
tb.render(document.body);  // toolbar is rendered
tb.add({text:'Button 1'}); // add multiple items (defaultType for Toolbar is 'button')
tb.add({text:'Button 2'});
tb.doLayout();             // refresh the layout
Warning: Containers directly managed by the BorderLayout layout manager
may not be removed or added.  See the Notes for BorderLayout
for more details.
</description></method><method name="addButton" scope="instance"><description>Adds a button to this panel.  Note that this method must be called prior to rendering.  The preferred
approach is to add buttons via the buttons config.</description></method><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cascade" scope="instance"><description>Cascades down the component/container heirarchy from this component (called first), calling the specified function with
each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the cascade is stopped on that branch.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="collapse" scope="instance"><description>Collapses the panel body so that it becomes hidden.  Fires the beforecollapse event which will
cancel the collapse action if it returns false.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="doLayout" scope="instance"><description>Force this container's layout to be recalculated. A call to this function is required after adding a new component
to an already rendered container, or possibly after changing sizing/position properties of child components.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="expand" scope="instance"><description>Expands the panel body so that it becomes visible.  Fires the beforeexpand event which will
cancel the expand action if it returns false.</description></method><method name="find" scope="instance"><description>Find a component under this container at any level by property</description></method><method name="findBy" scope="instance"><description>Find a component under this container at any level by a custom function. If the passed function returns
true, the component will be included in the results. The passed function is called with the arguments (component, this container).</description></method><method name="findById" scope="instance"><description>Find a component under this container at any level by id</description></method><method name="findByType" scope="instance"><description>Find a component under this container at any level by xtype or class</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="get" scope="instance"><description>Get a component contained by this container (alias for items.get(key))</description></method><method name="getBottomToolbar" scope="instance"><description>Returns the toolbar from the bottom (bbar) section of the panel.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getComponent" scope="instance"><description>Examines this container's items property
and gets a direct child component of this container.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getFooterToolbar" scope="instance"><description>Returns the toolbar from the footer (fbar) section of the panel.</description></method><method name="getFrameHeight" scope="instance"><description>Returns the height in pixels of the framing elements of this panel (including any top and bottom bars and
header and footer elements, but not including the body height).  To retrieve the body height see getInnerHeight.</description></method><method name="getFrameWidth" scope="instance"><description>Returns the width in pixels of the framing elements of this panel (not including the body width).  To
retrieve the body width see getInnerWidth.</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getInnerHeight" scope="instance"><description>Returns the height in pixels of the body element (not including the height of any framing elements).
For the frame height see getFrameHeight.</description></method><method name="getInnerWidth" scope="instance"><description>Returns the width in pixels of the body element (not including the width of any framing elements).
For the frame width see getFrameWidth.</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getLayout" scope="instance"><description>Returns the layout currently in use by the container.  If the container does not currently have a layout
set, a default Ext.layout.ContainerLayout will be created and set as the container's layout.</description></method><method name="getLayoutTarget" scope="instance"><description>Returns the Element to be used to contain the child Components of this Container.
An implementation is provided which returns the Container's Element, but
if there is a more complex structure to a Container, this may be overridden to return
the element into which the layout renders child Components.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getTool" scope="instance"><description>Retrieve a tool by id.</description></method><method name="getTopToolbar" scope="instance"><description>Returns the toolbar from the top (tbar) section of the panel.</description></method><method name="getUpdater" scope="instance"><description>Get the Ext.Updater for this panel. Enables you to perform Ajax updates of this panel's body.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hides this tooltip if visible.</description></method><method name="initTarget" scope="instance"><description>Binds this ToolTip to the specified element. The tooltip will be displayed when the mouse moves over the element.</description></method><method name="insert" scope="instance"><description>Inserts a Component into this Container at a specified index. Fires the
beforeadd event before inserting, then fires the add event after the
Component has been inserted.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="load" scope="instance"><description>Loads this content panel immediately with content returned from an XHR call.</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="remove" scope="instance"><description>Removes a component from this container.  Fires the beforeremove event before removing, then fires
the remove event after the component has been removed.</description></method><method name="removeAll" scope="instance"><description>Removes all components from this container.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setIconClass" scope="instance"><description>Sets the CSS class that provides the icon image for this panel.  This method will replace any existing
icon class if one has already been set and fire the iconchange event after completion.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setTitle" scope="instance"><description>Sets the title text for the panel and optionally the icon class.
In order to be able to set the title, a header element must have been created
for the Panel. This is triggered either by configuring the Panel with a non-blank title,
or configuring it with header: true.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Shows this tooltip at the current event target XY position.</description></method><method name="showAt" scope="instance"><description>Shows this tip at the specified XY position.  Example usage:
// Show the tip at x:50 and y:100
tip.showAt([50,100]);</description></method><method name="showBy" scope="instance"><description>Experimental. Shows this tip at a position relative to another element using a standard Ext.Element.alignTo
anchor position value.  Example usage:
// Show the tip at the default position ('tl-br?')
tip.showBy('my-el');

// Show the tip's top-left corner anchored to the element's top-right corner
tip.showBy('my-el', 'tl-tr');</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="toggleCollapse" scope="instance"><description>Shortcut for performing an expand or collapse based on the current state of the panel.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method></methods></class><class superclass="Object" type="Ext.FlashProxy"><description/><constructors/><properties/><methods/></class><class superclass="Ext.util.Observable" type="Ext.util.ClickRepeater"><description>A wrapper class which can be applied to any element. Fires a &quot;click&quot; event while the
 mouse is pressed. The interval between firings may be specified in the config but
 defaults to 20 milliseconds.

 Optionally, a CSS class may be applied to the element during the time it is pressed.</description><constructors/><properties/><methods><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="disable" scope="instance"><description>Disables the repeater and stops events from firing.</description></method><method name="enable" scope="instance"><description>Enables the repeater and allows events to fire.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method></methods></class><class superclass="Ext.menu.Item" type="Ext.menu.CheckItem"><description>Adds a menu item that contains a checkbox by default, but can also be part of a radio group.</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="checkHandler" scope="instance"><description>A function that handles the checkchange event.  The function is undefined by default, but if an implementation
is provided, it will be called automatically when the checkchange event fires.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setChecked" scope="instance"><description>Set the checked state of this item</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHandler" scope="instance"><description>Sets the function that will handle click events for this item (equivalent to passing in the handler
config property).  If an existing handler is already registered, it will be unregistered for you.</description></method><method name="setIconClass" scope="instance"><description>Sets the CSS class to apply to the item's icon element</description></method><method name="setText" scope="instance"><description>Sets the text to display in this menu item</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method></methods></class><class superclass="Ext.Container" type="Ext.Panel"><description>Panel is a container that has specific functionality and structural components that make
it the perfect building block for application-oriented user interfaces.
Panels are, by virtue of their inheritance from Ext.Container, capable
of being configured with a layout, and containing child Components.
When either specifying child items of a Panel, or dynamically adding Components
to a Panel, remember to consider how you wish the Panel to arrange those child elements, and whether
those child elements need to be sized using one of Ext's built-in layout schemes. By
default, Panels use the ContainerLayout scheme. This simply renders
child components, appending them one after the other inside the Container, and does not apply any sizing
at all.
A Panel may also contain bottom and top toolbars, along with separate
header, footer and body sections (see frame for additional
information).
Panel also provides built-in expandable and collapsible behavior, along with
a variety of prebuilt tool buttons that can be wired up to provide other customized
behavior.  Panels can be easily dropped into any Container or layout, and the
layout and rendering pipeline is completely managed by the framework.</description><constructors/><properties/><methods><method name="add" scope="instance"><description>Adds Component(s) to this Container.
Description :

Fires the beforeadd event before adding
The Container's default config values will be applied
accordingly (see defaults for details).
Fires the add event after the component has been added.

Notes :

If the Container is already rendered when add
is called, you may need to call doLayout to refresh the view which causes
any unrendered child Components to be rendered. This is required so that you can
add multiple child components if needed while only refreshing the layout
once. For example:var tb = new Ext.Toolbar();
tb.render(document.body);  // toolbar is rendered
tb.add({text:'Button 1'}); // add multiple items (defaultType for Toolbar is 'button')
tb.add({text:'Button 2'});
tb.doLayout();             // refresh the layout
Warning: Containers directly managed by the BorderLayout layout manager
may not be removed or added.  See the Notes for BorderLayout
for more details.
</description></method><method name="addButton" scope="instance"><description>Adds a button to this panel.  Note that this method must be called prior to rendering.  The preferred
approach is to add buttons via the buttons config.</description></method><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cascade" scope="instance"><description>Cascades down the component/container heirarchy from this component (called first), calling the specified function with
each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the cascade is stopped on that branch.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="collapse" scope="instance"><description>Collapses the panel body so that it becomes hidden.  Fires the beforecollapse event which will
cancel the collapse action if it returns false.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="doLayout" scope="instance"><description>Force this container's layout to be recalculated. A call to this function is required after adding a new component
to an already rendered container, or possibly after changing sizing/position properties of child components.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="expand" scope="instance"><description>Expands the panel body so that it becomes visible.  Fires the beforeexpand event which will
cancel the expand action if it returns false.</description></method><method name="find" scope="instance"><description>Find a component under this container at any level by property</description></method><method name="findBy" scope="instance"><description>Find a component under this container at any level by a custom function. If the passed function returns
true, the component will be included in the results. The passed function is called with the arguments (component, this container).</description></method><method name="findById" scope="instance"><description>Find a component under this container at any level by id</description></method><method name="findByType" scope="instance"><description>Find a component under this container at any level by xtype or class</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="get" scope="instance"><description>Get a component contained by this container (alias for items.get(key))</description></method><method name="getBottomToolbar" scope="instance"><description>Returns the toolbar from the bottom (bbar) section of the panel.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getComponent" scope="instance"><description>Examines this container's items property
and gets a direct child component of this container.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getFooterToolbar" scope="instance"><description>Returns the toolbar from the footer (fbar) section of the panel.</description></method><method name="getFrameHeight" scope="instance"><description>Returns the height in pixels of the framing elements of this panel (including any top and bottom bars and
header and footer elements, but not including the body height).  To retrieve the body height see getInnerHeight.</description></method><method name="getFrameWidth" scope="instance"><description>Returns the width in pixels of the framing elements of this panel (not including the body width).  To
retrieve the body width see getInnerWidth.</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getInnerHeight" scope="instance"><description>Returns the height in pixels of the body element (not including the height of any framing elements).
For the frame height see getFrameHeight.</description></method><method name="getInnerWidth" scope="instance"><description>Returns the width in pixels of the body element (not including the width of any framing elements).
For the frame width see getFrameWidth.</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getLayout" scope="instance"><description>Returns the layout currently in use by the container.  If the container does not currently have a layout
set, a default Ext.layout.ContainerLayout will be created and set as the container's layout.</description></method><method name="getLayoutTarget" scope="instance"><description>Returns the Element to be used to contain the child Components of this Container.
An implementation is provided which returns the Container's Element, but
if there is a more complex structure to a Container, this may be overridden to return
the element into which the layout renders child Components.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getTool" scope="instance"><description>Retrieve a tool by id.</description></method><method name="getTopToolbar" scope="instance"><description>Returns the toolbar from the top (tbar) section of the panel.</description></method><method name="getUpdater" scope="instance"><description>Get the Ext.Updater for this panel. Enables you to perform Ajax updates of this panel's body.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="insert" scope="instance"><description>Inserts a Component into this Container at a specified index. Fires the
beforeadd event before inserting, then fires the add event after the
Component has been inserted.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="load" scope="instance"><description>Loads this content panel immediately with content returned from an XHR call.</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="remove" scope="instance"><description>Removes a component from this container.  Fires the beforeremove event before removing, then fires
the remove event after the component has been removed.</description></method><method name="removeAll" scope="instance"><description>Removes all components from this container.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setIconClass" scope="instance"><description>Sets the CSS class that provides the icon image for this panel.  This method will replace any existing
icon class if one has already been set and fire the iconchange event after completion.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setTitle" scope="instance"><description>Sets the title text for the panel and optionally the icon class.
In order to be able to set the title, a header element must have been created
for the Panel. This is triggered either by configuring the Panel with a non-blank title,
or configuring it with header: true.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="toggleCollapse" scope="instance"><description>Shortcut for performing an expand or collapse based on the current state of the panel.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method></methods></class><class superclass="Object" type="Ext.Direct.Transaction"><description>Supporting Class for Ext.Direct (not intended to be used directly).</description><constructors/><properties/><methods/></class><class superclass="Object" type="Ext.tree.TreeFilter"><description>Note this class is experimental and doesn't update the indent (lines) or expand collapse icons of the nodes</description><constructors/><properties/><methods><method name="clear" scope="instance"><description>Clears the current filter. Note: with the &quot;remove&quot; option
set a filter cannot be cleared.</description></method><method name="filter" scope="instance"><description>Filter the data by a specific attribute.</description></method><method name="filterBy" scope="instance"><description>Filter by a function. The passed function will be called with each
node in the tree (or from the startNode). If the function returns true, the node is kept
otherwise it is filtered. If a node is filtered, its children are also filtered.</description></method></methods></class><class superclass="Ext.BoxComponent" type="Ext.slider.MultiSlider"><description>Slider which supports vertical or horizontal orientation, keyboard adjustments, configurable snapping, axis clicking and animation. Can be added as an item to any container. Example usage:

new Ext.Slider({
    renderTo: Ext.getBody(),
    width: 200,
    value: 50,
    increment: 10,
    minValue: 0,
    maxValue: 100
});

Sliders can be created with more than one thumb handle by passing an array of values instead of a single one:

new Ext.Slider({
    renderTo: Ext.getBody(),
    width: 200,
    values: [25, 50, 75],
    minValue: 0,
    maxValue: 100,

    //this defaults to true, setting to false allows the thumbs to pass each other
    constrainThumbs: false
});
</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="addThumb" scope="instance"><description>Creates a new thumb and adds it to the slider</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getValue" scope="instance"><description>Returns the current value of the slider</description></method><method name="getValues" scope="instance"><description>Returns an array of values - one for the location of each thumb</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setMaxValue" scope="instance"><description>Sets the maximum value for the slider instance. If the current value is more than the
maximum value, the current value will be changed.</description></method><method name="setMinValue" scope="instance"><description>Sets the minimum value for the slider instance. If the current value is less than the
minimum value, the current value will be changed.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setValue" scope="instance"><description>Programmatically sets the value of the Slider. Ensures that the value is constrained within
the minValue and maxValue.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="syncThumb" scope="instance"><description>Synchronizes the thumb position to the proper proportion of the total component width based
on the current slider value.  This will be called automatically when the Slider
is resized by a layout, but if it is rendered auto width, this method can be called from
another resize handler to sync the Slider if necessary.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method></methods></class><class superclass="Ext.list.Column" type="Ext.list.DateColumn"><description>A Column definition class which renders a passed date according to the default locale, or a configured
format. See the xtype config option of Ext.list.Column
for more details.</description><constructors/><properties/><methods/></class><class superclass="Object" type="Ext.util.Cookies"><description>Utility class for managing and interacting with cookies.</description><constructors/><properties/><methods><method name="clear" scope="instance"><description>Removes a cookie with the provided name from the browser
if found by setting its expiration date to sometime in the past.</description></method><method name="get" scope="instance"><description>Retrieves cookies that are accessible by the current page. If a cookie
does not exist, get() returns null.  The following
example retrieves the cookie called &quot;valid&quot; and stores the String value
in the variable validStatus.
var validStatus = Ext.util.Cookies.get(&quot;valid&quot;);</description></method><method name="set" scope="instance"><description>Create a cookie with the specified name and value. Additional settings
for the cookie may be optionally specified (for example: expiration,
access restriction, SSL).</description></method></methods></class><class superclass="Ext.grid.Column" type="Ext.grid.ActionColumn"><description>A Grid column type which renders an icon, or a series of icons in a grid cell, and offers a scoped click
handler for each icon. Example usage:
new Ext.grid.GridPanel({
    store: myStore,
    columns: [
        {
            xtype: 'actioncolumn',
            width: 50,
            items: [
                {
                    icon   : 'sell.gif',                // Use a URL in the icon config
                    tooltip: 'Sell stock',
                    handler: function(grid, rowIndex, colIndex) {
                        var rec = store.getAt(rowIndex);
                        alert(&quot;Sell &quot; + rec.get('company'));
                    }
                },
                {
                    getClass: function(v, meta, rec) {  // Or return a class from a function
                        if (rec.get('change') &lt; 0) {
                            this.items[1].tooltip = 'Do not buy!';
                            return 'alert-col';
                        } else {
                            this.items[1].tooltip = 'Buy stock';
                            return 'buy-col';
                        }
                    },
                    handler: function(grid, rowIndex, colIndex) {
                        var rec = store.getAt(rowIndex);
                        alert(&quot;Buy &quot; + rec.get('company'));
                    }
                }
            ]
        }
        //any other columns here
    ]
});

The action column can be at any index in the columns array, and a grid can have any number of
action columns. </description><constructors/><properties/><methods><method name="getCellEditor" scope="instance"><description>Returns the editor defined for this column that was created to wrap the Field
used to edit the cell.</description></method><method name="setEditor" scope="instance"><description>Sets a new editor for this column.</description></method></methods></class><class superclass="Ext.list.Column" type="Ext.list.NumberColumn"><description>A Column definition class which renders a numeric data field according to a format string.  See the
xtype config option of Ext.list.Column for more details.</description><constructors/><properties/><methods/></class><class superclass="Ext.Panel" type="Ext.Window"><description>A specialized panel intended for use as an application window.  Windows are floated, resizable, and
draggable by default.  Windows can be maximized to fill the viewport,
restored to their prior size, and can be minimized.
Windows can also be linked to a Ext.WindowGroup or managed by the Ext.WindowMgr to provide
grouping, activation, to front, to back and other application-specific behavior.
By default, Windows will be rendered to document.body. To constrain a Window to another element
specify renderTo.
Note: By default, the close header tool destroys the Window resulting in
destruction of any child Components. This makes the Window object, and all its descendants unusable. To enable
re-use of a Window, use closeAction: 'hide'.</description><constructors/><properties/><methods><method name="add" scope="instance"><description>Adds Component(s) to this Container.
Description :

Fires the beforeadd event before adding
The Container's default config values will be applied
accordingly (see defaults for details).
Fires the add event after the component has been added.

Notes :

If the Container is already rendered when add
is called, you may need to call doLayout to refresh the view which causes
any unrendered child Components to be rendered. This is required so that you can
add multiple child components if needed while only refreshing the layout
once. For example:var tb = new Ext.Toolbar();
tb.render(document.body);  // toolbar is rendered
tb.add({text:'Button 1'}); // add multiple items (defaultType for Toolbar is 'button')
tb.add({text:'Button 2'});
tb.doLayout();             // refresh the layout
Warning: Containers directly managed by the BorderLayout layout manager
may not be removed or added.  See the Notes for BorderLayout
for more details.
</description></method><method name="addButton" scope="instance"><description>Adds a button to this panel.  Note that this method must be called prior to rendering.  The preferred
approach is to add buttons via the buttons config.</description></method><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="alignTo" scope="instance"><description>Aligns the window to the specified element</description></method><method name="anchorTo" scope="instance"><description>Anchors this window to another element and realigns it when the window is resized or scrolled.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cascade" scope="instance"><description>Cascades down the component/container heirarchy from this component (called first), calling the specified function with
each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the cascade is stopped on that branch.</description></method><method name="center" scope="instance"><description>Centers this window in the viewport</description></method><method name="clearAnchor" scope="instance"><description>Removes any existing anchor from this window. See anchorTo.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="close" scope="instance"><description>Closes the Window, removes it from the DOM, destroys
the Window object and all its descendant Components. The beforeclose
event is fired before the close happens and will cancel the close action if it returns false.
Note: This method is not affected by the closeAction setting which
only affects the action triggered when clicking the 'close' tool in the header.
To hide the Window without destroying it, call hide.</description></method><method name="collapse" scope="instance"><description>Collapses the panel body so that it becomes hidden.  Fires the beforecollapse event which will
cancel the collapse action if it returns false.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="doLayout" scope="instance"><description>Force this container's layout to be recalculated. A call to this function is required after adding a new component
to an already rendered container, or possibly after changing sizing/position properties of child components.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="expand" scope="instance"><description>Expands the panel body so that it becomes visible.  Fires the beforeexpand event which will
cancel the expand action if it returns false.</description></method><method name="find" scope="instance"><description>Find a component under this container at any level by property</description></method><method name="findBy" scope="instance"><description>Find a component under this container at any level by a custom function. If the passed function returns
true, the component will be included in the results. The passed function is called with the arguments (component, this container).</description></method><method name="findById" scope="instance"><description>Find a component under this container at any level by id</description></method><method name="findByType" scope="instance"><description>Find a component under this container at any level by xtype or class</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Focuses the window.  If a defaultButton is set, it will receive focus, otherwise the
window itself will receive focus.</description></method><method name="get" scope="instance"><description>Get a component contained by this container (alias for items.get(key))</description></method><method name="getBottomToolbar" scope="instance"><description>Returns the toolbar from the bottom (bbar) section of the panel.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getComponent" scope="instance"><description>Examines this container's items property
and gets a direct child component of this container.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getFooterToolbar" scope="instance"><description>Returns the toolbar from the footer (fbar) section of the panel.</description></method><method name="getFrameHeight" scope="instance"><description>Returns the height in pixels of the framing elements of this panel (including any top and bottom bars and
header and footer elements, but not including the body height).  To retrieve the body height see getInnerHeight.</description></method><method name="getFrameWidth" scope="instance"><description>Returns the width in pixels of the framing elements of this panel (not including the body width).  To
retrieve the body width see getInnerWidth.</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getInnerHeight" scope="instance"><description>Returns the height in pixels of the body element (not including the height of any framing elements).
For the frame height see getFrameHeight.</description></method><method name="getInnerWidth" scope="instance"><description>Returns the width in pixels of the body element (not including the width of any framing elements).
For the frame width see getFrameWidth.</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getLayout" scope="instance"><description>Returns the layout currently in use by the container.  If the container does not currently have a layout
set, a default Ext.layout.ContainerLayout will be created and set as the container's layout.</description></method><method name="getLayoutTarget" scope="instance"><description>Returns the Element to be used to contain the child Components of this Container.
An implementation is provided which returns the Container's Element, but
if there is a more complex structure to a Container, this may be overridden to return
the element into which the layout renders child Components.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getTool" scope="instance"><description>Retrieve a tool by id.</description></method><method name="getTopToolbar" scope="instance"><description>Returns the toolbar from the top (tbar) section of the panel.</description></method><method name="getUpdater" scope="instance"><description>Get the Ext.Updater for this panel. Enables you to perform Ajax updates of this panel's body.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hides the window, setting it to invisible and applying negative offsets.</description></method><method name="insert" scope="instance"><description>Inserts a Component into this Container at a specified index. Fires the
beforeadd event before inserting, then fires the add event after the
Component has been inserted.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="load" scope="instance"><description>Loads this content panel immediately with content returned from an XHR call.</description></method><method name="maximize" scope="instance"><description>Fits the window within its current container and automatically replaces
the 'maximize' tool button with the 'restore' tool button.
Also see toggleMaximize.</description></method><method name="minimize" scope="instance"><description>Placeholder method for minimizing the window.  By default, this method simply fires the minimize event
since the behavior of minimizing a window is application-specific.  To implement custom minimize behavior,
either the minimize event can be handled or this method can be overridden.</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="remove" scope="instance"><description>Removes a component from this container.  Fires the beforeremove event before removing, then fires
the remove event after the component has been removed.</description></method><method name="removeAll" scope="instance"><description>Removes all components from this container.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="restore" scope="instance"><description>Restores a maximized  window back to its original
size and position prior to being maximized and also replaces
the 'restore' tool button with the 'maximize' tool button.
Also see toggleMaximize.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setActive" scope="instance"><description>Makes this the active window by showing its shadow, or deactivates it by hiding its shadow.  This method also
fires the activate or deactivate event depending on which action occurred. This method is
called internally by Ext.WindowMgr.</description></method><method name="setAnimateTarget" scope="instance"><description>Sets the target element from which the window should animate while opening.</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setIconClass" scope="instance"><description>Sets the CSS class that provides the icon image for this panel.  This method will replace any existing
icon class if one has already been set and fire the iconchange event after completion.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setTitle" scope="instance"><description>Sets the title text for the panel and optionally the icon class.
In order to be able to set the title, a header element must have been created
for the Panel. This is triggered either by configuring the Panel with a non-blank title,
or configuring it with header: true.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Shows the window, rendering it first if necessary, or activates it and brings it to front if hidden.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="toBack" scope="instance"><description>Sends this window to the back of (lower z-index than) any other visible windows</description></method><method name="toFront" scope="instance"><description>Brings this window to the front of any other visible windows</description></method><method name="toggleCollapse" scope="instance"><description>Shortcut for performing an expand or collapse based on the current state of the panel.</description></method><method name="toggleMaximize" scope="instance"><description>A shortcut method for toggling between maximize and restore based on the current maximized
state of the window.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method></methods></class><class superclass="Ext.form.Action" type="Ext.form.Action.Load"><description>A class which handles loading of data from a server into the Fields of an Ext.form.BasicForm.
Instances of this class are only created by a Form when
loading.
Response Packet Criteria
A response packet must contain:

success property : Boolean
data property : Object
The data property contains the values of Fields to load.
The individual value object for each Field is passed to the Field's
setValue method.

JSON Packets
By default, response packets are assumed to be JSON, so for the following form load call:var myFormPanel = new Ext.form.FormPanel({
    title: 'Client and routing info',
    items: [{
        fieldLabel: 'Client',
        name: 'clientName'
    }, {
        fieldLabel: 'Port of loading',
        name: 'portOfLoading'
    }, {
        fieldLabel: 'Port of discharge',
        name: 'portOfDischarge'
    }]
});
myFormPanel.getForm().load({
    url: '/getRoutingInfo.php',
    params: {
        consignmentRef: myConsignmentRef
    },
    failure: function(form, action) {
        Ext.Msg.alert(&quot;Load failed&quot;, action.result.errorMessage);
    }
});
a success response packet may look like this:{
    success: true,
    data: {
        clientName: &quot;Fred. Olsen Lines&quot;,
        portOfLoading: &quot;FXT&quot;,
        portOfDischarge: &quot;OSL&quot;
    }
}
while a failure response packet may look like this:{
    success: false,
    errorMessage: &quot;Consignment reference not found&quot;
}
Other data may be placed into the response for processing the Form's
callback or event handler methods. The object decoded from this JSON is available in the
result property.</description><constructors/><properties/><methods/></class><class superclass="Object" type="Ext.state.Provider"><description>Abstract base class for state provider implementations. This class provides methods
for encoding and decoding typed variables including dates and defines the
Provider interface.</description><constructors/><properties/><methods><method name="clear" scope="instance"><description>Clears a value from the state</description></method><method name="decodeValue" scope="instance"><description>Decodes a string previously encoded with encodeValue.</description></method><method name="encodeValue" scope="instance"><description>Encodes a value including type information.  Decode with decodeValue.</description></method><method name="get" scope="instance"><description>Returns the current value for a key</description></method><method name="set" scope="instance"><description>Sets the value for a key</description></method></methods></class><class superclass="Ext.util.Observable" type="Ext.list.ColumnResizer"><description>Supporting Class for Ext.list.ListView</description><constructors/><properties/><methods><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method></methods></class><class superclass="Ext.data.Store" type="Ext.data.GroupingStore"><description>A specialized store implementation that provides for grouping records by one of the available fields. This
is usually used in conjunction with an Ext.grid.GroupingView to provide the data model for
a grouped GridPanel.
Internally, GroupingStore is simply a normal Store with multi sorting enabled from the start. The grouping field
and direction are always injected as the first sorter pair. GroupingView picks up on the configured groupField and
builds grid rows appropriately.</description><constructors/><properties/><methods><method name="add" scope="instance"><description>Add Records to the Store and fires the add event.  To add Records
to the store from a remote source use load({add:true}).
See also recordType and insert.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="addSorted" scope="instance"><description>(Local sort only) Inserts the passed Record into the Store at the index where it
should go based on the current sort information.</description></method><method name="clearFilter" scope="instance"><description>Revert to a view of the Record cache with no filtering applied.</description></method><method name="clearGrouping" scope="instance"><description>Clears any existing grouping and refreshes the data using the default sort.</description></method><method name="collect" scope="instance"><description>Collects unique values for a particular dataIndex from this store.</description></method><method name="commitChanges" scope="instance"><description>Commit all Records with outstanding changes. To handle updates for changes,
subscribe to the Store's update event, and perform updating when the third parameter is
Ext.data.Record.COMMIT.</description></method><method name="destroy" scope="instance"><description>Destroys the store.</description></method><method name="each" scope="instance"><description>Calls the specified function for each of the Records in the cache.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="filter" scope="instance"><description>Filter the records by a specified property. Alternatively, pass an array of filter
options to filter by more than one property.
Single filter example:
store.filter('name', 'Ed', true, true); //finds all records containing the substring 'Ed'
Multiple filter example:
store.filter([
{
property     : 'name',
value        : 'Ed',
anyMatch     : true, //optional, defaults to true
caseSensitive: true  //optional, defaults to true
},
//filter functions can also be passed
{
fn   : function(record) {
return record.get('age') == 24
},
scope: this
}
]);</description></method><method name="filterBy" scope="instance"><description>Filter by a function. The specified function will be called for each
Record in this Store. If the function returns true the Record is included,
otherwise it is filtered out.</description></method><method name="find" scope="instance"><description>Finds the index of the first matching Record in this store by a specific field value.</description></method><method name="findBy" scope="instance"><description>Find the index of the first matching Record in this Store by a function.
If the function returns true it is considered a match.</description></method><method name="findExact" scope="instance"><description>Finds the index of the first matching Record in this store by a specific field value.</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="getAt" scope="instance"><description>Get the Record at the specified index.</description></method><method name="getById" scope="instance"><description>Get the Record with the specified id.</description></method><method name="getCount" scope="instance"><description>Gets the number of cached records.
If using paging, this may not be the total size of the dataset. If the data object
used by the Reader contains the dataset size, then the getTotalCount function returns
the dataset size.  Note: see the Important note in load.</description></method><method name="getModifiedRecords" scope="instance"><description>Gets all records modified since the last commit.  Modified records are
persisted across load operations (e.g., during paging). Note: deleted records are not
included.  See also pruneModifiedRecords and
Ext.data.RecordmarkDirty..</description></method><method name="getRange" scope="instance"><description>Returns a range of Records between specified indices.</description></method><method name="getSortState" scope="instance"><description>Returns an object describing the current sort state of this Store.</description></method><method name="getTotalCount" scope="instance"><description>Gets the total number of records in the dataset as returned by the server.
If using paging, for this to be accurate, the data object used by the Reader
must contain the dataset size. For remote data sources, the value for this property
(totalProperty for JsonReader,
totalRecords for XmlReader) shall be returned by a query on the server.
Note: see the Important note in load.</description></method><method name="groupBy" scope="instance"><description>Groups the data by the specified field.</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="indexOf" scope="instance"><description>Get the index within the cache of the passed Record.</description></method><method name="indexOfId" scope="instance"><description>Get the index within the cache of the Record with the passed id.</description></method><method name="insert" scope="instance"><description>Inserts Records into the Store at the given index and fires the add event.
See also add and addSorted.</description></method><method name="isFiltered" scope="instance"><description>Returns true if this store is currently filtered</description></method><method name="load" scope="instance"><description>Loads the Record cache from the configured proxy using the configured reader.
Notes:
Important: loading is asynchronous! This call will return before the new data has been
loaded. To perform any post-processing where information from the load call is required, specify
the callback function to be called, or use a a 'load' event handler.
If using remote paging, the first load call must specify the start and limit
properties in the options.params property to establish the initial position within the
dataset, and the number of Records to cache on each read from the Proxy.
If using remote sorting, the configured sortInfo
will be automatically included with the posted parameters according to the specified
paramNames.
</description></method><method name="loadData" scope="instance"><description>Loads data from a passed data block and fires the load event. A Reader
which understands the format of the data must have been configured in the constructor.</description></method><method name="multiSort" scope="instance"><description>Sorts the contents of this store by multiple field/direction sorters. This is called internally by sort
and would not usually be called manually.
Multi sorting only currently applies to local datasets - multiple sort data is not currently sent to a proxy
if remoteSort is used.</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="query" scope="instance"><description>Query the records by a specified property.</description></method><method name="queryBy" scope="instance"><description>Query the cached records in this Store using a filtering function. The specified function
will be called with each record in this Store. If the function returns true the record is
included in the results.</description></method><method name="rejectChanges" scope="instance"><description>Reject outstanding changes on all modified records.</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="reload" scope="instance"><description>Reloads the Record cache from the configured Proxy using the configured
Reader and the options from the last load operation
performed.
Note: see the Important note in load.</description></method><method name="remove" scope="instance"><description>Remove Records from the Store and fires the remove event.</description></method><method name="removeAll" scope="instance"><description>Remove all Records from the Store and fires the clear event.</description></method><method name="removeAt" scope="instance"><description>Remove a Record from the Store at the specified index. Fires the remove event.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="save" scope="instance"><description>Saves all pending changes to the store.  If the commensurate Ext.data.Api.actions action is not configured, then
the configured url will be used.

change            url
---------------   --------------------
removed records   Ext.data.Api.actions.destroy
phantom records   Ext.data.Api.actions.create
modified records  Ext.data.Api.actions.update
</description></method><method name="setBaseParam" scope="instance"><description>Set the value for a property name in this store's baseParams.  Usage:myStore.setBaseParam('foo', {bar:3});</description></method><method name="setDefaultSort" scope="instance"><description>Sets the default sort column and order to be used by the next load operation.</description></method><method name="singleSort" scope="instance"><description>Sorts the store contents by a single field and direction. This is called internally by sort and would
not usually be called manually</description></method><method name="sort" scope="instance"><description>Sort the Records.
If remote sorting is used, the sort is performed on the server, and the cache is reloaded. If local
sorting is used, the cache is sorted internally. See also remoteSort and paramNames.
This function accepts two call signatures - pass in a field name as the first argument to sort on a single
field, or pass in an array of sort configuration objects to sort by multiple fields.
Single sort example:
store.sort('name', 'ASC');
Multi sort example:
store.sort([
{
field    : 'name',
direction: 'ASC'
},
{
field    : 'salary',
direction: 'DESC'
}
], 'ASC');
In this second form, the sort configs are applied in order, with later sorters sorting within earlier sorters' results.
For example, if two records with the same name are present they will also be sorted by salary if given the sort configs
above. Any number of sort configs can be added.</description></method><method name="sum" scope="instance"><description>Sums the value of property for each record between start
and end and returns the result.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method></methods></class><class superclass="Ext.layout.boxOverflow.Menu" type="Ext.layout.boxOverflow.HorizontalMenu"><description>Description</description><constructors/><properties/><methods/></class><class superclass="Object" type="Number"><description/><constructors/><properties/><methods><method name="constrain" scope="instance"><description>Checks whether or not the current number is within a desired range.  If the number is already within the
range it is returned, otherwise the min or max value is returned depending on which side of the range is
exceeded.  Note that this method returns the constrained value but does not change the current number.</description></method></methods></class><class superclass="Ext.WindowGroup" type="Ext.WindowMgr"><description>The default global window group that is available automatically.  To have more than one group of windows
with separate z-order stacks, create additional instances of Ext.WindowGroup as needed.</description><constructors/><properties/><methods><method name="bringToFront" scope="instance"><description>Brings the specified window to the front of any other active windows in this WindowGroup.</description></method><method name="each" scope="instance"><description>Executes the specified function once for every window in this WindowGroup, passing each
window as the only parameter. Returning false from the function will stop the iteration.</description></method><method name="get" scope="instance"><description>Gets a registered window by id.</description></method><method name="getActive" scope="instance"><description>Gets the currently-active window in this WindowGroup.</description></method><method name="getBy" scope="instance"><description>Returns zero or more windows in this WindowGroup using the custom search function passed to this method.
The function should accept a single Ext.Window reference as its only argument and should
return true if the window matches the search criteria, otherwise it should return false.</description></method><method name="hideAll" scope="instance"><description>Hides all windows in this WindowGroup.</description></method><method name="register" scope="instance"><description>Registers a Window with this WindowManager. This should not
need to be called under normal circumstances. Windows are automatically registered
with a manager at construction time.
Where this may be useful is moving Windows between two WindowManagers. For example,
to bring the Ext.MessageBox dialog under the same manager as the Desktop's
WindowManager in the desktop sample app:
var msgWin = Ext.MessageBox.getDialog();
MyDesktop.getDesktop().getManager().register(msgWin);
</description></method><method name="sendToBack" scope="instance"><description>Sends the specified window to the back of other active windows in this WindowGroup.</description></method><method name="unregister" scope="instance"><description>Unregisters a Window from this WindowManager. This should not
need to be called. Windows are automatically unregistered upon destruction.
See register.</description></method></methods></class><class superclass="Ext.chart.CartesianSeries" type="Ext.chart.BarSeries"><description>BarSeries class for the charts widget.</description><constructors/><properties/><methods/></class><class superclass="Ext.chart.CartesianChart" type="Ext.chart.ColumnChart"><description/><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bindStore" scope="instance"><description>Changes the data store bound to this chart and refreshes it.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setSeriesStyles" scope="instance"><description>Sets the styles on all series in the Chart.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setStyle" scope="instance"><description>Sets a single style value on the Chart instance.</description></method><method name="setStyles" scope="instance"><description>Resets all styles on the Chart instance.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method></methods></class><class superclass="Object" type="Ext.data.DataWriter"><description>Ext.data.DataWriter facilitates create, update, and destroy actions between
an Ext.data.Store and a server-side framework. A Writer enabled Store will
automatically manage the Ajax requests to perform CRUD actions on a Store.
Ext.data.DataWriter is an abstract base class which is intended to be extended
and should not be created directly. For existing implementations, see
Ext.data.JsonWriter.
Creating a writer is simple:
var writer = new Ext.data.JsonWriter({
    encode: false   // &lt;--- false causes data to be printed to jsonData config-property of Ext.Ajax#reqeust
});
Same old JsonReader as Ext-2.x:
var reader = new Ext.data.JsonReader({idProperty: 'id'}, [{name: 'first'}, {name: 'last'}, {name: 'email'}]);
The proxy for a writer enabled store can be configured with a simple url:
// Create a standard HttpProxy instance.
var proxy = new Ext.data.HttpProxy({
    url: 'app.php/users'    // &lt;--- Supports &quot;provides&quot;-type urls, such as '/users.json', '/products.xml' (Hello Rails/Merb)
});
For finer grained control, the proxy may also be configured with an API:
// Maximum flexibility with the API-configuration
var proxy = new Ext.data.HttpProxy({
    api: {
        read    : 'app.php/users/read',
        create  : 'app.php/users/create',
        update  : 'app.php/users/update',
        destroy : {  // &lt;--- Supports object-syntax as well
            url: 'app.php/users/destroy',
            method: &quot;DELETE&quot;
        }
    }
});
Pulling it all together into a Writer-enabled Store:
var store = new Ext.data.Store({
    proxy: proxy,
    reader: reader,
    writer: writer,
    autoLoad: true,
    autoSave: true  // -- Cell-level updates.
});
Initiating write-actions automatically, using the existing Ext2.0 Store/Record API:
var rec = store.getAt(0);
rec.set('email', 'foo@bar.com');  // &lt;--- Immediately initiates an UPDATE action through configured proxy.

store.remove(rec);  // &lt;---- Immediately initiates a DESTROY action through configured proxy.
For record/batch updates, use the Store-configuration autoSave:false
var store = new Ext.data.Store({
    proxy: proxy,
    reader: reader,
    writer: writer,
    autoLoad: true,
    autoSave: false  // -- disable cell-updates
});

var urec = store.getAt(0);
urec.set('email', 'foo@bar.com');

var drec = store.getAt(1);
store.remove(drec);

// Push the button!
store.save();</description><constructors/><properties/><methods><method name="apply" scope="instance"><description>Compiles a Store recordset into a data-format defined by an extension such as Ext.data.JsonWriter or Ext.data.XmlWriter in preparation for a server-write action.  The first two params are similar similar in nature to Ext.apply,
Where the first parameter is the receiver of paramaters and the second, baseParams, the source.</description></method><method name="render" scope="instance"><description>abstract method meant to be overridden by all DataWriter extensions.  It's the extension's job to apply the &quot;data&quot; to the &quot;params&quot;.
The data-object provided to render is populated with data according to the meta-info defined in the user's DataReader config,</description></method><method name="toArray" scope="instance"><description>Converts a Hashed Ext.data.Record to fields-array array suitable
for encoding to xml via XTemplate, eg:
&lt;tpl for=&quot;.&quot;&gt;&lt;{name}&gt;{value}&lt;/{name}&lt;/tpl&gt;
eg, non-phantom:
{id: 1, first: 'foo', last: 'bar'} --&gt; [{name: 'id', value: 1}, {name: 'first', value: 'foo'}, {name: 'last', value: 'bar'}]
Phantom records will have had their idProperty omitted in toHash if determined to be auto-generated.
Non AUTOINCREMENT pks should have been protected.</description></method><method name="toHash" scope="instance"><description>Converts a Record to a hash, taking into account the state of the Ext.data.Record along with configuration properties
related to its rendering, such as writeAllFields, phantom, getChanges and
idProperty</description></method></methods></class><class superclass="Object" type="Ext.data.Request"><description>A simple Request class used internally to the data package to provide more generalized remote-requests
to a DataProxy.
TODO Not yet implemented.  Implement in Ext.data.Store#execute</description><constructors/><properties/><methods/></class><class superclass="Ext.layout.ContainerLayout" type="Ext.layout.ToolbarLayout"><description>Layout manager used by Ext.Toolbar. This is highly specialised for use by Toolbars and would not
usually be used by any other class.</description><constructors/><properties/><methods><method name="parseMargins" scope="instance"><description>Parses a number or string representing margin sizes into an object. Supports CSS-style margin declarations
(e.g. 10, &quot;10&quot;, &quot;10 10&quot;, &quot;10 10 10&quot; and &quot;10 10 10 10&quot; are all valid options and would return the same result)</description></method></methods></class><class superclass="Ext.Template" type="Ext.XTemplate"><description>A template class that supports advanced functionality like:
Autofilling arrays using templates and sub-templates
Conditional processing with basic comparison operators
Basic math function support
Execute arbitrary inline code with special built-in template variables
Custom member functions
Many special tags and built-in operators that aren't defined as part of
the API, but are supported in the templates that can be created

XTemplate provides the templating mechanism built into:
Ext.DataView
Ext.ListView
Ext.form.ComboBox
Ext.grid.TemplateColumn
Ext.grid.GroupingView
Ext.menu.Item
Ext.layout.MenuLayout
Ext.ColorPalette

For example usage see the constructor.</description><constructors/><properties/><methods><method name="XTemplate.from" scope="instance"><description>Creates a template from the passed element's value (display:none textarea, preferred) or innerHTML.</description></method><method name="append" scope="instance"><description>Applies the supplied values to the template and appends
the new node(s) to the specified el.
For example usage see the constructor.</description></method><method name="apply" scope="instance"><description>Alias for applyTemplate
Returns an HTML fragment of this template with the specified values applied.</description></method><method name="applyTemplate" scope="instance"><description>Returns an HTML fragment of this template with the specified values applied.</description></method><method name="compile" scope="instance"><description>Compile the template to a function for optimized performance.  Recommended if the template will be used frequently.</description></method><method name="insertAfter" scope="instance"><description>Applies the supplied values to the template and inserts the new node(s) after el.</description></method><method name="insertBefore" scope="instance"><description>Applies the supplied values to the template and inserts the new node(s) before el.</description></method><method name="insertFirst" scope="instance"><description>Applies the supplied values to the template and inserts the new node(s) as the first child of el.</description></method><method name="overwrite" scope="instance"><description>Applies the supplied values to the template and overwrites the content of el with the new node(s).</description></method></methods></class><class superclass="Object" type="Ext.grid.RowNumberer"><description>This is a utility class that can be passed into a Ext.grid.ColumnModel as a column config that provides
an automatic row numbering column.
Usage:
 // This is a typical column config with the first column providing row numbers
 var colModel = new Ext.grid.ColumnModel([
    new Ext.grid.RowNumberer(),
    {header: &quot;Name&quot;, width: 80, sortable: true},
    {header: &quot;Code&quot;, width: 50, sortable: true},
    {header: &quot;Description&quot;, width: 200, sortable: true}
 ]);</description><constructors/><properties/><methods/></class><class superclass="Ext.form.TriggerField" type="Ext.form.DateField"><description>Provides a date input field with a Ext.DatePicker dropdown and automatic date validation.</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="clearInvalid" scope="instance"><description>Clear any invalid styles/messages for this field</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getActiveError" scope="instance"><description>Gets the active error message for this field.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getErrors" scope="instance"><description>Runs all of NumberFields validations and returns an array of any errors. Note that this first
runs TextField's validations, so the returned array is an amalgamation of all field errors.
The additional validation checks are testing that the date format is valid, that the chosen
date is within the min and max date constraints set, that the date chosen is not in the disabledDates
regex and that the day chosed is not one of the disabledDays.</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getName" scope="instance"><description>Returns the name or hiddenName
attribute of the field if available.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getRawValue" scope="instance"><description>Returns the raw data value which may or may not be a valid, defined value.  To return a normalized value see getValue.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getValue" scope="instance"><description>Returns the current date value of the date field.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isDirty" scope="instance"><description>Returns true if the value of this Field has been changed from its original value.
Will return false if the field is disabled or has not been rendered yet.
Note that if the owning form was configured with
Ext.form.BasicForm.trackResetOnLoad
then the original value is updated when the values are loaded by
Ext.form.BasicForm.setValues.</description></method><method name="isValid" scope="instance"><description>Returns whether or not the field value is currently valid by
validating the processed value
of the field. Note: disabled fields are ignored.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="markInvalid" scope="instance"><description>Display an error message associated with this field, using msgTarget to determine how to
display the message and applying invalidClass to the field's UI element.
Note: this method does not cause the Field's validate method to return false
if the value does pass validation. So simply marking a Field as invalid will not prevent
submission of forms submitted with the Ext.form.Action.Submit.clientValidation option set.
invalid.</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="processValue" scope="instance"><description>This method should only be overridden if necessary to prepare raw values
for validation (see validate and isValid).  This method
is expected to return the processed value for the field which will
be used for validation (see validateValue method).</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="reset" scope="instance"><description>Resets the current field value to the originally-loaded value and clears any validation messages.
Also adds emptyText and emptyClass if the
original value was blank.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="selectText" scope="instance"><description>Selects text in this field</description></method><method name="setActiveError" scope="instance"><description>Sets the current activeError to the given string. Fires the 'invalid' event.
This does not set up the error icon, only sets the message and fires the event. To show the error icon,
use markInvalid instead, which calls this method internally</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setDisabledDates" scope="instance"><description>Replaces any existing disabled dates with new values and refreshes the DatePicker.</description></method><method name="setDisabledDays" scope="instance"><description>Replaces any existing disabled days (by index, 0-6) with new values and refreshes the DatePicker.</description></method><method name="setEditable" scope="instance"><description>Allow or prevent the user from directly editing the field text.  If false is passed,
the user will only be able to modify the field using the trigger.  Will also add
a click event to the text field which will call the trigger. This method
is the runtime equivalent of setting the editable config option at config time.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setHideTrigger" scope="instance"><description>Changes the hidden status of the trigger.</description></method><method name="setMaxValue" scope="instance"><description>Replaces any existing maxValue with the new value and refreshes the DatePicker.</description></method><method name="setMinValue" scope="instance"><description>Replaces any existing minValue with the new value and refreshes the DatePicker.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setRawValue" scope="instance"><description>Sets the underlying DOM field's value directly, bypassing validation.  To set the value with validation see setValue.</description></method><method name="setReadOnly" scope="instance"><description>Setting this to true will supersede settings editable and hideTrigger.
Setting this to false will defer back to editable and hideTrigger. This method
is the runtime equivalent of setting the readOnly config option at config time.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setValue" scope="instance"><description>Sets the value of the date field.  You can pass a date object or any string that can be
parsed into a valid date, using format as the date format, according
to the same rules as Date.parseDate (the default format used is &quot;m/d/Y&quot;).
Usage:
//All of these calls set the same date value (May 4, 2006)

//Pass a date object:
var dt = new Date('5/4/2006');
dateField.setValue(dt);

//Pass a date string (default format):
dateField.setValue('05/04/2006');

//Pass a date string (custom format):
dateField.format = 'Y-m-d';
dateField.setValue('2006-05-04');</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="unsetActiveError" scope="instance"><description>Clears the activeError and fires the 'valid' event. This is called internally by clearInvalid and would not
usually need to be called manually</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method><method name="validate" scope="instance"><description>Validates the field value</description></method><method name="validateValue" scope="instance"><description>Uses getErrors to build an array of validation errors. If any errors are found, markInvalid is called
with the first and false is returned, otherwise true is returned. Previously, subclasses were invited
to provide an implementation of this to process validations - from 3.2 onwards getErrors should be
overridden instead.</description></method></methods></class><class superclass="Ext.util.TaskRunner" type="Ext.TaskMgr"><description>A static Ext.util.TaskRunner instance that can be used to start and stop arbitrary tasks.  See
Ext.util.TaskRunner for supported methods and task config properties.
// Start a simple clock task that updates a div once per second
var task = {
    run: function(){
        Ext.fly('clock').update(new Date().format('g:i:s A'));
    },
    interval: 1000 //1 second
}
Ext.TaskMgr.start(task);
See the start method for details about how to configure a task object.</description><constructors/><properties/><methods><method name="start" scope="instance"><description>Starts a new task.</description></method><method name="stop" scope="instance"><description>Stops an existing running task.</description></method><method name="stopAll" scope="instance"><description>Stops all tasks that are currently running.</description></method></methods></class><class superclass="Ext.dd.DropTarget" type="Ext.dd.DropZone"><description>This class provides a container DD instance that allows dropping on multiple child target nodes.
By default, this class requires that child nodes accepting drop are registered with Ext.dd.Registry.
However a simpler way to allow a DropZone to manage any number of target elements is to configure the
DropZone with an implementation of getTargetFromEvent which interrogates the passed
mouse event to see if it has taken place within an element, or class of elements. This is easily done
by using the event's getTarget method to identify a node based on a
Ext.DomQuery selector.
Once the DropZone has detected through calling getTargetFromEvent, that the mouse is over
a drop target, that target is passed as the first parameter to onNodeEnter, onNodeOver,
onNodeOut, onNodeDrop. You may configure the instance of DropZone with implementations
of these methods to provide application-specific behaviour for these events to update both
application state, and UI state.
For example to make a GridPanel a cooperating target with the example illustrated in
DragZone, the following technique might be used:myGridPanel.on('render', function() {
    myGridPanel.dropZone = new Ext.dd.DropZone(myGridPanel.getView().scroller, {

//      If the mouse is over a grid row, return that node. This is
//      provided as the &quot;target&quot; parameter in all &quot;onNodeXXXX&quot; node event handling functions
        getTargetFromEvent: function(e) {
            return e.getTarget(myGridPanel.getView().rowSelector);
        },

//      On entry into a target node, highlight that node.
        onNodeEnter : function(target, dd, e, data){ 
            Ext.fly(target).addClass('my-row-highlight-class');
        },

//      On exit from a target node, unhighlight that node.
        onNodeOut : function(target, dd, e, data){ 
            Ext.fly(target).removeClass('my-row-highlight-class');
        },

//      While over a target node, return the default drop allowed class which
//      places a &quot;tick&quot; icon into the drag proxy.
        onNodeOver : function(target, dd, e, data){ 
            return Ext.dd.DropZone.prototype.dropAllowed;
        },

//      On node drop we can interrogate the target to find the underlying
//      application object that is the real target of the dragged data.
//      In this case, it is a Record in the GridPanel's Store.
//      We can use the data set up by the DragZone's getDragData method to read
//      any data we decided to attach in the DragZone's getDragData method.
        onNodeDrop : function(target, dd, e, data){
            var rowIndex = myGridPanel.getView().findRowIndex(target);
            var r = myGridPanel.getStore().getAt(rowIndex);
            Ext.Msg.alert('Drop gesture', 'Dropped Record id ' + data.draggedRecord.id +
                ' on Record id ' + r.id);
            return true;
        }
    });
}
See the DragZone documentation for details about building a DragZone which
cooperates with this DropZone.</description><constructors/><properties/><methods><method name="addToGroup" scope="instance"><description>Add this instance to a group of related drag/drop objects.  All
instances belong to at least one group, and can belong to as many
groups as needed.</description></method><method name="applyConfig" scope="instance"><description>Applies the configuration parameters that were passed into the constructor.
This is supposed to happen at each level through the inheritance chain.  So
a DDProxy implentation will execute apply config on DDProxy, DD, and
DragDrop in order to get all of the parameters that are available in
each object.</description></method><method name="constrainTo" scope="instance"><description>Initializes the drag drop object's constraints to restrict movement to a certain element.
Usage:
 var dd = new Ext.dd.DDProxy(&quot;dragDiv1&quot;, &quot;proxytest&quot;,
                { dragElId: &quot;existingProxyDiv&quot; });
 dd.startDrag = function(){
     this.constrainTo(&quot;parent-id&quot;);
 };
Or you can initalize it using the Ext.Element object:
 Ext.get(&quot;dragDiv1&quot;).initDDProxy(&quot;proxytest&quot;, {dragElId: &quot;existingProxyDiv&quot;}, {
     startDrag : function(){
         this.constrainTo(&quot;parent-id&quot;);
     }
 });</description></method><method name="getEl" scope="instance"><description>Returns a reference to the linked element</description></method><method name="getTargetFromEvent" scope="instance"><description>Returns a custom data object associated with the DOM node that is the target of the event.  By default
this looks up the event target in the Ext.dd.Registry, although you can override this method to
provide your own custom lookup.</description></method><method name="init" scope="instance"><description>Sets up the DragDrop object.  Must be called in the constructor of any
Ext.dd.DragDrop subclass</description></method><method name="initTarget" scope="instance"><description>Initializes Targeting functionality only... the object does not
get a mousedown handler.</description></method><method name="isLocked" scope="instance"><description>Returns true if this instance is locked, or the drag drop mgr is locked
(meaning that all drag/drop is disabled on the page.)</description></method><method name="lock" scope="instance"><description>Lock this instance</description></method><method name="notifyDrop" scope="instance"><description>The function a Ext.dd.DragSource calls once to notify this drop zone that the dragged item has
been dropped on it.  The drag zone will look up the target node based on the event passed in, and if there
is a node registered for that event, it will delegate to onNodeDrop for node-specific handling,
otherwise it will call onContainerDrop.</description></method><method name="notifyEnter" scope="instance"><description>The function a Ext.dd.DragSource calls once to notify this drop zone that the source is now over
the zone.  The default implementation returns this.dropNotAllowed and expects that only registered drop
nodes can process drag drop operations, so if you need the drop zone itself to be able to process drops
you should override this method and provide a custom implementation.</description></method><method name="notifyOut" scope="instance"><description>The function a Ext.dd.DragSource calls once to notify this drop zone that the source has been dragged
out of the zone without dropping.  If the drag source is currently over a registered node, the notification
will be delegated to onNodeOut for node-specific handling, otherwise it will be ignored.</description></method><method name="notifyOver" scope="instance"><description>The function a Ext.dd.DragSource calls continuously while it is being dragged over the drop zone.
This method will be called on every mouse movement while the drag source is over the drop zone.
It will call onNodeOver while the drag source is over a registered node, and will also automatically
delegate to the appropriate node-specific methods as necessary when the drag source enters and exits
registered nodes (onNodeEnter, onNodeOut). If the drag source is not currently over a
registered node, it will call onContainerOver.</description></method><method name="onAvailable" scope="instance"><description>Override the onAvailable method to do what is needed after the initial
position was determined.</description></method><method name="onContainerDrop" scope="instance"><description>Called when the DropZone determines that a Ext.dd.DragSource has been dropped on it,
but not on any of its registered drop nodes.  The default implementation returns false, so it should be
overridden to provide the appropriate processing of the drop event if you need the drop zone itself to
be able to accept drops.  It should return true when valid so that the drag source's repair action does not run.</description></method><method name="onContainerOver" scope="instance"><description>Called while the DropZone determines that a Ext.dd.DragSource is being dragged over it,
but not over any of its registered drop nodes.  The default implementation returns this.dropNotAllowed, so
it should be overridden to provide the proper feedback if necessary.</description></method><method name="onNodeDrop" scope="instance"><description>Called when the DropZone determines that a Ext.dd.DragSource has been dropped onto
the drop node.  The default implementation returns false, so it should be overridden to provide the
appropriate processing of the drop event and return true so that the drag source's repair action does not run.</description></method><method name="onNodeEnter" scope="instance"><description>Called when the DropZone determines that a Ext.dd.DragSource has entered a drop node
that has either been registered or detected by a configured implementation of getTargetFromEvent.
This method has no default implementation and should be overridden to provide
node-specific processing if necessary.</description></method><method name="onNodeOut" scope="instance"><description>Called when the DropZone determines that a Ext.dd.DragSource has been dragged out of
the drop node without dropping.  This method has no default implementation and should be overridden to provide
node-specific processing if necessary.</description></method><method name="onNodeOver" scope="instance"><description>Called while the DropZone determines that a Ext.dd.DragSource is over a drop node
that has either been registered or detected by a configured implementation of getTargetFromEvent.
The default implementation returns this.dropNotAllowed, so it should be
overridden to provide the proper feedback.</description></method><method name="removeFromGroup" scope="instance"><description>Remove's this instance from the supplied interaction group</description></method><method name="setPadding" scope="instance"><description>Configures the padding for the target zone in px.  Effectively expands
(or reduces) the virtual object size for targeting calculations.
Supports css-style shorthand; if only one parameter is passed, all sides
will have that padding, and if only two are passed, the top and bottom
will have the first param, the left and right the second.</description></method><method name="toString" scope="instance"><description>toString method</description></method><method name="unlock" scope="instance"><description>Unlock this instace</description></method><method name="unreg" scope="instance"><description>Remove all drag and drop hooks for this element</description></method></methods></class><class superclass="Ext.form.TextField" type="Ext.form.TextArea"><description>Multiline text field.  Can be used as a direct replacement for traditional textarea fields, plus adds
support for auto-sizing.</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="autoSize" scope="instance"><description>Automatically grows the field to accomodate the height of the text up to the maximum field height allowed.
This only takes effect if grow = true, and fires the autosize event if the height changes.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="clearInvalid" scope="instance"><description>Clear any invalid styles/messages for this field</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getActiveError" scope="instance"><description>Gets the active error message for this field.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getErrors" scope="instance"><description>Validates a value according to the field's validation rules and returns an array of errors
for any failing validations. Validation rules are processed in the following order:

1. Field specific validator

A validator offers a way to customize and reuse a validation specification.
If a field is configured with a validator
function, it will be passed the current field value.  The validator
function is expected to return either:

Boolean true if the value is valid (validation continues).
a String to represent the invalid message if invalid (validation halts).


2. Basic Validation

If the validator has not halted validation,
basic validation proceeds as follows:

allowBlank : (Invalid message =
emptyText)
Depending on the configuration of allowBlank, a
blank field will cause validation to halt at this step and return
Boolean true or false accordingly.  

minLength : (Invalid message =
minLengthText)
If the passed value does not satisfy the minLength
specified, validation halts.

maxLength : (Invalid message =
maxLengthText)
If the passed value does not satisfy the maxLength
specified, validation halts.



3. Preconfigured Validation Types (VTypes)

If none of the prior validation steps halts validation, a field
configured with a vtype will utilize the
corresponding VTypes validation function.
If invalid, either the field's vtypeText or
the VTypes vtype Text property will be used for the invalid message.
Keystrokes on the field will be filtered according to the VTypes
vtype Mask property.

4. Field specific regex test

If none of the prior validation steps halts validation, a field's
configured regex test will be processed.
The invalid message for this test is configured with
regexText.
</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getName" scope="instance"><description>Returns the name or hiddenName
attribute of the field if available.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getRawValue" scope="instance"><description>Returns the raw data value which may or may not be a valid, defined value.  To return a normalized value see getValue.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getValue" scope="instance"><description>Returns the normalized data value (undefined or emptyText will be returned as '').  To return the raw value see getRawValue.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isDirty" scope="instance"><description>Returns true if the value of this Field has been changed from its original value.
Will return false if the field is disabled or has not been rendered yet.
Note that if the owning form was configured with
Ext.form.BasicForm.trackResetOnLoad
then the original value is updated when the values are loaded by
Ext.form.BasicForm.setValues.</description></method><method name="isValid" scope="instance"><description>Returns whether or not the field value is currently valid by
validating the processed value
of the field. Note: disabled fields are ignored.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="markInvalid" scope="instance"><description>Display an error message associated with this field, using msgTarget to determine how to
display the message and applying invalidClass to the field's UI element.
Note: this method does not cause the Field's validate method to return false
if the value does pass validation. So simply marking a Field as invalid will not prevent
submission of forms submitted with the Ext.form.Action.Submit.clientValidation option set.
invalid.</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="processValue" scope="instance"><description>This method should only be overridden if necessary to prepare raw values
for validation (see validate and isValid).  This method
is expected to return the processed value for the field which will
be used for validation (see validateValue method).</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="reset" scope="instance"><description>Resets the current field value to the originally-loaded value and clears any validation messages.
Also adds emptyText and emptyClass if the
original value was blank.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="selectText" scope="instance"><description>Selects text in this field</description></method><method name="setActiveError" scope="instance"><description>Sets the current activeError to the given string. Fires the 'invalid' event.
This does not set up the error icon, only sets the message and fires the event. To show the error icon,
use markInvalid instead, which calls this method internally</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setRawValue" scope="instance"><description>Sets the underlying DOM field's value directly, bypassing validation.  To set the value with validation see setValue.</description></method><method name="setReadOnly" scope="instance"><description>Sets the read only state of this field.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setValue" scope="instance"><description>Sets a data value into the field and validates it.  To set the value directly without validation see setRawValue.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="unsetActiveError" scope="instance"><description>Clears the activeError and fires the 'valid' event. This is called internally by clearInvalid and would not
usually need to be called manually</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method><method name="validate" scope="instance"><description>Validates the field value</description></method><method name="validateValue" scope="instance"><description>Uses getErrors to build an array of validation errors. If any errors are found, markInvalid is called
with the first and false is returned, otherwise true is returned. Previously, subclasses were invited
to provide an implementation of this to process validations - from 3.2 onwards getErrors should be
overridden instead.</description></method></methods></class><class superclass="Ext.form.Checkbox" type="Ext.form.Radio"><description>Single radio field.  Same as Checkbox, but provided as a convenience for automatically setting the input type.
Radio grouping is handled automatically by the browser if you give each radio in a group the same name.</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getActiveError" scope="instance"><description>Gets the active error message for this field.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getErrors" scope="instance"><description>Runs this field's validators and returns an array of error messages for any validation failures.
This is called internally during validation and would not usually need to be used manually.
Each subclass should override or augment the return value to provide their own errors</description></method><method name="getGroupValue" scope="instance"><description>If this radio is part of a group, it will return the selected value</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getName" scope="instance"><description>Returns the name or hiddenName
attribute of the field if available.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getRawValue" scope="instance"><description>Returns the raw data value which may or may not be a valid, defined value.  To return a normalized value see getValue.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getValue" scope="instance"><description>Returns the checked state of the checkbox.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isDirty" scope="instance"><description>Returns true if the value of this Field has been changed from its original value.
Will return false if the field is disabled or has not been rendered yet.
Note that if the owning form was configured with
Ext.form.BasicForm.trackResetOnLoad
then the original value is updated when the values are loaded by
Ext.form.BasicForm.setValues.</description></method><method name="isValid" scope="instance"><description>Returns whether or not the field value is currently valid by
validating the processed value
of the field. Note: disabled fields are ignored.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="processValue" scope="instance"><description>This method should only be overridden if necessary to prepare raw values
for validation (see validate and isValid).  This method
is expected to return the processed value for the field which will
be used for validation (see validateValue method).</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="reset" scope="instance"><description>Resets the current field value to the originally loaded value and clears any validation messages.
See Ext.form.BasicForm.trackResetOnLoad</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setActiveError" scope="instance"><description>Sets the current activeError to the given string. Fires the 'invalid' event.
This does not set up the error icon, only sets the message and fires the event. To show the error icon,
use markInvalid instead, which calls this method internally</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setRawValue" scope="instance"><description>Sets the underlying DOM field's value directly, bypassing validation.  To set the value with validation see setValue.</description></method><method name="setReadOnly" scope="instance"><description>Sets the read only state of this field.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setValue" scope="instance"><description>Sets either the checked/unchecked status of this Radio, or, if a string value
is passed, checks a sibling Radio of the same name whose value is the value specified.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="unsetActiveError" scope="instance"><description>Clears the activeError and fires the 'valid' event. This is called internally by clearInvalid and would not
usually need to be called manually</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method><method name="validate" scope="instance"><description>Validates the field value</description></method><method name="validateValue" scope="instance"><description>Uses getErrors to build an array of validation errors. If any errors are found, markInvalid is called
with the first and false is returned, otherwise true is returned. Previously, subclasses were invited
to provide an implementation of this to process validations - from 3.2 onwards getErrors should be
overridden instead.</description></method></methods></class><class superclass="Ext.SplitBar.BasicLayoutAdapter" type="Ext.SplitBar.AbsoluteLayoutAdapter"><description>Adapter that  moves the splitter element to align with the resized sizing element.
Used with an absolute positioned SplitBar.</description><constructors/><properties/><methods><method name="getElementSize" scope="instance"><description>Called before drag operations to get the current size of the resizing element.</description></method><method name="setElementSize" scope="instance"><description>Called after drag operations to set the size of the resizing element.</description></method></methods></class><class superclass="Ext.data.DataWriter" type="Ext.data.JsonWriter"><description>DataWriter extension for writing an array or single Ext.data.Record object(s) in preparation for executing a remote CRUD action.</description><constructors/><properties/><methods><method name="apply" scope="instance"><description>Compiles a Store recordset into a data-format defined by an extension such as Ext.data.JsonWriter or Ext.data.XmlWriter in preparation for a server-write action.  The first two params are similar similar in nature to Ext.apply,
Where the first parameter is the receiver of paramaters and the second, baseParams, the source.</description></method><method name="createRecord" scope="instance"><description>Implements abstract Ext.data.DataWriter#createRecord</description></method><method name="destroyRecord" scope="instance"><description>Implements abstract Ext.data.DataWriter#destroyRecord</description></method><method name="render" scope="instance"><description>This method should not need to be called by application code, however it may be useful on occasion to
override it, or augment it with an interceptor or sequence.
The provided implementation encodes the serialized data representing the Store's modified Records into the Ajax request's
params according to the encode setting.</description></method><method name="toArray" scope="instance"><description>Converts a Hashed Ext.data.Record to fields-array array suitable
for encoding to xml via XTemplate, eg:
&lt;tpl for=&quot;.&quot;&gt;&lt;{name}&gt;{value}&lt;/{name}&lt;/tpl&gt;
eg, non-phantom:
{id: 1, first: 'foo', last: 'bar'} --&gt; [{name: 'id', value: 1}, {name: 'first', value: 'foo'}, {name: 'last', value: 'bar'}]
Phantom records will have had their idProperty omitted in toHash if determined to be auto-generated.
Non AUTOINCREMENT pks should have been protected.</description></method><method name="toHash" scope="instance"><description>Converts a Record to a hash, taking into account the state of the Ext.data.Record along with configuration properties
related to its rendering, such as writeAllFields, phantom, getChanges and
idProperty</description></method><method name="updateRecord" scope="instance"><description>Implements abstract Ext.data.DataWriter#updateRecord</description></method></methods></class><class superclass="Ext.layout.ContainerLayout" type="Ext.layout.ColumnLayout"><description>This is the layout style of choice for creating structural layouts in a multi-column format where the width of
each column can be specified as a percentage or fixed width, but the height is allowed to vary based on the content.
This class is intended to be extended or created via the layout:'column' Ext.Container.layout config,
and should generally not need to be created directly via the new keyword.
ColumnLayout does not have any direct config options (other than inherited ones), but it does support a
specific config property of columnWidth that can be included in the config of any panel added to it.  The
layout will use the columnWidth (if present) or width of each panel during layout to determine how to size each panel.
If width or columnWidth is not specified for a given panel, its width will default to the panel's width (or auto).
The width property is always evaluated as pixels, and must be a number greater than or equal to 1.
The columnWidth property is always evaluated as a percentage, and must be a decimal value greater than 0 and
less than 1 (e.g., .25).
The basic rules for specifying column widths are pretty simple.  The logic makes two passes through the
set of contained panels.  During the first layout pass, all panels that either have a fixed width or none
specified (auto) are skipped, but their widths are subtracted from the overall container width.  During the second
pass, all panels with columnWidths are assigned pixel widths in proportion to their percentages based on
the total remaining container width.  In other words, percentage width panels are designed to fill the space
left over by all the fixed-width and/or auto-width panels.  Because of this, while you can specify any number of columns
with different percentages, the columnWidths must always add up to 1 (or 100%) when added together, otherwise your
layout may not render as expected.  Example usage:
// All columns are percentages -- they must add up to 1
var p = new Ext.Panel({
    title: 'Column Layout - Percentage Only',
    layout:'column',
    items: [{
        title: 'Column 1',
        columnWidth: .25
    },{
        title: 'Column 2',
        columnWidth: .6
    },{
        title: 'Column 3',
        columnWidth: .15
    }]
});

// Mix of width and columnWidth -- all columnWidth values must add up
// to 1. The first column will take up exactly 120px, and the last two
// columns will fill the remaining container width.
var p = new Ext.Panel({
    title: 'Column Layout - Mixed',
    layout:'column',
    items: [{
        title: 'Column 1',
        width: 120
    },{
        title: 'Column 2',
        columnWidth: .8
    },{
        title: 'Column 3',
        columnWidth: .2
    }]
});</description><constructors/><properties/><methods><method name="parseMargins" scope="instance"><description>Parses a number or string representing margin sizes into an object. Supports CSS-style margin declarations
(e.g. 10, &quot;10&quot;, &quot;10 10&quot;, &quot;10 10 10&quot; and &quot;10 10 10 10&quot; are all valid options and would return the same result)</description></method></methods></class><class superclass="Ext.layout.ContainerLayout" type="Ext.layout.TableLayout"><description>This layout allows you to easily render content into an HTML table.  The total number of columns can be
specified, and rowspan and colspan can be used to create complex layouts within the table.
This class is intended to be extended or created via the layout:'table' Ext.Container.layout config,
and should generally not need to be created directly via the new keyword.
Note that when creating a layout via config, the layout-specific config properties must be passed in via
the Ext.Container.layoutConfig object which will then be applied internally to the layout.  In the
case of TableLayout, the only valid layout config property is columns.  However, the items added to a
TableLayout can supply the following table-specific config properties:

rowspan Applied to the table cell containing the item.
colspan Applied to the table cell containing the item.
cellId An id applied to the table cell containing the item.
cellCls A CSS class name added to the table cell containing the item.

The basic concept of building up a TableLayout is conceptually very similar to building up a standard
HTML table.  You simply add each panel (or &quot;cell&quot;) that you want to include along with any span attributes
specified as the special config properties of rowspan and colspan which work exactly like their HTML counterparts.
Rather than explicitly creating and nesting rows and columns as you would in HTML, you simply specify the
total column count in the layoutConfig and start adding panels in their natural order from left to right,
top to bottom.  The layout will automatically figure out, based on the column count, rowspans and colspans,
how to position each panel within the table.  Just like with HTML tables, your rowspans and colspans must add
up correctly in your overall layout or you'll end up with missing and/or extra cells!  Example usage:
// This code will generate a layout table that is 3 columns by 2 rows
// with some spanning included.  The basic layout will be:
// +--------+-----------------+
// |   A    |   B             |
// |        |--------+--------|
// |        |   C    |   D    |
// +--------+--------+--------+
var table = new Ext.Panel({
    title: 'Table Layout',
    layout:'table',
    defaults: {
        // applied to each contained panel
        bodyStyle:'padding:20px'
    },
    layoutConfig: {
        // The total column count must be specified here
        columns: 3
    },
    items: [{
        html: '&lt;p&gt;Cell A content&lt;/p&gt;',
        rowspan: 2
    },{
        html: '&lt;p&gt;Cell B content&lt;/p&gt;',
        colspan: 2
    },{
        html: '&lt;p&gt;Cell C content&lt;/p&gt;',
        cellCls: 'highlight'
    },{
        html: '&lt;p&gt;Cell D content&lt;/p&gt;'
    }]
});</description><constructors/><properties/><methods><method name="parseMargins" scope="instance"><description>Parses a number or string representing margin sizes into an object. Supports CSS-style margin declarations
(e.g. 10, &quot;10&quot;, &quot;10 10&quot;, &quot;10 10 10&quot; and &quot;10 10 10 10&quot; are all valid options and would return the same result)</description></method></methods></class><class superclass="Ext.Error" type="Ext.data.Store.Error"><description>Store Error extension.</description><constructors/><properties/><methods><method name="getMessage" scope="instance"><description>getMessage</description></method><method name="getName" scope="instance"><description>getName</description></method><method name="toJson" scope="instance"><description>toJson</description></method></methods></class><class superclass="Object" type="Ext.data.Field"><description>This class encapsulates the field definition information specified in the field definition objects
passed to Ext.data.Record.create.
Developers do not need to instantiate this class. Instances are created by Ext.data.Record.create
and cached in the fields property of the created Record constructor's prototype.</description><constructors/><properties/><methods/></class><class superclass="Ext.Button" type="Ext.SplitButton"><description>A split button that provides a built-in dropdown arrow that can fire an event separately from the default
click event of the button.  Typically this would be used to display a dropdown menu that provides additional
options to the primary button action, but any custom handler can provide the arrowclick implementation.  Example usage:
// display a dropdown menu:
new Ext.SplitButton({
	renderTo: 'button-ct', // the container id
   	text: 'Options',
   	handler: optionsHandler, // handle a click on the button itself
   	menu: new Ext.menu.Menu({
        items: [
        	// these items will render as dropdown menu items when the arrow is clicked:
	        {text: 'Item 1', handler: item1Handler},
	        {text: 'Item 2', handler: item2Handler}
        ]
   	})
});

// Instead of showing a menu, you provide any type of custom
// functionality you want when the dropdown arrow is clicked:
new Ext.SplitButton({
	renderTo: 'button-ct',
   	text: 'Options',
   	handler: optionsHandler,
   	arrowHandler: myCustomHandler
});</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getPressed" scope="instance"><description>Gets the pressed button in the passed group or null</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getTemplateArgs" scope="instance"><description>This method returns an Array which provides substitution parameters for the Template used
to create this Button's DOM structure.
Instances or subclasses which use a different Template to create a different DOM structure may need to provide their
own implementation of this method.
The default implementation which provides data for the default template returns an Array containing the
following items:
The &lt;button&gt;'s type
A CSS class name applied to the Button's main &lt;tbody&gt; element which determines the button's scale and icon alignment.
A CSS class to determine the presence and position of an arrow icon. ('x-btn-arrow' or 'x-btn-arrow-bottom' or '')
The cls CSS class name applied to the button's wrapping &lt;table&gt; element.
The Component id which is applied to the button's wrapping &lt;table&gt; element.
</description></method><method name="getText" scope="instance"><description>Gets the text for this Button</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hasVisibleMenu" scope="instance"><description>Returns true if the button has a menu and it is visible</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="hideMenu" scope="instance"><description>Hide this button's menu (if it has one)</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setArrowHandler" scope="instance"><description>Sets this button's arrow click handler.</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHandler" scope="instance"><description>Assigns this Button's click handler</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setIcon" scope="instance"><description>Sets the background image (inline style) of the button.  This method also changes
the value of the icon config internally.</description></method><method name="setIconClass" scope="instance"><description>Sets the CSS class that provides a background image to use as the button's icon.  This method also changes
the value of the iconCls config internally.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setText" scope="instance"><description>Sets this Button's text</description></method><method name="setTooltip" scope="instance"><description>Sets the tooltip for this Button.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="showMenu" scope="instance"><description>Show this button's menu (if it has one)</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="toggle" scope="instance"><description>If a state it passed, it becomes the pressed state otherwise the current state is toggled.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method></methods></class><class superclass="Ext.layout.ContainerLayout" type="Ext.layout.BoxLayout"><description>Base Class for HBoxLayout and VBoxLayout Classes. Generally it should not need to be used directly.</description><constructors/><properties/><methods><method name="parseMargins" scope="instance"><description>Parses a number or string representing margin sizes into an object. Supports CSS-style margin declarations
(e.g. 10, &quot;10&quot;, &quot;10 10&quot;, &quot;10 10 10&quot; and &quot;10 10 10 10&quot; are all valid options and would return the same result)</description></method><method name="updateChildBoxes" scope="instance"><description>Resizes and repositions each child component</description></method></methods></class><class superclass="Object" type="Date"><description>The date parsing and formatting syntax contains a subset of
PHP's date() function, and the formats that are
supported will provide results equivalent to their PHP versions.
The following is a list of all currently supported formats:

Format  Description                                                               Example returned values
------  -----------------------------------------------------------------------   -----------------------
  d     Day of the month, 2 digits with leading zeros                             01 to 31
  D     A short textual representation of the day of the week                     Mon to Sun
  j     Day of the month without leading zeros                                    1 to 31
  l     A full textual representation of the day of the week                      Sunday to Saturday
  N     ISO-8601 numeric representation of the day of the week                    1 (for Monday) through 7 (for Sunday)
  S     English ordinal suffix for the day of the month, 2 characters             st, nd, rd or th. Works well with j
  w     Numeric representation of the day of the week                             0 (for Sunday) to 6 (for Saturday)
  z     The day of the year (starting from 0)                                     0 to 364 (365 in leap years)
  W     ISO-8601 week number of year, weeks starting on Monday                    01 to 53
  F     A full textual representation of a month, such as January or March        January to December
  m     Numeric representation of a month, with leading zeros                     01 to 12
  M     A short textual representation of a month                                 Jan to Dec
  n     Numeric representation of a month, without leading zeros                  1 to 12
  t     Number of days in the given month                                         28 to 31
  L     Whether it's a leap year                                                  1 if it is a leap year, 0 otherwise.
  o     ISO-8601 year number (identical to (Y), but if the ISO week number (W)    Examples: 1998 or 2004
        belongs to the previous or next year, that year is used instead)
  Y     A full numeric representation of a year, 4 digits                         Examples: 1999 or 2003
  y     A two digit representation of a year                                      Examples: 99 or 03
  a     Lowercase Ante meridiem and Post meridiem                                 am or pm
  A     Uppercase Ante meridiem and Post meridiem                                 AM or PM
  g     12-hour format of an hour without leading zeros                           1 to 12
  G     24-hour format of an hour without leading zeros                           0 to 23
  h     12-hour format of an hour with leading zeros                              01 to 12
  H     24-hour format of an hour with leading zeros                              00 to 23
  i     Minutes, with leading zeros                                               00 to 59
  s     Seconds, with leading zeros                                               00 to 59
  u     Decimal fraction of a second                                              Examples:
        (minimum 1 digit, arbitrary number of digits allowed)                     001 (i.e. 0.001s) or
                                                                                  100 (i.e. 0.100s) or
                                                                                  999 (i.e. 0.999s) or
                                                                                  999876543210 (i.e. 0.999876543210s)
  O     Difference to Greenwich time (GMT) in hours and minutes                   Example: +1030
  P     Difference to Greenwich time (GMT) with colon between hours and minutes   Example: -08:00
  T     Timezone abbreviation of the machine running the code                     Examples: EST, MDT, PDT ...
  Z     Timezone offset in seconds (negative if west of UTC, positive if east)    -43200 to 50400
  c     ISO 8601 date
        Notes:                                                                    Examples:
        1) If unspecified, the month / day defaults to the current month / day,   1991 or
           the time defaults to midnight, while the timezone defaults to the      1992-10 or
           browser's timezone. If a time is specified, it must include both hours 1993-09-20 or
           and minutes. The &quot;T&quot; delimiter, seconds, milliseconds and timezone     1994-08-19T16:20+01:00 or
           are optional.                                                          1995-07-18T17:21:28-02:00 or
        2) The decimal fraction of a second, if specified, must contain at        1996-06-17T18:22:29.98765+03:00 or
           least 1 digit (there is no limit to the maximum number                 1997-05-16T19:23:30,12345-0400 or
           of digits allowed), and may be delimited by either a '.' or a ','      1998-04-15T20:24:31.2468Z or
        Refer to the examples on the right for the various levels of              1999-03-14T20:24:32Z or
        date-time granularity which are supported, or see                         2000-02-13T21:25:33
        http://www.w3.org/TR/NOTE-datetime for more info.                         2001-01-12 22:26:34
  U     Seconds since the Unix Epoch (January 1 1970 00:00:00 GMT)                1193432466 or -2138434463
  M$    Microsoft AJAX serialized dates                                           \/Date(1238606590509)\/ (i.e. UTC milliseconds since epoch) or
                                                                                  \/Date(1238606590509+0800)\/

Example usage (note that you must escape format specifiers with '\\' to render them as character literals):
// Sample date:
// 'Wed Jan 10 2007 15:05:01 GMT-0600 (Central Standard Time)'

var dt = new Date('1/10/2007 03:05:01 PM GMT-0600');
document.write(dt.format('Y-m-d'));                           // 2007-01-10
document.write(dt.format('F j, Y, g:i a'));                   // January 10, 2007, 3:05 pm
document.write(dt.format('l, \\t\\he jS \\of F Y h:i:s A'));  // Wednesday, the 10th of January 2007 03:05:01 PM
Here are some standard date/time patterns that you might find helpful.  They
are not part of the source of Date.js, but to use them you can simply copy this
block of code into any script that is included after Date.js and they will also become
globally available on the Date object.  Feel free to add or remove patterns as needed in your code.
Date.patterns = {
    ISO8601Long:&quot;Y-m-d H:i:s&quot;,
    ISO8601Short:&quot;Y-m-d&quot;,
    ShortDate: &quot;n/j/Y&quot;,
    LongDate: &quot;l, F d, Y&quot;,
    FullDateTime: &quot;l, F d, Y g:i:s A&quot;,
    MonthDay: &quot;F d&quot;,
    ShortTime: &quot;g:i A&quot;,
    LongTime: &quot;g:i:s A&quot;,
    SortableDateTime: &quot;Y-m-d\\TH:i:s&quot;,
    UniversalSortableDateTime: &quot;Y-m-d H:i:sO&quot;,
    YearMonth: &quot;F, Y&quot;
};
Example usage:
var dt = new Date();
document.write(dt.format(Date.patterns.ShortDate));
Developer-written, custom formats may be used by supplying both a formatting and a parsing function
which perform to specialized requirements. The functions are stored in parseFunctions and formatFunctions.</description><constructors/><properties/><methods><method name="add" scope="instance"><description>Provides a convenient method for performing basic date arithmetic. This method
does not modify the Date instance being called - it creates and returns
a new Date instance containing the resulting date value.
Examples:
// Basic usage:
var dt = new Date('10/29/2006').add(Date.DAY, 5);
document.write(dt); //returns 'Fri Nov 03 2006 00:00:00'

// Negative values will be subtracted:
var dt2 = new Date('10/1/2006').add(Date.DAY, -5);
document.write(dt2); //returns 'Tue Sep 26 2006 00:00:00'

// You can even chain several calls together in one line:
var dt3 = new Date('10/1/2006').add(Date.DAY, 5).add(Date.HOUR, 8).add(Date.MINUTE, -30);
document.write(dt3); //returns 'Fri Oct 06 2006 07:30:00'</description></method><method name="between" scope="instance"><description>Checks if this date falls on or between the given start and end dates.</description></method><method name="clearTime" scope="instance"><description>Attempts to clear all time information from this Date by setting the time to midnight of the same day,
automatically adjusting for Daylight Saving Time (DST) where applicable.
(note: DST timezone information for the browser's host operating system is assumed to be up-to-date)</description></method><method name="clone" scope="instance"><description>Creates and returns a new Date instance with the exact same date value as the called instance.
Dates are copied and passed by reference, so if a copied date variable is modified later, the original
variable will also be changed.  When the intention is to create a new variable that will not
modify the original instance, you should create a clone.
Example of correctly cloning a date:
//wrong way:
var orig = new Date('10/1/2006');
var copy = orig;
copy.setDate(5);
document.write(orig);  //returns 'Thu Oct 05 2006'!

//correct way:
var orig = new Date('10/1/2006');
var copy = orig.clone();
copy.setDate(5);
document.write(orig);  //returns 'Thu Oct 01 2006'</description></method><method name="format" scope="instance"><description>Formats a date given the supplied format string.</description></method><method name="getDayOfYear" scope="instance"><description>Get the numeric day number of the year, adjusted for leap year.</description></method><method name="getDaysInMonth" scope="instance"><description>Get the number of days in the current month, adjusted for leap year.</description></method><method name="getElapsed" scope="instance"><description>Returns the number of milliseconds between this date and date</description></method><method name="getFirstDateOfMonth" scope="instance"><description>Get the date of the first day of the month in which this date resides.</description></method><method name="getFirstDayOfMonth" scope="instance"><description>Get the first day of the current month, adjusted for leap year.  The returned value
is the numeric day index within the week (0-6) which can be used in conjunction with
the monthNames array to retrieve the textual day name.
Example:
var dt = new Date('1/10/2007');
document.write(Date.dayNames[dt.getFirstDayOfMonth()]); //output: 'Monday'</description></method><method name="getGMTOffset" scope="instance"><description>Get the offset from GMT of the current date (equivalent to the format specifier 'O').</description></method><method name="getLastDateOfMonth" scope="instance"><description>Get the date of the last day of the month in which this date resides.</description></method><method name="getLastDayOfMonth" scope="instance"><description>Get the last day of the current month, adjusted for leap year.  The returned value
is the numeric day index within the week (0-6) which can be used in conjunction with
the monthNames array to retrieve the textual day name.
Example:
var dt = new Date('1/10/2007');
document.write(Date.dayNames[dt.getLastDayOfMonth()]); //output: 'Wednesday'</description></method><method name="getMonthNumber" scope="instance"><description>Get the zero-based javascript month number for the given short/full month name.
Override this function for international dates.</description></method><method name="getShortDayName" scope="instance"><description>Get the short day name for the given day number.
Override this function for international dates.</description></method><method name="getShortMonthName" scope="instance"><description>Get the short month name for the given month number.
Override this function for international dates.</description></method><method name="getSuffix" scope="instance"><description>Get the English ordinal suffix of the current day (equivalent to the format specifier 'S').</description></method><method name="getTimezone" scope="instance"><description>Get the timezone abbreviation of the current date (equivalent to the format specifier 'T').
Note: The date string returned by the javascript Date object's toString() method varies
between browsers (e.g. FF vs IE) and system region settings (e.g. IE in Asia vs IE in America).
For a given date string e.g. &quot;Thu Oct 25 2007 22:55:35 GMT+0800 (Malay Peninsula Standard Time)&quot;,
getTimezone() first tries to get the timezone abbreviation from between a pair of parentheses
(which may or may not be present), failing which it proceeds to get the timezone abbreviation
from the GMT offset portion of the date string.</description></method><method name="getWeekOfYear" scope="instance"><description>Get the numeric ISO-8601 week number of the year.
(equivalent to the format specifier 'W', but without a leading zero).</description></method><method name="isDST" scope="instance"><description>Checks if the current date is affected by Daylight Saving Time (DST).</description></method><method name="isLeapYear" scope="instance"><description>Checks if the current date falls within a leap year.</description></method><method name="isValid" scope="instance"><description>Checks if the passed Date parameters will cause a javascript Date &quot;rollover&quot;.</description></method><method name="parseDate" scope="instance"><description>Parses the passed string using the specified date format.
Note that this function expects normal calendar dates, meaning that months are 1-based (i.e. 1 = January).
The defaults hash will be used for any date value (i.e. year, month, day, hour, minute, second or millisecond)
which cannot be found in the passed string. If a corresponding default date value has not been specified in the defaults hash,
the current date's year, month, day or DST-adjusted zero-hour time value will be used instead.
Keep in mind that the input date string must precisely match the specified format string
in order for the parse operation to be successful (failed parse operations return a null value).
Example://dt = Fri May 25 2007 (current date)
var dt = new Date();

//dt = Thu May 25 2006 (today&#39;s month/day in 2006)
dt = Date.parseDate(&quot;2006&quot;, &quot;Y&quot;);

//dt = Sun Jan 15 2006 (all date parts specified)
dt = Date.parseDate(&quot;2006-01-15&quot;, &quot;Y-m-d&quot;);

//dt = Sun Jan 15 2006 15:20:01
dt = Date.parseDate(&quot;2006-01-15 3:20:01 PM&quot;, &quot;Y-m-d g:i:s A&quot;);

// attempt to parse Sun Feb 29 2006 03:20:01 in strict mode
dt = Date.parseDate(&quot;2006-02-29 03:20:01&quot;, &quot;Y-m-d H:i:s&quot;, true); // returns null</description></method></methods></class><class superclass="Ext.BoxComponent" type="Ext.form.Field"><description>Base class for form fields that provides default event handling, sizing, value handling and other functionality.</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="clearInvalid" scope="instance"><description>Clear any invalid styles/messages for this field</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getActiveError" scope="instance"><description>Gets the active error message for this field.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getErrors" scope="instance"><description>Runs this field's validators and returns an array of error messages for any validation failures.
This is called internally during validation and would not usually need to be used manually.
Each subclass should override or augment the return value to provide their own errors</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getName" scope="instance"><description>Returns the name or hiddenName
attribute of the field if available.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getRawValue" scope="instance"><description>Returns the raw data value which may or may not be a valid, defined value.  To return a normalized value see getValue.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getValue" scope="instance"><description>Returns the normalized data value (undefined or emptyText will be returned as '').  To return the raw value see getRawValue.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isDirty" scope="instance"><description>Returns true if the value of this Field has been changed from its original value.
Will return false if the field is disabled or has not been rendered yet.
Note that if the owning form was configured with
Ext.form.BasicForm.trackResetOnLoad
then the original value is updated when the values are loaded by
Ext.form.BasicForm.setValues.</description></method><method name="isValid" scope="instance"><description>Returns whether or not the field value is currently valid by
validating the processed value
of the field. Note: disabled fields are ignored.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="markInvalid" scope="instance"><description>Display an error message associated with this field, using msgTarget to determine how to
display the message and applying invalidClass to the field's UI element.
Note: this method does not cause the Field's validate method to return false
if the value does pass validation. So simply marking a Field as invalid will not prevent
submission of forms submitted with the Ext.form.Action.Submit.clientValidation option set.
invalid.</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="processValue" scope="instance"><description>This method should only be overridden if necessary to prepare raw values
for validation (see validate and isValid).  This method
is expected to return the processed value for the field which will
be used for validation (see validateValue method).</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="reset" scope="instance"><description>Resets the current field value to the originally loaded value and clears any validation messages.
See Ext.form.BasicForm.trackResetOnLoad</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setActiveError" scope="instance"><description>Sets the current activeError to the given string. Fires the 'invalid' event.
This does not set up the error icon, only sets the message and fires the event. To show the error icon,
use markInvalid instead, which calls this method internally</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setRawValue" scope="instance"><description>Sets the underlying DOM field's value directly, bypassing validation.  To set the value with validation see setValue.</description></method><method name="setReadOnly" scope="instance"><description>Sets the read only state of this field.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setValue" scope="instance"><description>Sets a data value into the field and validates it.  To set the value directly without validation see setRawValue.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="unsetActiveError" scope="instance"><description>Clears the activeError and fires the 'valid' event. This is called internally by clearInvalid and would not
usually need to be called manually</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method><method name="validate" scope="instance"><description>Validates the field value</description></method><method name="validateValue" scope="instance"><description>Uses getErrors to build an array of validation errors. If any errors are found, markInvalid is called
with the first and false is returned, otherwise true is returned. Previously, subclasses were invited
to provide an implementation of this to process validations - from 3.2 onwards getErrors should be
overridden instead.</description></method></methods></class><class superclass="Ext.form.Field" type="Ext.form.TextField"><description>Basic text field.  Can be used as a direct replacement for traditional text inputs,
or as the base class for more sophisticated input controls (like Ext.form.TextArea
and Ext.form.ComboBox).
Validation
The validation procedure is described in the documentation for validateValue.
Alter Validation Behavior
Validation behavior for each field can be configured:

invalidText : the default validation message to
show if any validation step above does not provide a message when invalid
maskRe : filter out keystrokes before any validation occurs
stripCharsRe : filter characters after being typed in,
but before being validated
invalidClass : alternate style when invalid
validateOnBlur,
validationDelay, and
validationEvent : modify how/when validation is triggered
</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="autoSize" scope="instance"><description>Automatically grows the field to accomodate the width of the text up to the maximum field width allowed.
This only takes effect if grow = true, and fires the autosize event.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="clearInvalid" scope="instance"><description>Clear any invalid styles/messages for this field</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getActiveError" scope="instance"><description>Gets the active error message for this field.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getErrors" scope="instance"><description>Validates a value according to the field's validation rules and returns an array of errors
for any failing validations. Validation rules are processed in the following order:

1. Field specific validator

A validator offers a way to customize and reuse a validation specification.
If a field is configured with a validator
function, it will be passed the current field value.  The validator
function is expected to return either:

Boolean true if the value is valid (validation continues).
a String to represent the invalid message if invalid (validation halts).


2. Basic Validation

If the validator has not halted validation,
basic validation proceeds as follows:

allowBlank : (Invalid message =
emptyText)
Depending on the configuration of allowBlank, a
blank field will cause validation to halt at this step and return
Boolean true or false accordingly.  

minLength : (Invalid message =
minLengthText)
If the passed value does not satisfy the minLength
specified, validation halts.

maxLength : (Invalid message =
maxLengthText)
If the passed value does not satisfy the maxLength
specified, validation halts.



3. Preconfigured Validation Types (VTypes)

If none of the prior validation steps halts validation, a field
configured with a vtype will utilize the
corresponding VTypes validation function.
If invalid, either the field's vtypeText or
the VTypes vtype Text property will be used for the invalid message.
Keystrokes on the field will be filtered according to the VTypes
vtype Mask property.

4. Field specific regex test

If none of the prior validation steps halts validation, a field's
configured regex test will be processed.
The invalid message for this test is configured with
regexText.
</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getName" scope="instance"><description>Returns the name or hiddenName
attribute of the field if available.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getRawValue" scope="instance"><description>Returns the raw data value which may or may not be a valid, defined value.  To return a normalized value see getValue.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getValue" scope="instance"><description>Returns the normalized data value (undefined or emptyText will be returned as '').  To return the raw value see getRawValue.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isDirty" scope="instance"><description>Returns true if the value of this Field has been changed from its original value.
Will return false if the field is disabled or has not been rendered yet.
Note that if the owning form was configured with
Ext.form.BasicForm.trackResetOnLoad
then the original value is updated when the values are loaded by
Ext.form.BasicForm.setValues.</description></method><method name="isValid" scope="instance"><description>Returns whether or not the field value is currently valid by
validating the processed value
of the field. Note: disabled fields are ignored.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="markInvalid" scope="instance"><description>Display an error message associated with this field, using msgTarget to determine how to
display the message and applying invalidClass to the field's UI element.
Note: this method does not cause the Field's validate method to return false
if the value does pass validation. So simply marking a Field as invalid will not prevent
submission of forms submitted with the Ext.form.Action.Submit.clientValidation option set.
invalid.</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="processValue" scope="instance"><description>This method should only be overridden if necessary to prepare raw values
for validation (see validate and isValid).  This method
is expected to return the processed value for the field which will
be used for validation (see validateValue method).</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="reset" scope="instance"><description>Resets the current field value to the originally-loaded value and clears any validation messages.
Also adds emptyText and emptyClass if the
original value was blank.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="selectText" scope="instance"><description>Selects text in this field</description></method><method name="setActiveError" scope="instance"><description>Sets the current activeError to the given string. Fires the 'invalid' event.
This does not set up the error icon, only sets the message and fires the event. To show the error icon,
use markInvalid instead, which calls this method internally</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setRawValue" scope="instance"><description>Sets the underlying DOM field's value directly, bypassing validation.  To set the value with validation see setValue.</description></method><method name="setReadOnly" scope="instance"><description>Sets the read only state of this field.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setValue" scope="instance"><description>Sets a data value into the field and validates it.  To set the value directly without validation see setRawValue.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="unsetActiveError" scope="instance"><description>Clears the activeError and fires the 'valid' event. This is called internally by clearInvalid and would not
usually need to be called manually</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method><method name="validate" scope="instance"><description>Validates the field value</description></method><method name="validateValue" scope="instance"><description>Uses getErrors to build an array of validation errors. If any errors are found, markInvalid is called
with the first and false is returned, otherwise true is returned. Previously, subclasses were invited
to provide an implementation of this to process validations - from 3.2 onwards getErrors should be
overridden instead.</description></method></methods></class><class superclass="Object" type="Ext.menu.MenuMgr"><description>Provides a common registry of all menu items on a page so that they can be easily accessed by id.</description><constructors/><properties/><methods><method name="get" scope="instance"><description>Returns a Ext.menu.Menu object</description></method><method name="hideAll" scope="instance"><description>Hides all menus that are currently visible</description></method></methods></class><class superclass="Ext.menu.BaseItem" type="Ext.menu.TextItem"><description>Adds a static text string to a menu, usually used as either a heading or group separator.</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHandler" scope="instance"><description>Sets the function that will handle click events for this item (equivalent to passing in the handler
config property).  If an existing handler is already registered, it will be unregistered for you.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method></methods></class><class superclass="Object" type="Ext.data.Api"><description>Ext.data.Api is a singleton designed to manage the data API including methods
for validating a developer's DataProxy API.  Defines variables for CRUD actions
create, read, update and destroy in addition to a mapping of RESTful HTTP methods
GET, POST, PUT and DELETE to CRUD actions.</description><constructors/><properties/><methods><method name="Response" scope="instance"><description>Ext.data.Response
Experimental.  Do not use directly.</description></method><method name="getVerb" scope="instance"><description>Returns the actual CRUD action KEY &quot;create&quot;, &quot;read&quot;, &quot;update&quot; or &quot;destroy&quot; from the supplied action-name.  This method is used internally and shouldn't generally
need to be used directly.  The key/value pair of Ext.data.Api.actions will often be identical but this is not necessarily true.  A developer can override this naming
convention if desired.  However, the framework internally calls methods based upon the KEY so a way of retreiving the the words &quot;create&quot;, &quot;read&quot;, &quot;update&quot; and &quot;destroy&quot; is
required.  This method will cache discovered KEYS into the private validActions hash.</description></method><method name="hasUniqueUrl" scope="instance"><description>Returns true if the supplied verb upon the supplied proxy points to a unique url in that none of the other api-actions
point to the same url.  The question is important for deciding whether to insert the &quot;xaction&quot; HTTP parameter within an
Ajax request.  This method is used internally and shouldn't generally need to be called directly.</description></method><method name="isAction" scope="instance"><description>Returns true if supplied action-name is a valid API action defined in actions constants</description></method><method name="isValid" scope="instance"><description>Returns true if the supplied API is valid; that is, check that all keys match defined actions
otherwise returns an array of mistakes.</description></method><method name="prepare" scope="instance"><description>This method is used internally by DataProxy and should not generally need to be used directly.
Each action of a DataProxy api can be initially defined as either a String or an Object.  When specified as an object,
one can explicitly define the HTTP method (GET|POST) to use for each CRUD action.  This method will prepare the supplied API, setting
each action to the Object form.  If your API-actions do not explicitly define the HTTP method, the &quot;method&quot; configuration-parameter will
be used.  If the method configuration parameter is not specified, POST will be used.
         new Ext.data.HttpProxy({
    method: &quot;POST&quot;,     // &lt;-- default HTTP method when not specified.
    api: {
        create: 'create.php',
        load: 'read.php',
        save: 'save.php',
        destroy: 'destroy.php'
    }
});

// Alternatively, one can use the object-form to specify the API
new Ext.data.HttpProxy({
    api: {
        load: {url: 'read.php', method: 'GET'},
        create: 'create.php',
        destroy: 'destroy.php',
        save: 'update.php'
    }
});</description></method><method name="restify" scope="instance"><description>Prepares a supplied Proxy to be RESTful.  Sets the HTTP method for each api-action to be one of
GET, POST, PUT, DELETE according to the defined restActions.</description></method></methods></class><class superclass="Ext.util.Observable" type="Ext.data.Store"><description>The Store class encapsulates a client side cache of Record
objects which provide input data for Components such as the GridPanel,
the ComboBox, or the DataView.
Retrieving Data
A Store object may access a data object using:
configured implementation of DataProxy
data to automatically pass in data
loadData to manually pass in data

Reading Data
A Store object has no inherent knowledge of the format of the data object (it could be
an Array, XML, or JSON). A Store object uses an appropriate configured implementation
of a DataReader to create Record instances from the data
object.
Store Types
There are several implementations of Store available which are customized for use with
a specific DataReader implementation.  Here is an example using an ArrayStore which implicitly
creates a reader commensurate to an Array data object.
var myStore = new Ext.data.ArrayStore({
    fields: ['fullname', 'first'],
    idIndex: 0 // id for each record will be the first element
});
For custom implementations create a basic Ext.data.Store configured as needed:
// create a Record constructor:
var rt = Ext.data.Record.create([
    {name: 'fullname'},
    {name: 'first'}
]);
var myStore = new Ext.data.Store({
    // explicitly create reader
    reader: new Ext.data.ArrayReader(
        {
            idIndex: 0  // id for each record will be the first element
        },
        rt // recordType
    )
});
Load some data into store (note the data object is an array which corresponds to the reader):
var myData = [
    [1, 'Fred Flintstone', 'Fred'],  // note that id for the record is the first element
    [2, 'Barney Rubble', 'Barney']
];
myStore.loadData(myData);
Records are cached and made available through accessor functions.  An example of adding
a record to the store:
var defaultData = {
    fullname: 'Full Name',
    first: 'First Name'
};
var recId = 100; // provide unique id for the record
var r = new myStore.recordType(defaultData, ++recId); // create new record
myStore.insert(0, r); // insert a new record into the store (also see add)
Writing Data
And new in Ext version 3, use the new DataWriter to create an automated, Writable Store
along with RESTful features.</description><constructors/><properties/><methods><method name="add" scope="instance"><description>Add Records to the Store and fires the add event.  To add Records
to the store from a remote source use load({add:true}).
See also recordType and insert.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="addSorted" scope="instance"><description>(Local sort only) Inserts the passed Record into the Store at the index where it
should go based on the current sort information.</description></method><method name="clearFilter" scope="instance"><description>Revert to a view of the Record cache with no filtering applied.</description></method><method name="collect" scope="instance"><description>Collects unique values for a particular dataIndex from this store.</description></method><method name="commitChanges" scope="instance"><description>Commit all Records with outstanding changes. To handle updates for changes,
subscribe to the Store's update event, and perform updating when the third parameter is
Ext.data.Record.COMMIT.</description></method><method name="destroy" scope="instance"><description>Destroys the store.</description></method><method name="each" scope="instance"><description>Calls the specified function for each of the Records in the cache.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="filter" scope="instance"><description>Filter the records by a specified property. Alternatively, pass an array of filter
options to filter by more than one property.
Single filter example:
store.filter('name', 'Ed', true, true); //finds all records containing the substring 'Ed'
Multiple filter example:
store.filter([
{
property     : 'name',
value        : 'Ed',
anyMatch     : true, //optional, defaults to true
caseSensitive: true  //optional, defaults to true
},
//filter functions can also be passed
{
fn   : function(record) {
return record.get('age') == 24
},
scope: this
}
]);</description></method><method name="filterBy" scope="instance"><description>Filter by a function. The specified function will be called for each
Record in this Store. If the function returns true the Record is included,
otherwise it is filtered out.</description></method><method name="find" scope="instance"><description>Finds the index of the first matching Record in this store by a specific field value.</description></method><method name="findBy" scope="instance"><description>Find the index of the first matching Record in this Store by a function.
If the function returns true it is considered a match.</description></method><method name="findExact" scope="instance"><description>Finds the index of the first matching Record in this store by a specific field value.</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="getAt" scope="instance"><description>Get the Record at the specified index.</description></method><method name="getById" scope="instance"><description>Get the Record with the specified id.</description></method><method name="getCount" scope="instance"><description>Gets the number of cached records.
If using paging, this may not be the total size of the dataset. If the data object
used by the Reader contains the dataset size, then the getTotalCount function returns
the dataset size.  Note: see the Important note in load.</description></method><method name="getModifiedRecords" scope="instance"><description>Gets all records modified since the last commit.  Modified records are
persisted across load operations (e.g., during paging). Note: deleted records are not
included.  See also pruneModifiedRecords and
Ext.data.RecordmarkDirty..</description></method><method name="getRange" scope="instance"><description>Returns a range of Records between specified indices.</description></method><method name="getSortState" scope="instance"><description>Returns an object describing the current sort state of this Store.</description></method><method name="getTotalCount" scope="instance"><description>Gets the total number of records in the dataset as returned by the server.
If using paging, for this to be accurate, the data object used by the Reader
must contain the dataset size. For remote data sources, the value for this property
(totalProperty for JsonReader,
totalRecords for XmlReader) shall be returned by a query on the server.
Note: see the Important note in load.</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="indexOf" scope="instance"><description>Get the index within the cache of the passed Record.</description></method><method name="indexOfId" scope="instance"><description>Get the index within the cache of the Record with the passed id.</description></method><method name="insert" scope="instance"><description>Inserts Records into the Store at the given index and fires the add event.
See also add and addSorted.</description></method><method name="isFiltered" scope="instance"><description>Returns true if this store is currently filtered</description></method><method name="load" scope="instance"><description>Loads the Record cache from the configured proxy using the configured reader.
Notes:
Important: loading is asynchronous! This call will return before the new data has been
loaded. To perform any post-processing where information from the load call is required, specify
the callback function to be called, or use a a 'load' event handler.
If using remote paging, the first load call must specify the start and limit
properties in the options.params property to establish the initial position within the
dataset, and the number of Records to cache on each read from the Proxy.
If using remote sorting, the configured sortInfo
will be automatically included with the posted parameters according to the specified
paramNames.
</description></method><method name="loadData" scope="instance"><description>Loads data from a passed data block and fires the load event. A Reader
which understands the format of the data must have been configured in the constructor.</description></method><method name="multiSort" scope="instance"><description>Sorts the contents of this store by multiple field/direction sorters. This is called internally by sort
and would not usually be called manually.
Multi sorting only currently applies to local datasets - multiple sort data is not currently sent to a proxy
if remoteSort is used.</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="query" scope="instance"><description>Query the records by a specified property.</description></method><method name="queryBy" scope="instance"><description>Query the cached records in this Store using a filtering function. The specified function
will be called with each record in this Store. If the function returns true the record is
included in the results.</description></method><method name="rejectChanges" scope="instance"><description>Reject outstanding changes on all modified records.</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="reload" scope="instance"><description>Reloads the Record cache from the configured Proxy using the configured
Reader and the options from the last load operation
performed.
Note: see the Important note in load.</description></method><method name="remove" scope="instance"><description>Remove Records from the Store and fires the remove event.</description></method><method name="removeAll" scope="instance"><description>Remove all Records from the Store and fires the clear event.</description></method><method name="removeAt" scope="instance"><description>Remove a Record from the Store at the specified index. Fires the remove event.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="save" scope="instance"><description>Saves all pending changes to the store.  If the commensurate Ext.data.Api.actions action is not configured, then
the configured url will be used.

change            url
---------------   --------------------
removed records   Ext.data.Api.actions.destroy
phantom records   Ext.data.Api.actions.create
modified records  Ext.data.Api.actions.update
</description></method><method name="setBaseParam" scope="instance"><description>Set the value for a property name in this store's baseParams.  Usage:myStore.setBaseParam('foo', {bar:3});</description></method><method name="setDefaultSort" scope="instance"><description>Sets the default sort column and order to be used by the next load operation.</description></method><method name="singleSort" scope="instance"><description>Sorts the store contents by a single field and direction. This is called internally by sort and would
not usually be called manually</description></method><method name="sort" scope="instance"><description>Sort the Records.
If remote sorting is used, the sort is performed on the server, and the cache is reloaded. If local
sorting is used, the cache is sorted internally. See also remoteSort and paramNames.
This function accepts two call signatures - pass in a field name as the first argument to sort on a single
field, or pass in an array of sort configuration objects to sort by multiple fields.
Single sort example:
store.sort('name', 'ASC');
Multi sort example:
store.sort([
{
field    : 'name',
direction: 'ASC'
},
{
field    : 'salary',
direction: 'DESC'
}
], 'ASC');
In this second form, the sort configs are applied in order, with later sorters sorting within earlier sorters' results.
For example, if two records with the same name are present they will also be sorted by salary if given the sort configs
above. Any number of sort configs can be added.</description></method><method name="sum" scope="instance"><description>Sums the value of property for each record between start
and end and returns the result.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method></methods></class><class superclass="Ext.layout.ContainerLayout" type="Ext.layout.AnchorLayout"><description>This is a layout that enables anchoring of contained elements relative to the container's dimensions.
If the container is resized, all anchored items are automatically rerendered according to their
anchor rules.
This class is intended to be extended or created via the layout:'anchor' Ext.Container.layout
config, and should generally not need to be created directly via the new keyword.
AnchorLayout does not have any direct config options (other than inherited ones). By default,
AnchorLayout will calculate anchor measurements based on the size of the container itself. However, the
container using the AnchorLayout can supply an anchoring-specific config property of anchorSize.
If anchorSize is specifed, the layout will use it as a virtual container for the purposes of calculating
anchor measurements based on it instead, allowing the container to be sized independently of the anchoring
logic if necessary.  For example:
var viewport = new Ext.Viewport({
    layout:'anchor',
    anchorSize: {width:800, height:600},
    items:[{
        title:'Item 1',
        html:'Content 1',
        width:800,
        anchor:'right 20%'
    },{
        title:'Item 2',
        html:'Content 2',
        width:300,
        anchor:'50% 30%'
    },{
        title:'Item 3',
        html:'Content 3',
        width:600,
        anchor:'-100 50%'
    }]
});</description><constructors/><properties/><methods><method name="parseMargins" scope="instance"><description>Parses a number or string representing margin sizes into an object. Supports CSS-style margin declarations
(e.g. 10, &quot;10&quot;, &quot;10 10&quot;, &quot;10 10 10&quot; and &quot;10 10 10 10&quot; are all valid options and would return the same result)</description></method></methods></class><class superclass="Ext.layout.BoxLayout" type="Ext.layout.VBoxLayout"><description>A layout that arranges items vertically down a Container. This layout optionally divides available vertical
space between child items containing a numeric flex configuration.
This layout may also be used to set the widths of child items by configuring it with the align option.</description><constructors/><properties/><methods><method name="parseMargins" scope="instance"><description>Parses a number or string representing margin sizes into an object. Supports CSS-style margin declarations
(e.g. 10, &quot;10&quot;, &quot;10 10&quot;, &quot;10 10 10&quot; and &quot;10 10 10 10&quot; are all valid options and would return the same result)</description></method><method name="updateChildBoxes" scope="instance"><description>Resizes and repositions each child component</description></method></methods></class><class superclass="Ext.form.Action.Submit" type="Ext.form.Action.DirectSubmit"><description>Provides Ext.direct support for submitting form data.
This example illustrates usage of Ext.Direct to submit a form through Ext.Direct.
var myFormPanel = new Ext.form.FormPanel({
    // configs for FormPanel
    title: 'Basic Information',
    renderTo: document.body,
    width: 300, height: 160,
    padding: 10,
    buttons:[{
        text: 'Submit',
        handler: function(){
            myFormPanel.getForm().submit({
                params: {
                    foo: 'bar',
                    uid: 34
                }
            });
        }
    }],

    // configs apply to child items
    defaults: {anchor: '100%'},
    defaultType: 'textfield',
    items: [{
        fieldLabel: 'Name',
        name: 'name'
    },{
        fieldLabel: 'Email',
        name: 'email'
    },{
        fieldLabel: 'Company',
        name: 'company'
    }],

    // configs for BasicForm
    api: {
        // The server-side method to call for load() requests
        load: Profile.getBasicInfo,
        // The server-side must mark the submit handler as a 'formHandler'
        submit: Profile.updateBasicInfo
    },
    // specify the order for the passed params
    paramOrder: ['uid', 'foo']
});
The data packet sent to the server will resemble something like:
{
    &quot;action&quot;:&quot;Profile&quot;,&quot;method&quot;:&quot;updateBasicInfo&quot;,&quot;type&quot;:&quot;rpc&quot;,&quot;tid&quot;:&quot;6&quot;,
    &quot;result&quot;:{
        &quot;success&quot;:true,
        &quot;id&quot;:{
            &quot;extAction&quot;:&quot;Profile&quot;,&quot;extMethod&quot;:&quot;updateBasicInfo&quot;,
            &quot;extType&quot;:&quot;rpc&quot;,&quot;extTID&quot;:&quot;6&quot;,&quot;extUpload&quot;:&quot;false&quot;,
            &quot;name&quot;:&quot;Aaron Conran&quot;,&quot;email&quot;:&quot;aaron@extjs.com&quot;,&quot;company&quot;:&quot;Ext JS, LLC&quot;
        }
    }
}
The form will process a data packet returned by the server that is similar
to the following:
// sample success packet (batched requests)
[
    {
        &quot;action&quot;:&quot;Profile&quot;,&quot;method&quot;:&quot;updateBasicInfo&quot;,&quot;type&quot;:&quot;rpc&quot;,&quot;tid&quot;:3,
        &quot;result&quot;:{
            &quot;success&quot;:true
        }
    }
]

// sample failure packet (one request)
{
        &quot;action&quot;:&quot;Profile&quot;,&quot;method&quot;:&quot;updateBasicInfo&quot;,&quot;type&quot;:&quot;rpc&quot;,&quot;tid&quot;:&quot;6&quot;,
        &quot;result&quot;:{
            &quot;errors&quot;:{
                &quot;email&quot;:&quot;already taken&quot;
            },
            &quot;success&quot;:false,
            &quot;foo&quot;:&quot;bar&quot;
        }
}
Also see the discussion in Ext.form.Action.DirectLoad.</description><constructors/><properties/><methods/></class><class superclass="Ext.util.Observable" type="Ext.tree.TreeLoader"><description>A TreeLoader provides for lazy loading of an Ext.tree.TreeNode's child
nodes from a specified URL. The response must be a JavaScript Array definition
whose elements are node definition objects. e.g.:
[{
        id: 1,
        text: 'A leaf Node',
        leaf: true
    },{
        id: 2,
        text: 'A folder Node',
        children: [{
            id: 3,
            text: 'A child Node',
            leaf: true
        }]
   }]

A server request is sent, and child nodes are loaded only when a node is expanded.
The loading node's id is passed to the server under the parameter name &quot;node&quot; to
enable the server to produce the correct child nodes.

To pass extra parameters, an event handler may be attached to the &quot;beforeload&quot;
event, and the parameters specified in the TreeLoader's baseParams property:
myTreeLoader.on(&quot;beforeload&quot;, function(treeLoader, node) {
        this.baseParams.category = node.attributes.category;
    }, this);
This would pass an HTTP parameter called &quot;category&quot; to the server containing
the value of the Node's &quot;category&quot; attribute.</description><constructors/><properties/><methods><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="createNode" scope="instance"><description>Override this function for custom TreeNode node implementation, or to
modify the attributes at creation time.
Example:new Ext.tree.TreePanel({
    ...
    loader: new Ext.tree.TreeLoader({
        url: 'dataUrl',
        createNode: function(attr) {
//          Allow consolidation consignments to have
//          consignments dropped into them.
            if (attr.isConsolidation) {
                attr.iconCls = 'x-consol',
                attr.allowDrop = true;
            }
            return Ext.tree.TreeLoader.prototype.createNode.call(this, attr);
        }
    }),
    ...
});</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="load" scope="instance"><description>Load an Ext.tree.TreeNode from the URL specified in the constructor.
This is called automatically when a node is expanded, but may be used to reload
a node (or append new children if the clearOnLoad option is false.)</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method></methods></class><class superclass="Ext.form.Field" type="Ext.form.HtmlEditor"><description>Provides a lightweight HTML Editor component. Some toolbar features are not supported by Safari and will be
automatically hidden when needed.  These are noted in the config options where appropriate.
The editor's toolbar buttons have tooltips defined in the buttonTips property, but they are not
enabled by default unless the global Ext.QuickTips singleton is initialized.
Note: The focus/blur and validation marking functionality inherited from Ext.form.Field is NOT
supported by this editor.
An Editor is a sensitive component that can't be used in all spots standard fields can be used. Putting an Editor within
any element that has display set to 'none' can cause problems in Safari and Firefox due to their default iframe reloading bugs.
Example usage:
// Simple example rendered with default options:
Ext.QuickTips.init();  // enable tooltips
new Ext.form.HtmlEditor({
    renderTo: Ext.getBody(),
    width: 800,
    height: 300
});

// Passed via xtype into a container and with custom options:
Ext.QuickTips.init();  // enable tooltips
new Ext.Panel({
    title: 'HTML Editor',
    renderTo: Ext.getBody(),
    width: 600,
    height: 300,
    frame: true,
    layout: 'fit',
    items: {
        xtype: 'htmleditor',
        enableColors: false,
        enableAlignments: false
    }
});</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cleanHtml" scope="instance"><description>Protected method that will not generally be called directly. If you need/want
custom HTML cleanup, this is the method you should override.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="execCmd" scope="instance"><description>Executes a Midas editor command directly on the editor document.
For visual commands, you should use relayCmd instead.
This should only be called after the editor is initialized.</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getActiveError" scope="instance"><description>Gets the active error message for this field.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getDocMarkup" scope="instance"><description>Protected method that will not generally be called directly. It
is called when the editor initializes the iframe with HTML contents. Override this method if you
want to change the initialization markup of the iframe (e.g. to add stylesheets).
Note: IE8-Standards has unwanted scroller behavior, so the default meta tag forces IE7 compatibility</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getErrors" scope="instance"><description>Runs this field's validators and returns an array of error messages for any validation failures.
This is called internally during validation and would not usually need to be used manually.
Each subclass should override or augment the return value to provide their own errors</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getName" scope="instance"><description>Returns the name or hiddenName
attribute of the field if available.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getRawValue" scope="instance"><description>Returns the raw data value which may or may not be a valid, defined value.  To return a normalized value see getValue.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getToolbar" scope="instance"><description>Returns the editor's toolbar. This is only available after the editor has been rendered.</description></method><method name="getValue" scope="instance"><description>Returns the normalized data value (undefined or emptyText will be returned as '').  To return the raw value see getRawValue.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="insertAtCursor" scope="instance"><description>Inserts the passed text at the current cursor position. Note: the editor must be initialized and activated
to insert text.</description></method><method name="isDirty" scope="instance"><description>Returns true if the value of this Field has been changed from its original value.
Will return false if the field is disabled or has not been rendered yet.
Note that if the owning form was configured with
Ext.form.BasicForm.trackResetOnLoad
then the original value is updated when the values are loaded by
Ext.form.BasicForm.setValues.</description></method><method name="isValid" scope="instance"><description>Returns whether or not the field value is currently valid by
validating the processed value
of the field. Note: disabled fields are ignored.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="processValue" scope="instance"><description>This method should only be overridden if necessary to prepare raw values
for validation (see validate and isValid).  This method
is expected to return the processed value for the field which will
be used for validation (see validateValue method).</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="pushValue" scope="instance"><description>Protected method that will not generally be called directly. Pushes the value of the textarea
into the iframe editor.</description></method><method name="relayCmd" scope="instance"><description>Executes a Midas editor command on the editor document and performs necessary focus and
toolbar updates. This should only be called after the editor is initialized.</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="reset" scope="instance"><description>Resets the current field value to the originally loaded value and clears any validation messages.
See Ext.form.BasicForm.trackResetOnLoad</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setActiveError" scope="instance"><description>Sets the current activeError to the given string. Fires the 'invalid' event.
This does not set up the error icon, only sets the message and fires the event. To show the error icon,
use markInvalid instead, which calls this method internally</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setRawValue" scope="instance"><description>Sets the underlying DOM field's value directly, bypassing validation.  To set the value with validation see setValue.</description></method><method name="setReadOnly" scope="instance"><description>Sets the read only state of this field.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setValue" scope="instance"><description>Sets a data value into the field and validates it.  To set the value directly without validation see setRawValue.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="syncValue" scope="instance"><description>Protected method that will not generally be called directly. Syncs the contents
of the editor iframe with the textarea.</description></method><method name="toggleSourceEdit" scope="instance"><description>Toggles the editor between standard and source edit mode.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="unsetActiveError" scope="instance"><description>Clears the activeError and fires the 'valid' event. This is called internally by clearInvalid and would not
usually need to be called manually</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method><method name="updateToolbar" scope="instance"><description>Protected method that will not generally be called directly. It triggers
a toolbar update by reading the markup state of the current selection in the editor.</description></method><method name="validateValue" scope="instance"><description>Uses getErrors to build an array of validation errors. If any errors are found, markInvalid is called
with the first and false is returned, otherwise true is returned. Previously, subclasses were invited
to provide an implementation of this to process validations - from 3.2 onwards getErrors should be
overridden instead.</description></method></methods></class><class superclass="Ext.BoxComponent" type="Ext.ProgressBar"><description>An updateable progress bar component.  The progress bar supports two different modes: manual and automatic.
In manual mode, you are responsible for showing, updating (via updateProgress) and clearing the
progress bar as needed from your own code.  This method is most appropriate when you want to show progress
throughout an operation that has predictable points of interest at which you can update the control.
In automatic mode, you simply call wait and let the progress bar run indefinitely, only clearing it
once the operation is complete.  You can optionally have the progress bar wait for a specific amount of time
and then clear itself.  Automatic mode is most appropriate for timed operations or asynchronous operations in
which you have no need for indicating intermediate progress.</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isWaiting" scope="instance"><description>Returns true if the progress bar is currently in a wait operation</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="reset" scope="instance"><description>Resets the progress bar value to 0 and text to empty string.  If hide = true, the progress
bar will also be hidden (using the hideMode property internally).</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setSize" scope="instance"><description>Sets the size of the progress bar.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncProgressBar" scope="instance"><description>Synchronizes the inner bar width to the proper proportion of the total componet width based
on the current progress value.  This will be called automatically when the ProgressBar
is resized by a layout, but if it is rendered auto width, this method can be called from
another resize handler to sync the ProgressBar if necessary.</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method><method name="updateProgress" scope="instance"><description>Updates the progress bar value, and optionally its text.  If the text argument is not specified,
any existing text value will be unchanged.  To blank out existing text, pass ''.  Note that even
if the progress bar value exceeds 1, it will never automatically reset -- you are responsible for
determining when the progress is complete and calling reset to clear and/or hide the control.</description></method><method name="updateText" scope="instance"><description>Updates the progress bar text.  If specified, textEl will be updated, otherwise the progress
bar itself will display the updated text.</description></method><method name="wait" scope="instance"><description>Initiates an auto-updating progress bar.  A duration can be specified, in which case the progress
bar will automatically reset after a fixed amount of time and optionally call a callback function
if specified.  If no duration is passed in, then the progress bar will run indefinitely and must
be manually cleared by calling reset.  The wait method accepts a config object with
the following properties:

Property   Type          Description
---------- ------------  ----------------------------------------------------------------------
duration   Number        The length of time in milliseconds that the progress bar should
                         run before resetting itself (defaults to undefined, in which case it
                         will run indefinitely until reset is called)
interval   Number        The length of time in milliseconds between each progress update
                         (defaults to 1000 ms)
animate    Boolean       Whether to animate the transition of the progress bar. If this value is
                         not specified, the default for the class is used.                                                   
increment  Number        The number of progress update segments to display within the progress
                         bar (defaults to 10).  If the bar reaches the end and is still
                         updating, it will automatically wrap back to the beginning.
text       String        Optional text to display in the progress bar element (defaults to '').
fn         Function      A callback function to execute after the progress bar finishes auto-
                         updating.  The function will be called with no arguments.  This function
                         will be ignored if duration is not specified since in that case the
                         progress bar can only be stopped programmatically, so any required function
                         should be called by the same code after it resets the progress bar.
scope      Object        The scope that is passed to the callback function (only applies when
                         duration and fn are both passed).

Example usage:
var p = new Ext.ProgressBar({
   renderTo: 'my-el'
});

//Wait for 5 seconds, then update the status el (progress bar will auto-reset)
p.wait({
   interval: 100, //bar will move fast!
   duration: 5000,
   increment: 15,
   text: 'Updating...',
   scope: this,
   fn: function(){
      Ext.fly('status').update('Done!');
   }
});

//Or update indefinitely until some async action completes, then reset manually
p.wait();
myAction.on('complete', function(){
    p.reset();
    Ext.fly('status').update('Done!');
});</description></method></methods></class><class superclass="Ext.form.Field" type="Ext.form.Checkbox"><description>Single checkbox field.  Can be used as a direct replacement for traditional checkbox fields.</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getActiveError" scope="instance"><description>Gets the active error message for this field.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getErrors" scope="instance"><description>Runs this field's validators and returns an array of error messages for any validation failures.
This is called internally during validation and would not usually need to be used manually.
Each subclass should override or augment the return value to provide their own errors</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getName" scope="instance"><description>Returns the name or hiddenName
attribute of the field if available.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getRawValue" scope="instance"><description>Returns the raw data value which may or may not be a valid, defined value.  To return a normalized value see getValue.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getValue" scope="instance"><description>Returns the checked state of the checkbox.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isDirty" scope="instance"><description>Returns true if the value of this Field has been changed from its original value.
Will return false if the field is disabled or has not been rendered yet.
Note that if the owning form was configured with
Ext.form.BasicForm.trackResetOnLoad
then the original value is updated when the values are loaded by
Ext.form.BasicForm.setValues.</description></method><method name="isValid" scope="instance"><description>Returns whether or not the field value is currently valid by
validating the processed value
of the field. Note: disabled fields are ignored.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="processValue" scope="instance"><description>This method should only be overridden if necessary to prepare raw values
for validation (see validate and isValid).  This method
is expected to return the processed value for the field which will
be used for validation (see validateValue method).</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="reset" scope="instance"><description>Resets the current field value to the originally loaded value and clears any validation messages.
See Ext.form.BasicForm.trackResetOnLoad</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setActiveError" scope="instance"><description>Sets the current activeError to the given string. Fires the 'invalid' event.
This does not set up the error icon, only sets the message and fires the event. To show the error icon,
use markInvalid instead, which calls this method internally</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setRawValue" scope="instance"><description>Sets the underlying DOM field's value directly, bypassing validation.  To set the value with validation see setValue.</description></method><method name="setReadOnly" scope="instance"><description>Sets the read only state of this field.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setValue" scope="instance"><description>Sets the checked state of the checkbox, fires the 'check' event, and calls a
handler (if configured).</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="unsetActiveError" scope="instance"><description>Clears the activeError and fires the 'valid' event. This is called internally by clearInvalid and would not
usually need to be called manually</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method><method name="validate" scope="instance"><description>Validates the field value</description></method><method name="validateValue" scope="instance"><description>Uses getErrors to build an array of validation errors. If any errors are found, markInvalid is called
with the first and false is returned, otherwise true is returned. Previously, subclasses were invited
to provide an implementation of this to process validations - from 3.2 onwards getErrors should be
overridden instead.</description></method></methods></class><class superclass="Ext.direct.JsonProvider" type="Ext.direct.PollingProvider"><description>Provides for repetitive polling of the server at distinct intervals.
The initial request for data originates from the client, and then is responded to by the
server.
All configurations for the PollingProvider should be generated by the server-side
API portion of the Ext.Direct stack.
An instance of PollingProvider may be created directly via the new keyword or by simply
specifying type = 'polling'.  For example:
var pollA = new Ext.direct.PollingProvider({
    type:'polling',
    url: 'php/pollA.php',
});
Ext.Direct.addProvider(pollA);
pollA.disconnect();

Ext.Direct.addProvider(
    {
        type:'polling',
        url: 'php/pollB.php',
        id: 'pollB-provider'
    }
);
var pollB = Ext.Direct.getProvider('pollB-provider');</description><constructors/><properties/><methods><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="connect" scope="instance"><description>Connect to the server-side and begin the polling process. To handle each
response subscribe to the data event.</description></method><method name="disconnect" scope="instance"><description>Disconnect from the server-side and stop the polling process. The disconnect
event will be fired on a successful disconnect.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="isConnected" scope="instance"><description>Returns whether or not the server-side is currently connected.
Abstract method for subclasses to implement.</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method></methods></class><class superclass="Ext.data.JsonReader" type="Ext.data.ArrayReader"><description>Data reader class to create an Array of Ext.data.Record objects from an Array.
Each element of that Array represents a row of data fields. The
fields are pulled into a Record object using as a subscript, the mapping property
of the field definition if it exists, or the field's ordinal position in the definition.
Example code:
var Employee = Ext.data.Record.create([
    {name: 'name', mapping: 1},         // &quot;mapping&quot; only needed if an &quot;id&quot; field is present which
    {name: 'occupation', mapping: 2}    // precludes using the ordinal position as the index.
]);
var myReader = new Ext.data.ArrayReader({
    idIndex: 0
}, Employee);
This would consume an Array like this:
[ [1, 'Bill', 'Gardener'], [2, 'Ben', 'Horticulturalist'] ]</description><constructors/><properties/><methods><method name="isData" scope="instance"><description>Returns true if the supplied data-hash looks and quacks like data.  Checks to see if it has a key
corresponding to idProperty defined in your DataReader config containing non-empty pk.</description></method><method name="read" scope="instance"><description>This method is only used by a DataProxy which has retrieved data from a remote server.</description></method><method name="readRecords" scope="instance"><description>Create a data block containing Ext.data.Records from an Array.</description></method><method name="readResponse" scope="instance"><description>Decode a JSON response from server.</description></method><method name="realize" scope="instance"><description>Used for un-phantoming a record after a successful database insert.  Sets the records pk along with new data from server.
You must return at least the database pk using the idProperty defined in your DataReader configuration.  The incoming
data from server will be merged with the data in the local record.
In addition, you must return record-data from the server in the same order received.
Will perform a commit as well, un-marking dirty-fields.  Store's &quot;update&quot; event will be suppressed.</description></method><method name="update" scope="instance"><description>Used for updating a non-phantom or &quot;real&quot; record's data with fresh data from server after remote-save.
If returning data from multiple-records after a batch-update, you must return record-data from the server in
the same order received.  Will perform a commit as well, un-marking dirty-fields.  Store's &quot;update&quot; event will be
suppressed as the record receives fresh new data-hash</description></method></methods></class><class superclass="Object" type="Ext.grid.PropertyRecord"><description>A specific Ext.data.Record type that represents a name/value pair and is made to work with the
Ext.grid.PropertyGrid.  Typically, PropertyRecords do not need to be created directly as they can be
created implicitly by simply using the appropriate data configs either via the Ext.grid.PropertyGrid.source
config property or by calling Ext.grid.PropertyGrid.setSource.  However, if the need arises, these records
can also be created explicitly as shwon below.  Example usage:
var rec = new Ext.grid.PropertyRecord({
    name: 'Birthday',
    value: new Date(Date.parse('05/26/1972'))
});
// Add record to an already populated grid
grid.store.addSorted(rec);</description><constructors/><properties/><methods/></class><class superclass="Object" type="Ext.data.DataReader"><description>Abstract base class for reading structured data from a data source and converting
it into an object containing Ext.data.Record objects and metadata for use
by an Ext.data.Store.  This class is intended to be extended and should not
be created directly. For existing implementations, see Ext.data.ArrayReader,
Ext.data.JsonReader and Ext.data.XmlReader.</description><constructors/><properties/><methods><method name="isData" scope="instance"><description>Returns true if the supplied data-hash looks and quacks like data.  Checks to see if it has a key
corresponding to idProperty defined in your DataReader config containing non-empty pk.</description></method><method name="realize" scope="instance"><description>Used for un-phantoming a record after a successful database insert.  Sets the records pk along with new data from server.
You must return at least the database pk using the idProperty defined in your DataReader configuration.  The incoming
data from server will be merged with the data in the local record.
In addition, you must return record-data from the server in the same order received.
Will perform a commit as well, un-marking dirty-fields.  Store's &quot;update&quot; event will be suppressed.</description></method><method name="update" scope="instance"><description>Used for updating a non-phantom or &quot;real&quot; record's data with fresh data from server after remote-save.
If returning data from multiple-records after a batch-update, you must return record-data from the server in
the same order received.  Will perform a commit as well, un-marking dirty-fields.  Store's &quot;update&quot; event will be
suppressed as the record receives fresh new data-hash</description></method></methods></class><class superclass="Ext.util.Observable" type="Ext.data.Connection"><description>The class encapsulates a connection to the page's originating domain, allowing requests to be made
either to a configured URL, or to a URL specified at request time.
Requests made by this class are asynchronous, and will return immediately. No data from
the server will be available to the statement immediately following the request call.
To process returned data, use a
success callback
in the request options object,
or an event listener.
File UploadsFile uploads are not performed using normal &quot;Ajax&quot; techniques, that
is they are not performed using XMLHttpRequests. Instead the form is submitted in the standard
manner with the DOM &lt;form&gt; element temporarily modified to have its
target set to refer
to a dynamically generated, hidden &lt;iframe&gt; which is inserted into the document
but removed after the return data has been gathered.
The server response is parsed by the browser to create the document for the IFRAME. If the
server is using JSON to send the return object, then the
Content-Type header
must be set to &quot;text/html&quot; in order to tell the browser to insert the text unchanged into the document body.
Characters which are significant to an HTML parser must be sent as HTML entities, so encode
&quot;&lt;&quot; as &quot;&amp;lt;&quot;, &quot;&amp;&quot; as &quot;&amp;amp;&quot; etc.
The response text is retrieved from the document, and a fake XMLHttpRequest object
is created containing a responseText property in order to conform to the
requirements of event handlers and callbacks.
Be aware that file upload packets are sent with the content type multipart/form
and some server technologies (notably JEE) may require some custom processing in order to
retrieve parameter names and parameter values from the packet content.
Also note that it's not possible to check the response code of the hidden iframe, so the success handler will ALWAYS fire.</description><constructors/><properties/><methods><method name="abort" scope="instance"><description>Aborts any outstanding request.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="isLoading" scope="instance"><description>Determine whether this object has a request outstanding.</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="request" scope="instance"><description>Sends an HTTP request to a remote server.
Important: Ajax server requests are asynchronous, and this call will
return before the response has been received. Process any returned data
in a callback function.
Ext.Ajax.request({
   url: 'ajax_demo/sample.json',
   success: function(response, opts) {
      var obj = Ext.decode(response.responseText);
      console.dir(obj);
   },
   failure: function(response, opts) {
      console.log('server-side failure with status code ' + response.status);
   }
});
To execute a callback function in the correct scope, use the scope option.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method></methods></class><class superclass="Ext.Component" type="Ext.ColorPalette"><description>Simple color palette class for choosing colors.  The palette can be rendered to any container.
Here's an example of typical usage:
var cp = new Ext.ColorPalette({value:'993300'});  // initial selected color
cp.render('my-div');

cp.on('select', function(palette, selColor){
    // do something with selColor
});</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="select" scope="instance"><description>Selects the specified color in the palette (fires the select event)</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method></methods></class><class superclass="Ext.Container" type="Ext.Viewport"><description>A specialized container representing the viewable application area (the browser viewport).
The Viewport renders itself to the document body, and automatically sizes itself to the size of
the browser viewport and manages window resizing. There may only be one Viewport created
in a page. Inner layouts are available by virtue of the fact that all Panels
added to the Viewport, either through its items, or through the items, or the add
method of any of its child Panels may themselves have a layout.
The Viewport does not provide scrolling, so child Panels within the Viewport should provide
for scrolling if needed using the autoScroll config.
An example showing a classic application border layout:new Ext.Viewport({
    layout: 'border',
    items: [{
        region: 'north',
        html: '&lt;h1 class=&quot;x-panel-header&quot;&gt;Page Title&lt;/h1&gt;',
        autoHeight: true,
        border: false,
        margins: '0 0 5 0'
    }, {
        region: 'west',
        collapsible: true,
        title: 'Navigation',
        width: 200
        // the west region might typically utilize a TreePanel or a Panel with Accordion layout
    }, {
        region: 'south',
        title: 'Title for Panel',
        collapsible: true,
        html: 'Information goes here',
        split: true,
        height: 100,
        minHeight: 100
    }, {
        region: 'east',
        title: 'Title for the Grid Panel',
        collapsible: true,
        split: true,
        width: 200,
        xtype: 'grid',
        // remaining grid configuration not shown ...
        // notice that the GridPanel is added directly as the region
        // it is not &quot;overnested&quot; inside another Panel
    }, {
        region: 'center',
        xtype: 'tabpanel', // TabPanel itself has no title
        items: {
            title: 'Default Tab',
            html: 'The first tab\'s content. Others may be added dynamically'
        }
    }]
});</description><constructors/><properties/><methods><method name="add" scope="instance"><description>Adds Component(s) to this Container.
Description :

Fires the beforeadd event before adding
The Container's default config values will be applied
accordingly (see defaults for details).
Fires the add event after the component has been added.

Notes :

If the Container is already rendered when add
is called, you may need to call doLayout to refresh the view which causes
any unrendered child Components to be rendered. This is required so that you can
add multiple child components if needed while only refreshing the layout
once. For example:var tb = new Ext.Toolbar();
tb.render(document.body);  // toolbar is rendered
tb.add({text:'Button 1'}); // add multiple items (defaultType for Toolbar is 'button')
tb.add({text:'Button 2'});
tb.doLayout();             // refresh the layout
Warning: Containers directly managed by the BorderLayout layout manager
may not be removed or added.  See the Notes for BorderLayout
for more details.
</description></method><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cascade" scope="instance"><description>Cascades down the component/container heirarchy from this component (called first), calling the specified function with
each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the cascade is stopped on that branch.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="doLayout" scope="instance"><description>Force this container's layout to be recalculated. A call to this function is required after adding a new component
to an already rendered container, or possibly after changing sizing/position properties of child components.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="find" scope="instance"><description>Find a component under this container at any level by property</description></method><method name="findBy" scope="instance"><description>Find a component under this container at any level by a custom function. If the passed function returns
true, the component will be included in the results. The passed function is called with the arguments (component, this container).</description></method><method name="findById" scope="instance"><description>Find a component under this container at any level by id</description></method><method name="findByType" scope="instance"><description>Find a component under this container at any level by xtype or class</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="get" scope="instance"><description>Get a component contained by this container (alias for items.get(key))</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getComponent" scope="instance"><description>Examines this container's items property
and gets a direct child component of this container.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getLayout" scope="instance"><description>Returns the layout currently in use by the container.  If the container does not currently have a layout
set, a default Ext.layout.ContainerLayout will be created and set as the container's layout.</description></method><method name="getLayoutTarget" scope="instance"><description>Returns the Element to be used to contain the child Components of this Container.
An implementation is provided which returns the Container's Element, but
if there is a more complex structure to a Container, this may be overridden to return
the element into which the layout renders child Components.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="insert" scope="instance"><description>Inserts a Component into this Container at a specified index. Fires the
beforeadd event before inserting, then fires the add event after the
Component has been inserted.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="remove" scope="instance"><description>Removes a component from this container.  Fires the beforeremove event before removing, then fires
the remove event after the component has been removed.</description></method><method name="removeAll" scope="instance"><description>Removes all components from this container.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method></methods></class><class superclass="Object" type="Ext.util.Functions"><description/><constructors/><properties/><methods><method name="createDelegate" scope="instance"><description>Creates a delegate (callback) that sets the scope to obj.
Call directly on any function. Example: Ext.createDelegate(this.myFunction, this, [arg1, arg2])
Will create a function that is automatically scoped to obj so that the this variable inside the
callback points to obj. Example usage:
var sayHi = function(name){
    // Note this use of &quot;this.text&quot; here.  This function expects to
    // execute within a scope that contains a text property.  In this
    // example, the &quot;this&quot; variable is pointing to the btn object that
    // was passed in createDelegate below.
    alert('Hi, ' + name + '. You clicked the &quot;' + this.text + '&quot; button.');
}

var btn = new Ext.Button({
    text: 'Say Hi',
    renderTo: Ext.getBody()
});

// This callback will execute in the scope of the
// button instance. Clicking the button alerts
// &quot;Hi, Fred. You clicked the &quot;Say Hi&quot; button.&quot;
btn.on('click', Ext.createDelegate(sayHi, btn, ['Fred']));</description></method><method name="createInterceptor" scope="instance"><description>Creates an interceptor function. The passed function is called before the original one. If it returns false,
the original one is not called. The resulting function returns the results of the original function.
The passed function is called with the parameters of the original function. Example usage:
var sayHi = function(name){
    alert('Hi, ' + name);
}

sayHi('Fred'); // alerts &quot;Hi, Fred&quot;

// create a new function that validates input without
// directly modifying the original function:
var sayHiToFriend = Ext.createInterceptor(sayHi, function(name){
    return name == 'Brian';
});

sayHiToFriend('Fred');  // no alert
sayHiToFriend('Brian'); // alerts &quot;Hi, Brian&quot;</description></method><method name="createSequence" scope="instance"><description>Create a combined function call sequence of the original function + the passed function.
The resulting function returns the results of the original function.
The passed fcn is called with the parameters of the original function. Example usage:
var sayHi = function(name){
    alert('Hi, ' + name);
}

sayHi('Fred'); // alerts &quot;Hi, Fred&quot;

var sayGoodbye = Ext.createSequence(sayHi, function(name){
    alert('Bye, ' + name);
});

sayGoodbye('Fred'); // both alerts show</description></method><method name="defer" scope="instance"><description>Calls this function after the number of millseconds specified, optionally in a specific scope. Example usage:
var sayHi = function(name){
    alert('Hi, ' + name);
}

// executes immediately:
sayHi('Fred');

// executes after 2 seconds:
Ext.defer(sayHi, 2000, this, ['Fred']);

// this syntax is sometimes useful for deferring
// execution of an anonymous function:
Ext.defer(function(){
    alert('Anonymous');
}, 100);</description></method></methods></class><class superclass="Ext.grid.GridView" type="Ext.grid.GroupingView"><description>Adds the ability for single level grouping to the grid. A GroupingStore
must be used to enable grouping.  Some grouping characteristics may also be configured at the
Column level
emptyGroupText
groupable
groupName
groupRender

Sample usage:
var grid = new Ext.grid.GridPanel({
    // A groupingStore is required for a GroupingView
    store: new Ext.data.GroupingStore({
        autoDestroy: true,
        reader: reader,
        data: xg.dummyData,
        sortInfo: {field: 'company', direction: 'ASC'},
        groupOnSort: true,
        remoteGroup: true,
        groupField: 'industry'
    }),
    colModel: new Ext.grid.ColumnModel({
        columns:[
            {id:'company',header: 'Company', width: 60, dataIndex: 'company'},
            // groupable, groupName, groupRender are also configurable at column level
            {header: 'Price', renderer: Ext.util.Format.usMoney, dataIndex: 'price', groupable: false},
            {header: 'Change', dataIndex: 'change', renderer: Ext.util.Format.usMoney},
            {header: 'Industry', dataIndex: 'industry'},
            {header: 'Last Updated', renderer: Ext.util.Format.dateRenderer('m/d/Y'), dataIndex: 'lastChange'}
        ],
        defaults: {
            sortable: true,
            menuDisabled: false,
            width: 20
        }
    }),

    view: new Ext.grid.GroupingView({
        forceFit: true,
        // custom grouping text template to display the number of items per group
        groupTextTpl: '{text} ({[values.rs.length]} {[values.rs.length &gt; 1 ? &quot;Items&quot; : &quot;Item&quot;]})'
    }),

    frame:true,
    width: 700,
    height: 450,
    collapsible: true,
    animCollapse: false,
    title: 'Grouping Example',
    iconCls: 'icon-grid',
    renderTo: document.body
});</description><constructors/><properties/><methods><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="collapseAllGroups" scope="instance"><description>Collapses all grouped rows.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="expandAllGroups" scope="instance"><description>Expands all grouped rows.</description></method><method name="findCellIndex" scope="instance"><description>Return the index of the grid column which contains the passed HTMLElement.
See also findRowIndex</description></method><method name="findRow" scope="instance"><description>Return the HtmlElement representing the grid row which contains the passed element.</description></method><method name="findRowBody" scope="instance"><description>Return the HtmlElement representing the grid row body which contains the passed element.</description></method><method name="findRowIndex" scope="instance"><description>Return the index of the grid row which contains the passed HTMLElement.
See also findCellIndex</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focusCell" scope="instance"><description>Focuses the specified cell.</description></method><method name="focusRow" scope="instance"><description>Focuses the specified row.</description></method><method name="getCell" scope="instance"><description>Returns the grid's &lt;td&gt; HtmlElement at the specified coordinates.</description></method><method name="getGridInnerWidth" scope="instance"><description>Returns the total internal width available to the grid, taking the scrollbar into account</description></method><method name="getGroupId" scope="instance"><description>Dynamically tries to determine the groupId of a specific value</description></method><method name="getHeaderCell" scope="instance"><description>Return the &lt;td&gt; HtmlElement which represents the Grid's header cell for the specified column index.</description></method><method name="getRow" scope="instance"><description>Return the &lt;div&gt; HtmlElement which represents a Grid row for the specified index.</description></method><method name="getRowClass" scope="instance"><description>Override this function to apply custom CSS classes to rows during rendering.  You can also supply custom
parameters to the row template for the current row to customize how it is rendered using the rowParams
parameter.  This function should return the CSS class name (or empty string '' for none) that will be added
to the row's wrapping div.  To apply multiple class names, simply return them space-delimited within the string
(e.g., 'my-class another-class'). Example usage:
    viewConfig: {
    forceFit: true,
    showPreview: true, // custom property
    enableRowBody: true, // required to create a second, full-width row to show expanded Record data
    getRowClass: function(record, rowIndex, rp, ds){ // rp = rowParams
        if(this.showPreview){
            rp.body = '&lt;p&gt;'+record.data.excerpt+'&lt;/p&gt;';
            return 'x-grid3-row-expanded';
        }
        return 'x-grid3-row-collapsed';
    }
},</description></method><method name="handleHdMenuClickDefault" scope="instance"><description>Called by handleHdMenuClick if any button except a sort ASC/DESC button was clicked. The default implementation provides
the column hide/show functionality based on the check state of the menu item. A different implementation can be provided
if needed.</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="refresh" scope="instance"><description>Refreshs the grid UI</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="scrollToTop" scope="instance"><description>Scrolls the grid to the top</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="toggleAllGroups" scope="instance"><description>Toggles all groups if no value is passed, otherwise sets the expanded state of all groups to the value passed.</description></method><method name="toggleGroup" scope="instance"><description>Toggles the specified group if no value is passed, otherwise sets the expanded state of the group to the value passed.</description></method><method name="toggleRowIndex" scope="instance"><description>Toggle the group that contains the specific row.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method></methods></class><class superclass="Ext.chart.Axis" type="Ext.chart.NumericAxis"><description>A type of axis whose units are measured in numeric values.</description><constructors/><properties/><methods/></class><class superclass="Ext.chart.Axis" type="Ext.chart.TimeAxis"><description>A type of axis whose units are measured in time-based values.</description><constructors/><properties/><methods/></class><class superclass="Ext.data.DataWriter" type="Ext.data.XmlWriter"><description>DataWriter extension for writing an array or single Ext.data.Record object(s) in preparation for executing a remote CRUD action via XML.
XmlWriter uses an instance of Ext.XTemplate for maximum flexibility in defining your own custom XML schema if the default schema is not appropriate for your needs.
See the tpl configuration-property.</description><constructors/><properties/><methods><method name="apply" scope="instance"><description>Compiles a Store recordset into a data-format defined by an extension such as Ext.data.JsonWriter or Ext.data.XmlWriter in preparation for a server-write action.  The first two params are similar similar in nature to Ext.apply,
Where the first parameter is the receiver of paramaters and the second, baseParams, the source.</description></method><method name="createRecord" scope="instance"><description>createRecord</description></method><method name="destroyRecord" scope="instance"><description>destroyRecord</description></method><method name="render" scope="instance"><description>XmlWriter implementation of the final stage of a write action.</description></method><method name="toArray" scope="instance"><description>Converts a Hashed Ext.data.Record to fields-array array suitable
for encoding to xml via XTemplate, eg:
&lt;tpl for=&quot;.&quot;&gt;&lt;{name}&gt;{value}&lt;/{name}&lt;/tpl&gt;
eg, non-phantom:
{id: 1, first: 'foo', last: 'bar'} --&gt; [{name: 'id', value: 1}, {name: 'first', value: 'foo'}, {name: 'last', value: 'bar'}]
Phantom records will have had their idProperty omitted in toHash if determined to be auto-generated.
Non AUTOINCREMENT pks should have been protected.</description></method><method name="toHash" scope="instance"><description>Converts a Record to a hash, taking into account the state of the Ext.data.Record along with configuration properties
related to its rendering, such as writeAllFields, phantom, getChanges and
idProperty</description></method><method name="updateRecord" scope="instance"><description>updateRecord</description></method></methods></class><class superclass="Ext.menu.Menu" type="Ext.menu.DateMenu"><description>A menu containing an Ext.DatePicker Component.
Notes:
Although not listed here, the constructor for this class
accepts all of the configuration options of Ext.DatePicker.
If subclassing DateMenu, any configuration options for the DatePicker must be
applied to the initialConfig property of the DateMenu.
Applying DatePicker configuration settings to
this will not affect the DatePicker's configuration.
</description><constructors/><properties/><methods><method name="add" scope="instance"><description>Adds Component(s) to this Container.
Description :

Fires the beforeadd event before adding
The Container's default config values will be applied
accordingly (see defaults for details).
Fires the add event after the component has been added.

Notes :

If the Container is already rendered when add
is called, you may need to call doLayout to refresh the view which causes
any unrendered child Components to be rendered. This is required so that you can
add multiple child components if needed while only refreshing the layout
once. For example:var tb = new Ext.Toolbar();
tb.render(document.body);  // toolbar is rendered
tb.add({text:'Button 1'}); // add multiple items (defaultType for Toolbar is 'button')
tb.add({text:'Button 2'});
tb.doLayout();             // refresh the layout
Warning: Containers directly managed by the BorderLayout layout manager
may not be removed or added.  See the Notes for BorderLayout
for more details.
</description></method><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addElement" scope="instance"><description>Adds an Ext.Element object to the menu</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addItem" scope="instance"><description>Adds an existing object based on Ext.menu.BaseItem to the menu</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="addMenuItem" scope="instance"><description>Creates a new Ext.menu.Item based an the supplied config object and adds it to the menu</description></method><method name="addSeparator" scope="instance"><description>Adds a separator bar to the menu</description></method><method name="addText" scope="instance"><description>Creates a new Ext.menu.TextItem with the supplied text and adds it to the menu</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cascade" scope="instance"><description>Cascades down the component/container heirarchy from this component (called first), calling the specified function with
each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the cascade is stopped on that branch.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="doLayout" scope="instance"><description>Force this container's layout to be recalculated. A call to this function is required after adding a new component
to an already rendered container, or possibly after changing sizing/position properties of child components.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="find" scope="instance"><description>Find a component under this container at any level by property</description></method><method name="findBy" scope="instance"><description>Find a component under this container at any level by a custom function. If the passed function returns
true, the component will be included in the results. The passed function is called with the arguments (component, this container).</description></method><method name="findById" scope="instance"><description>Find a component under this container at any level by id</description></method><method name="findByType" scope="instance"><description>Find a component under this container at any level by xtype or class</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="get" scope="instance"><description>Get a component contained by this container (alias for items.get(key))</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getComponent" scope="instance"><description>Examines this container's items property
and gets a direct child component of this container.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getLayout" scope="instance"><description>Returns the layout currently in use by the container.  If the container does not currently have a layout
set, a default Ext.layout.ContainerLayout will be created and set as the container's layout.</description></method><method name="getLayoutTarget" scope="instance"><description>Returns the Element to be used to contain the child Components of this Container.
An implementation is provided which returns the Container's Element, but
if there is a more complex structure to a Container, this may be overridden to return
the element into which the layout renders child Components.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hides this menu and optionally all parent menus</description></method><method name="insert" scope="instance"><description>Inserts a Component into this Container at a specified index. Fires the
beforeadd event before inserting, then fires the add event after the
Component has been inserted.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="remove" scope="instance"><description>Removes a component from this container.  Fires the beforeremove event before removing, then fires
the remove event after the component has been removed.</description></method><method name="removeAll" scope="instance"><description>Removes all components from this container.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>If floating=true, shows this menu relative to
another element using showat, otherwise uses Ext.Component.show.</description></method><method name="showAt" scope="instance"><description>Displays this menu at a specific xy position and fires the 'show' event if a
handler for the 'beforeshow' event does not return false cancelling the operation.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method></methods></class><class superclass="Object" type="Ext.data.Response"><description>A generic response class to normalize response-handling internally to the framework.</description><constructors/><properties/><methods/></class><class superclass="Object" type="Ext.layout.boxOverflow.None"><description>Base class for Box Layout overflow handlers. These specialized classes are invoked when a Box Layout
(either an HBox or a VBox) has child items that are either too wide (for HBox) or too tall (for VBox)
for its container.</description><constructors/><properties/><methods/></class><class superclass="Object" type="Ext.KeyNav"><description>Provides a convenient wrapper for normalized keyboard navigation.  KeyNav allows you to bind
navigation keys to function calls that will get called when the keys are pressed, providing an easy
way to implement custom navigation schemes for any UI component.
The following are all of the possible keys that can be implemented: enter, left, right, up, down, tab, esc,
pageUp, pageDown, del, home, end.  Usage:
 var nav = new Ext.KeyNav(&quot;my-element&quot;, {
    &quot;left&quot; : function(e){
        this.moveLeft(e.ctrlKey);
    },
    &quot;right&quot; : function(e){
        this.moveRight(e.ctrlKey);
    },
    &quot;enter&quot; : function(e){
        this.save();
    },
    scope : this
});</description><constructors/><properties/><methods><method name="destroy" scope="instance"><description>Destroy this KeyNav (this is the same as calling disable).</description></method><method name="disable" scope="instance"><description>Disable this KeyNav</description></method><method name="enable" scope="instance"><description>Enable this KeyNav</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method></methods></class><class superclass="Ext.form.Field" type="Ext.form.Hidden"><description>A basic hidden field for storing hidden values in forms that need to be passed in the form submit.</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="clearInvalid" scope="instance"><description>Clear any invalid styles/messages for this field</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getActiveError" scope="instance"><description>Gets the active error message for this field.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getErrors" scope="instance"><description>Runs this field's validators and returns an array of error messages for any validation failures.
This is called internally during validation and would not usually need to be used manually.
Each subclass should override or augment the return value to provide their own errors</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getName" scope="instance"><description>Returns the name or hiddenName
attribute of the field if available.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getRawValue" scope="instance"><description>Returns the raw data value which may or may not be a valid, defined value.  To return a normalized value see getValue.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getValue" scope="instance"><description>Returns the normalized data value (undefined or emptyText will be returned as '').  To return the raw value see getRawValue.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isDirty" scope="instance"><description>Returns true if the value of this Field has been changed from its original value.
Will return false if the field is disabled or has not been rendered yet.
Note that if the owning form was configured with
Ext.form.BasicForm.trackResetOnLoad
then the original value is updated when the values are loaded by
Ext.form.BasicForm.setValues.</description></method><method name="isValid" scope="instance"><description>Returns whether or not the field value is currently valid by
validating the processed value
of the field. Note: disabled fields are ignored.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="markInvalid" scope="instance"><description>Display an error message associated with this field, using msgTarget to determine how to
display the message and applying invalidClass to the field's UI element.
Note: this method does not cause the Field's validate method to return false
if the value does pass validation. So simply marking a Field as invalid will not prevent
submission of forms submitted with the Ext.form.Action.Submit.clientValidation option set.
invalid.</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="processValue" scope="instance"><description>This method should only be overridden if necessary to prepare raw values
for validation (see validate and isValid).  This method
is expected to return the processed value for the field which will
be used for validation (see validateValue method).</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="reset" scope="instance"><description>Resets the current field value to the originally loaded value and clears any validation messages.
See Ext.form.BasicForm.trackResetOnLoad</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setActiveError" scope="instance"><description>Sets the current activeError to the given string. Fires the 'invalid' event.
This does not set up the error icon, only sets the message and fires the event. To show the error icon,
use markInvalid instead, which calls this method internally</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setRawValue" scope="instance"><description>Sets the underlying DOM field's value directly, bypassing validation.  To set the value with validation see setValue.</description></method><method name="setReadOnly" scope="instance"><description>Sets the read only state of this field.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setValue" scope="instance"><description>Sets a data value into the field and validates it.  To set the value directly without validation see setRawValue.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="unsetActiveError" scope="instance"><description>Clears the activeError and fires the 'valid' event. This is called internally by clearInvalid and would not
usually need to be called manually</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method><method name="validate" scope="instance"><description>Validates the field value</description></method><method name="validateValue" scope="instance"><description>Uses getErrors to build an array of validation errors. If any errors are found, markInvalid is called
with the first and false is returned, otherwise true is returned. Previously, subclasses were invited
to provide an implementation of this to process validations - from 3.2 onwards getErrors should be
overridden instead.</description></method></methods></class><class superclass="Ext.data.DataProxy" type="Ext.data.DirectProxy"><description/><constructors/><properties/><methods><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="destroy" scope="instance"><description>Destroys the proxy by purging any event listeners and cancelling any active requests.</description></method><method name="doRequest" scope="instance"><description>DirectProxy implementation of Ext.data.DataProxy.doRequest</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="isApiAction" scope="instance"><description>Returns true if the specified action is defined as a unique action in the api-config.
request.  If all API-actions are routed to unique urls, the xaction parameter is unecessary.  However, if no api is defined
and all Proxy actions are routed to DataProxy#url, the server-side will require the xaction parameter to perform a switch to
the corresponding code for CRUD action.</description></method><method name="load" scope="instance"><description>Deprecated load method using old method signature. See {@doRequest} for preferred method.</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="onRead" scope="instance"><description>Callback for read actions</description></method><method name="onWrite" scope="instance"><description>Callback for write actions</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="request" scope="instance"><description>All proxy actions are executed through this method.  Automatically fires the &quot;before&quot; + action event</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setApi" scope="instance"><description>Redefines the Proxy's API or a single action of an API. Can be called with two method signatures.
If called with an object as the only parameter, the object should redefine the entire API, e.g.:proxy.setApi({
    read    : '/users/read',
    create  : '/users/create',
    update  : '/users/update',
    destroy : '/users/destroy'
});
If called with two parameters, the first parameter should be a string specifying the API action to
redefine and the second parameter should be the URL (or function if using DirectProxy) to call for that action, e.g.:proxy.setApi(Ext.data.Api.actions.read, '/users/new_load_url');</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method></methods></class><class superclass="Ext.direct.Provider" type="Ext.direct.JsonProvider"><description/><constructors/><properties/><methods><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="isConnected" scope="instance"><description>Returns whether or not the server-side is currently connected.
Abstract method for subclasses to implement.</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method></methods></class><class superclass="Ext.util.Observable" type="Ext.data.DataProxy"><description>Abstract base class for implementations which provide retrieval of unformatted data objects.
This class is intended to be extended and should not be created directly. For existing implementations,
see Ext.data.DirectProxy, Ext.data.HttpProxy, Ext.data.ScriptTagProxy and
Ext.data.MemoryProxy.
DataProxy implementations are usually used in conjunction with an implementation of Ext.data.DataReader
(of the appropriate type which knows how to parse the data object) to provide a block of
Ext.data.Records to an Ext.data.Store.
The parameter to a DataProxy constructor may be an Ext.data.Connection or can also be the
config object to an Ext.data.Connection.
Custom implementations must implement either the doRequest method (preferred) or the
load method (deprecated). See
Ext.data.HttpProxy.doRequest or
Ext.data.HttpProxy.load for additional details.
Example 1
proxy: new Ext.data.ScriptTagProxy({
    url: 'http://extjs.com/forum/topics-remote.php'
}),
Example 2
proxy : new Ext.data.HttpProxy({
    method: 'GET',
    prettyUrls: false,
    url: 'local/default.php', // see options parameter for Ext.Ajax.request
    api: {
        // all actions except the following will use above url
        create  : 'local/new.php',
        update  : 'local/update.php'
    }
}),
And new in Ext version 3, attach centralized event-listeners upon the DataProxy class itself!  This is a great place
to implement a messaging system to centralize your application's user-feedback and error-handling.
// Listen to all &quot;beforewrite&quot; event fired by all proxies.
Ext.data.DataProxy.on('beforewrite', function(proxy, action) {
    console.log('beforewrite: ', action);
});

// Listen to &quot;write&quot; event fired by all proxies
Ext.data.DataProxy.on('write', function(proxy, action, data, res, rs) {
    console.info('write: ', action);
});

// Listen to &quot;exception&quot; event fired by all proxies
Ext.data.DataProxy.on('exception', function(proxy, type, action, exception) {
    console.error(type + action + ' exception);
});
Note: These three events are all fired with the signature of the corresponding DataProxy instance event beforewrite, write and exception.</description><constructors/><properties/><methods><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="destroy" scope="instance"><description>Destroys the proxy by purging any event listeners and cancelling any active requests.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="isApiAction" scope="instance"><description>Returns true if the specified action is defined as a unique action in the api-config.
request.  If all API-actions are routed to unique urls, the xaction parameter is unecessary.  However, if no api is defined
and all Proxy actions are routed to DataProxy#url, the server-side will require the xaction parameter to perform a switch to
the corresponding code for CRUD action.</description></method><method name="load" scope="instance"><description>Deprecated load method using old method signature. See {@doRequest} for preferred method.</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="request" scope="instance"><description>All proxy actions are executed through this method.  Automatically fires the &quot;before&quot; + action event</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setApi" scope="instance"><description>Redefines the Proxy's API or a single action of an API. Can be called with two method signatures.
If called with an object as the only parameter, the object should redefine the entire API, e.g.:proxy.setApi({
    read    : '/users/read',
    create  : '/users/create',
    update  : '/users/update',
    destroy : '/users/destroy'
});
If called with two parameters, the first parameter should be a string specifying the API action to
redefine and the second parameter should be the URL (or function if using DirectProxy) to call for that action, e.g.:proxy.setApi(Ext.data.Api.actions.read, '/users/new_load_url');</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method></methods></class><class superclass="Ext.util.Observable" type="Ext.History"><description>History management component that allows you to register arbitrary tokens that signify application
history state on navigation actions.  You can then handle the history change event in order
to reset your application UI to the appropriate state when the user navigates forward or backward through
the browser history stack.</description><constructors/><properties/><methods><method name="add" scope="instance"><description>Add a new token to the history stack. This can be any arbitrary value, although it would
commonly be the concatenation of a component id and another id marking the specifc history
state of that component.  Example usage:
// Handle tab changes on a TabPanel
tabPanel.on('tabchange', function(tabPanel, tab){
    Ext.History.add(tabPanel.id + ':' + tab.id);
});</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="back" scope="instance"><description>Programmatically steps back one step in browser history (equivalent to the user pressing the Back button).</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="forward" scope="instance"><description>Programmatically steps forward one step in browser history (equivalent to the user pressing the Forward button).</description></method><method name="getToken" scope="instance"><description>Retrieves the currently-active history token.</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="init" scope="instance"><description>Initialize the global History instance.</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method></methods></class><class superclass="Object" type="Ext.data.SortTypes"><description/><constructors/><properties/><methods><method name="asDate" scope="instance"><description>Date sorting</description></method><method name="asFloat" scope="instance"><description>Float sorting</description></method><method name="asInt" scope="instance"><description>Integer sorting</description></method><method name="asText" scope="instance"><description>Strips all HTML tags to sort on text only</description></method><method name="asUCString" scope="instance"><description>Case insensitive string</description></method><method name="asUCText" scope="instance"><description>Strips all HTML tags to sort on text only - Case insensitive</description></method><method name="none" scope="instance"><description>Default sort that does nothing</description></method></methods></class><class superclass="Object" type="Ext.util.CSS"><description>Utility class for manipulating CSS rules</description><constructors/><properties/><methods><method name="createStyleSheet" scope="instance"><description>Creates a stylesheet from a text blob of rules.
These rules will be wrapped in a STYLE tag and appended to the HEAD of the document.</description></method><method name="getRule" scope="instance"><description>Gets an an individual CSS rule by selector(s)</description></method><method name="getRules" scope="instance"><description>Gets all css rules for the document</description></method><method name="refreshCache" scope="instance"><description>Refresh the rule cache if you have dynamically added stylesheets</description></method><method name="removeStyleSheet" scope="instance"><description>Removes a style or link tag by id</description></method><method name="swapStyleSheet" scope="instance"><description>Dynamically swaps an existing stylesheet reference for a new one</description></method><method name="updateRule" scope="instance"><description>Updates a rule property</description></method></methods></class><class superclass="Object" type="Array"><description/><constructors/><properties/><methods><method name="indexOf" scope="instance"><description>Checks whether or not the specified object exists in the array.</description></method><method name="remove" scope="instance"><description>Removes the specified object from the array.  If the object is not found nothing happens.</description></method></methods></class><class superclass="Ext.dd.DDTarget" type="Ext.dd.DropTarget"><description>A simple class that provides the basic implementation needed to make any element a drop target that can have
draggable items dropped onto it.  The drop has no effect until an implementation of notifyDrop is provided.</description><constructors/><properties/><methods><method name="addInvalidHandleClass" scope="instance"><description>Lets you specify a css class of elements that will not initiate a drag</description></method><method name="addInvalidHandleId" scope="instance"><description>Lets you to specify an element id for a child of a drag handle
that should not initiate a drag</description></method><method name="addInvalidHandleType" scope="instance"><description>Allows you to specify a tag name that should not start a drag operation
when clicked.  This is designed to facilitate embedding links within a
drag handle that do something other than start the drag.</description></method><method name="addToGroup" scope="instance"><description>Add this instance to a group of related drag/drop objects.  All
instances belong to at least one group, and can belong to as many
groups as needed.</description></method><method name="applyConfig" scope="instance"><description>Applies the configuration parameters that were passed into the constructor.
This is supposed to happen at each level through the inheritance chain.  So
a DDProxy implentation will execute apply config on DDProxy, DD, and
DragDrop in order to get all of the parameters that are available in
each object.</description></method><method name="clearConstraints" scope="instance"><description>Clears any constraints applied to this instance.  Also clears ticks
since they can't exist independent of a constraint at this time.</description></method><method name="clearTicks" scope="instance"><description>Clears any tick interval defined for this instance</description></method><method name="constrainTo" scope="instance"><description>Initializes the drag drop object's constraints to restrict movement to a certain element.
Usage:
 var dd = new Ext.dd.DDProxy(&quot;dragDiv1&quot;, &quot;proxytest&quot;,
                { dragElId: &quot;existingProxyDiv&quot; });
 dd.startDrag = function(){
     this.constrainTo(&quot;parent-id&quot;);
 };
Or you can initalize it using the Ext.Element object:
 Ext.get(&quot;dragDiv1&quot;).initDDProxy(&quot;proxytest&quot;, {dragElId: &quot;existingProxyDiv&quot;}, {
     startDrag : function(){
         this.constrainTo(&quot;parent-id&quot;);
     }
 });</description></method><method name="endDrag" scope="instance"><description>Fired when we are done dragging the object</description></method><method name="getDragEl" scope="instance"><description>Returns a reference to the actual element to drag.  By default this is
the same as the html element, but it can be assigned to another
element. An example of this can be found in Ext.dd.DDProxy</description></method><method name="getEl" scope="instance"><description>Returns a reference to the linked element</description></method><method name="init" scope="instance"><description>Sets up the DragDrop object.  Must be called in the constructor of any
Ext.dd.DragDrop subclass</description></method><method name="initTarget" scope="instance"><description>Initializes Targeting functionality only... the object does not
get a mousedown handler.</description></method><method name="isLocked" scope="instance"><description>Returns true if this instance is locked, or the drag drop mgr is locked
(meaning that all drag/drop is disabled on the page.)</description></method><method name="isValidHandleChild" scope="instance"><description>Checks the tag exclusion list to see if this click should be ignored</description></method><method name="lock" scope="instance"><description>Lock this instance</description></method><method name="notifyDrop" scope="instance"><description>The function a Ext.dd.DragSource calls once to notify this drop target that the dragged item has
been dropped on it.  This method has no default implementation and returns false, so you must provide an
implementation that does something to process the drop event and returns true so that the drag source's
repair action does not run.</description></method><method name="notifyEnter" scope="instance"><description>The function a Ext.dd.DragSource calls once to notify this drop target that the source is now over the
target.  This default implementation adds the CSS class specified by overClass (if any) to the drop element
and returns the dropAllowed config value.  This method should be overridden if drop validation is required.</description></method><method name="notifyOut" scope="instance"><description>The function a Ext.dd.DragSource calls once to notify this drop target that the source has been dragged
out of the target without dropping.  This default implementation simply removes the CSS class specified by
overClass (if any) from the drop element.</description></method><method name="notifyOver" scope="instance"><description>The function a Ext.dd.DragSource calls continuously while it is being dragged over the target.
This method will be called on every mouse movement while the drag source is over the drop target.
This default implementation simply returns the dropAllowed config value.</description></method><method name="onAvailable" scope="instance"><description>Override the onAvailable method to do what is needed after the initial
position was determined.</description></method><method name="onDrag" scope="instance"><description>Abstract method called during the onMouseMove event while dragging an
object.</description></method><method name="onDragDrop" scope="instance"><description>Abstract method called when this item is dropped on another DragDrop
obj</description></method><method name="onDragEnter" scope="instance"><description>Abstract method called when this element fist begins hovering over
another DragDrop obj</description></method><method name="onDragOut" scope="instance"><description>Abstract method called when we are no longer hovering over an element</description></method><method name="onDragOver" scope="instance"><description>Abstract method called when this element is hovering over another
DragDrop obj</description></method><method name="onInvalidDrop" scope="instance"><description>Abstract method called when this item is dropped on an area with no
drop target</description></method><method name="onMouseDown" scope="instance"><description>Event handler that fires when a drag/drop obj gets a mousedown</description></method><method name="onMouseUp" scope="instance"><description>Event handler that fires when a drag/drop obj gets a mouseup</description></method><method name="removeFromGroup" scope="instance"><description>Remove's this instance from the supplied interaction group</description></method><method name="removeInvalidHandleClass" scope="instance"><description>Unsets an invalid css class</description></method><method name="removeInvalidHandleId" scope="instance"><description>Unsets an invalid handle id</description></method><method name="removeInvalidHandleType" scope="instance"><description>Unsets an excluded tag name set by addInvalidHandleType</description></method><method name="resetConstraints" scope="instance"><description>resetConstraints must be called if you manually reposition a dd element.</description></method><method name="setDragElId" scope="instance"><description>Allows you to specify that an element other than the linked element
will be moved with the cursor during a drag</description></method><method name="setHandleElId" scope="instance"><description>Allows you to specify a child of the linked element that should be
used to initiate the drag operation.  An example of this would be if
you have a content div with text and links.  Clicking anywhere in the
content area would normally start the drag operation.  Use this method
to specify that an element inside of the content div is the element
that starts the drag operation.</description></method><method name="setInitPosition" scope="instance"><description>Stores the initial placement of the linked element.</description></method><method name="setOuterHandleElId" scope="instance"><description>Allows you to set an element outside of the linked element as a drag
handle</description></method><method name="setPadding" scope="instance"><description>Configures the padding for the target zone in px.  Effectively expands
(or reduces) the virtual object size for targeting calculations.
Supports css-style shorthand; if only one parameter is passed, all sides
will have that padding, and if only two are passed, the top and bottom
will have the first param, the left and right the second.</description></method><method name="setXConstraint" scope="instance"><description>By default, the element can be dragged any place on the screen.  Use
this method to limit the horizontal travel of the element.  Pass in
0,0 for the parameters if you want to lock the drag to the y axis.</description></method><method name="setYConstraint" scope="instance"><description>By default, the element can be dragged any place on the screen.  Set
this to limit the vertical travel of the element.  Pass in 0,0 for the
parameters if you want to lock the drag to the x axis.</description></method><method name="startDrag" scope="instance"><description>Abstract method called after a drag/drop object is clicked
and the drag or mousedown time thresholds have beeen met.</description></method><method name="toString" scope="instance"><description>toString method</description></method><method name="unlock" scope="instance"><description>Unlock this instace</description></method><method name="unreg" scope="instance"><description>Remove all drag and drop hooks for this element</description></method></methods></class><class superclass="Object" type="Ext.AbstractManager"><description>Base Manager class - extended by ComponentMgr and PluginMgr</description><constructors/><properties/><methods><method name="create" scope="instance"><description>Creates and returns an instance of whatever this manager manages, based on the supplied type and config object</description></method><method name="get" scope="instance"><description>Returns a component by id.
For additional details see Ext.util.MixedCollection.get.</description></method><method name="isRegistered" scope="instance"><description>Checks if a Component type is registered.</description></method><method name="onAvailable" scope="instance"><description>Registers a function that will be called when a Component with the specified id is added to the manager. This will happen on instantiation.</description></method><method name="register" scope="instance"><description>Registers an item to be managed</description></method><method name="registerType" scope="instance"><description>Registers a new Component constructor, keyed by a new
Ext.Component.xtype.
Use this method (or its alias Ext.reg) to register new
subclasses of Ext.Component so that lazy instantiation may be used when specifying
child Components.
see Ext.Container.items</description></method><method name="unregister" scope="instance"><description>Unregisters a component by removing it from this manager</description></method></methods></class><class superclass="Object" type="Ext.Shadow"><description>Simple class that can provide a shadow effect for any element.  Note that the element MUST be absolutely positioned,
and the shadow does not provide any shimming.  This should be used only in simple cases -- for more advanced
functionality that can also provide the same shadow effect, see the Ext.Layer class.</description><constructors/><properties/><methods><method name="hide" scope="instance"><description>Hides this shadow</description></method><method name="isVisible" scope="instance"><description>Returns true if the shadow is visible, else false</description></method><method name="realign" scope="instance"><description>Direct alignment when values are already available. Show must be called at least once before
calling this method to ensure it is initialized.</description></method><method name="setZIndex" scope="instance"><description>Adjust the z-index of this shadow</description></method><method name="show" scope="instance"><description>Displays the shadow under the target element</description></method></methods></class><class superclass="Object" type="Ext.form.VTypes"><description>This is a singleton object which contains a set of commonly used field validation functions.
The validations provided are basic and intended to be easily customizable and extended.
To add custom VTypes specify the vtype validation
test function, and optionally specify any corresponding error text to display and any keystroke
filtering mask to apply. For example:
// custom Vtype for vtype:'time'
var timeTest = /^([1-9]|1[0-9]):([0-5][0-9])(\s[a|p]m)$/i;
Ext.apply(Ext.form.VTypes, {
    //  vtype validation function
    time: function(val, field) {
        return timeTest.test(val);
    },
    // vtype Text property: The error text to display when the validation function returns false
    timeText: 'Not a valid time.  Must be in the format &quot;12:34 PM&quot;.',
    // vtype Mask property: The keystroke filter mask
    timeMask: /[\d\s:amp]/i
});
Another example:
// custom Vtype for vtype:'IPAddress'
Ext.apply(Ext.form.VTypes, {
    IPAddress:  function(v) {
        return /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/.test(v);
    },
    IPAddressText: 'Must be a numeric IP address',
    IPAddressMask: /[\d\.]/i
});</description><constructors/><properties/><methods><method name="alpha" scope="instance"><description>The function used to validate alpha values</description></method><method name="alphanum" scope="instance"><description>The function used to validate alphanumeric values</description></method><method name="email" scope="instance"><description>The function used to validate email addresses.  Note that this is a very basic validation -- complete
validation per the email RFC specifications is very complex and beyond the scope of this class, although
this function can be overridden if a more comprehensive validation scheme is desired.  See the validation
section of the Wikipedia article on email addresses
for additional information.  This implementation is intended to validate the following emails:
'barney@example.de', 'barney.rubble@example.com', 'barney-rubble@example.coop', 'barney+rubble@example.com'
.</description></method><method name="url" scope="instance"><description>The function used to validate URLs</description></method></methods></class><class superclass="Ext.util.Observable" type="Ext.Component"><description>Base class for all Ext components.  All subclasses of Component may participate in the automated
Ext component lifecycle of creation, rendering and destruction which is provided by the Container class.
Components may be added to a Container through the items config option at the time the Container is created,
or they may be added dynamically via the add method.
The Component base class has built-in support for basic hide/show and enable/disable behavior.
All Components are registered with the Ext.ComponentMgr on construction so that they can be referenced at any time via
Ext.getCmp, passing the id.
All user-developed visual widgets that are required to participate in automated lifecycle and size management should subclass Component (or
Ext.BoxComponent if managed box model handling is required, ie height and width management).
See the Creating new UI controls tutorial for details on how
and to either extend or augment ExtJs base classes to create custom Components.
Every component has a specific xtype, which is its Ext-specific type name, along with methods for checking the
xtype like getXType and isXType. This is the list of all valid xtypes:

xtype            Class
-------------    ------------------
box              Ext.BoxComponent
button           Ext.Button
buttongroup      Ext.ButtonGroup
colorpalette     Ext.ColorPalette
component        Ext.Component
container        Ext.Container
cycle            Ext.CycleButton
dataview         Ext.DataView
datepicker       Ext.DatePicker
editor           Ext.Editor
editorgrid       Ext.grid.EditorGridPanel
flash            Ext.FlashComponent
grid             Ext.grid.GridPanel
listview         Ext.ListView
multislider      Ext.slider.MultiSlider
panel            Ext.Panel
progress         Ext.ProgressBar
propertygrid     Ext.grid.PropertyGrid
slider           Ext.slider.SingleSlider
spacer           Ext.Spacer
splitbutton      Ext.SplitButton
tabpanel         Ext.TabPanel
treepanel        Ext.tree.TreePanel
viewport         Ext.ViewPort
window           Ext.Window

Toolbar components
---------------------------------------
paging           Ext.PagingToolbar
toolbar          Ext.Toolbar
tbbutton         Ext.Toolbar.Button        (deprecated; use button)
tbfill           Ext.Toolbar.Fill
tbitem           Ext.Toolbar.Item
tbseparator      Ext.Toolbar.Separator
tbspacer         Ext.Toolbar.Spacer
tbsplit          Ext.Toolbar.SplitButton   (deprecated; use splitbutton)
tbtext           Ext.Toolbar.TextItem

Menu components
---------------------------------------
menu             Ext.menu.Menu
colormenu        Ext.menu.ColorMenu
datemenu         Ext.menu.DateMenu
menubaseitem     Ext.menu.BaseItem
menucheckitem    Ext.menu.CheckItem
menuitem         Ext.menu.Item
menuseparator    Ext.menu.Separator
menutextitem     Ext.menu.TextItem

Form components
---------------------------------------
form             Ext.form.FormPanel
checkbox         Ext.form.Checkbox
checkboxgroup    Ext.form.CheckboxGroup
combo            Ext.form.ComboBox
compositefield   Ext.form.CompositeField
datefield        Ext.form.DateField
displayfield     Ext.form.DisplayField
field            Ext.form.Field
fieldset         Ext.form.FieldSet
hidden           Ext.form.Hidden
htmleditor       Ext.form.HtmlEditor
label            Ext.form.Label
numberfield      Ext.form.NumberField
radio            Ext.form.Radio
radiogroup       Ext.form.RadioGroup
textarea         Ext.form.TextArea
textfield        Ext.form.TextField
timefield        Ext.form.TimeField
trigger          Ext.form.TriggerField

Chart components
---------------------------------------
chart            Ext.chart.Chart
barchart         Ext.chart.BarChart
cartesianchart   Ext.chart.CartesianChart
columnchart      Ext.chart.ColumnChart
linechart        Ext.chart.LineChart
piechart         Ext.chart.PieChart

Store xtypes
---------------------------------------
arraystore       Ext.data.ArrayStore
directstore      Ext.data.DirectStore
groupingstore    Ext.data.GroupingStore
jsonstore        Ext.data.JsonStore
simplestore      Ext.data.SimpleStore      (deprecated; use arraystore)
store            Ext.data.Store
xmlstore         Ext.data.XmlStore
</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method></methods></class><class superclass="Ext.form.Field" type="Ext.form.DisplayField"><description>A display-only text field which is not validated and not submitted.</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="clearInvalid" scope="instance"><description>Clear any invalid styles/messages for this field</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getActiveError" scope="instance"><description>Gets the active error message for this field.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getErrors" scope="instance"><description>Runs this field's validators and returns an array of error messages for any validation failures.
This is called internally during validation and would not usually need to be used manually.
Each subclass should override or augment the return value to provide their own errors</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getName" scope="instance"><description>Returns the name or hiddenName
attribute of the field if available.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getRawValue" scope="instance"><description>Returns the raw data value which may or may not be a valid, defined value.  To return a normalized value see getValue.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getValue" scope="instance"><description>Returns the normalized data value (undefined or emptyText will be returned as '').  To return the raw value see getRawValue.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isDirty" scope="instance"><description>Returns true if the value of this Field has been changed from its original value.
Will return false if the field is disabled or has not been rendered yet.
Note that if the owning form was configured with
Ext.form.BasicForm.trackResetOnLoad
then the original value is updated when the values are loaded by
Ext.form.BasicForm.setValues.</description></method><method name="isValid" scope="instance"><description>Returns whether or not the field value is currently valid by
validating the processed value
of the field. Note: disabled fields are ignored.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="markInvalid" scope="instance"><description>Display an error message associated with this field, using msgTarget to determine how to
display the message and applying invalidClass to the field's UI element.
Note: this method does not cause the Field's validate method to return false
if the value does pass validation. So simply marking a Field as invalid will not prevent
submission of forms submitted with the Ext.form.Action.Submit.clientValidation option set.
invalid.</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="processValue" scope="instance"><description>This method should only be overridden if necessary to prepare raw values
for validation (see validate and isValid).  This method
is expected to return the processed value for the field which will
be used for validation (see validateValue method).</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="reset" scope="instance"><description>Resets the current field value to the originally loaded value and clears any validation messages.
See Ext.form.BasicForm.trackResetOnLoad</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setActiveError" scope="instance"><description>Sets the current activeError to the given string. Fires the 'invalid' event.
This does not set up the error icon, only sets the message and fires the event. To show the error icon,
use markInvalid instead, which calls this method internally</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setRawValue" scope="instance"><description>Sets the underlying DOM field's value directly, bypassing validation.  To set the value with validation see setValue.</description></method><method name="setReadOnly" scope="instance"><description>Sets the read only state of this field.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setValue" scope="instance"><description>Sets a data value into the field and validates it.  To set the value directly without validation see setRawValue.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="unsetActiveError" scope="instance"><description>Clears the activeError and fires the 'valid' event. This is called internally by clearInvalid and would not
usually need to be called manually</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method><method name="validate" scope="instance"><description>Validates the field value</description></method><method name="validateValue" scope="instance"><description>Uses getErrors to build an array of validation errors. If any errors are found, markInvalid is called
with the first and false is returned, otherwise true is returned. Previously, subclasses were invited
to provide an implementation of this to process validations - from 3.2 onwards getErrors should be
overridden instead.</description></method></methods></class><class superclass="Ext.SplitButton" type="Ext.CycleButton"><description>A specialized SplitButton that contains a menu of Ext.menu.CheckItem elements.  The button automatically
cycles through each menu item on click, raising the button's change event (or calling the button's
changeHandler function, if supplied) for the active menu item. Clicking on the arrow section of the
button displays the dropdown menu just like a normal SplitButton.  Example usage:
var btn = new Ext.CycleButton({
    showText: true,
    prependText: 'View as ',
    items: [{
        text:'text only',
        iconCls:'view-text',
        checked:true
    },{
        text:'HTML',
        iconCls:'view-html'
    }],
    changeHandler:function(btn, item){
        Ext.Msg.alert('Change View', item.text);
    }
});</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getActiveItem" scope="instance"><description>Gets the currently active menu item.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getPressed" scope="instance"><description>Gets the pressed button in the passed group or null</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getTemplateArgs" scope="instance"><description>This method returns an Array which provides substitution parameters for the Template used
to create this Button's DOM structure.
Instances or subclasses which use a different Template to create a different DOM structure may need to provide their
own implementation of this method.
The default implementation which provides data for the default template returns an Array containing the
following items:
The &lt;button&gt;'s type
A CSS class name applied to the Button's main &lt;tbody&gt; element which determines the button's scale and icon alignment.
A CSS class to determine the presence and position of an arrow icon. ('x-btn-arrow' or 'x-btn-arrow-bottom' or '')
The cls CSS class name applied to the button's wrapping &lt;table&gt; element.
The Component id which is applied to the button's wrapping &lt;table&gt; element.
</description></method><method name="getText" scope="instance"><description>Gets the text for this Button</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hasVisibleMenu" scope="instance"><description>Returns true if the button has a menu and it is visible</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="hideMenu" scope="instance"><description>Hide this button's menu (if it has one)</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setActiveItem" scope="instance"><description>Sets the button's active menu item.</description></method><method name="setArrowHandler" scope="instance"><description>Sets this button's arrow click handler.</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHandler" scope="instance"><description>Assigns this Button's click handler</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setIcon" scope="instance"><description>Sets the background image (inline style) of the button.  This method also changes
the value of the icon config internally.</description></method><method name="setIconClass" scope="instance"><description>Sets the CSS class that provides a background image to use as the button's icon.  This method also changes
the value of the iconCls config internally.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setText" scope="instance"><description>Sets this Button's text</description></method><method name="setTooltip" scope="instance"><description>Sets the tooltip for this Button.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="showMenu" scope="instance"><description>Show this button's menu (if it has one)</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="toggle" scope="instance"><description>If a state it passed, it becomes the pressed state otherwise the current state is toggled.</description></method><method name="toggleSelected" scope="instance"><description>This is normally called internally on button click, but can be called externally to advance the button's
active item programmatically to the next one in the menu.  If the current item is the last one in the menu
the active item will be set to the first item in the menu.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method></methods></class><class superclass="Ext.dd.DragDrop" type="Ext.dd.DD"><description>A DragDrop implementation where the linked element follows the
mouse cursor during a drag.</description><constructors/><properties/><methods><method name="addInvalidHandleClass" scope="instance"><description>Lets you specify a css class of elements that will not initiate a drag</description></method><method name="addInvalidHandleId" scope="instance"><description>Lets you to specify an element id for a child of a drag handle
that should not initiate a drag</description></method><method name="addInvalidHandleType" scope="instance"><description>Allows you to specify a tag name that should not start a drag operation
when clicked.  This is designed to facilitate embedding links within a
drag handle that do something other than start the drag.</description></method><method name="addToGroup" scope="instance"><description>Add this instance to a group of related drag/drop objects.  All
instances belong to at least one group, and can belong to as many
groups as needed.</description></method><method name="alignElWithMouse" scope="instance"><description>Sets the element to the location of the mousedown or click event,
maintaining the cursor location relative to the location on the element
that was clicked.  Override this if you want to place the element in a
location other than where the cursor is.</description></method><method name="applyConfig" scope="instance"><description>Sets up config options specific to this class. Overrides
Ext.dd.DragDrop, but all versions of this method through the
inheritance chain are called</description></method><method name="autoOffset" scope="instance"><description>Sets the pointer offset to the distance between the linked element's top
left corner and the location the element was clicked</description></method><method name="b4Drag" scope="instance"><description>Event that fires prior to the onDrag event.  Overrides
Ext.dd.DragDrop.</description></method><method name="b4MouseDown" scope="instance"><description>Event that fires prior to the onMouseDown event.  Overrides
Ext.dd.DragDrop.</description></method><method name="cachePosition" scope="instance"><description>Saves the most recent position so that we can reset the constraints and
tick marks on-demand.  We need to know this so that we can calculate the
number of pixels the element is offset from its original position.</description></method><method name="clearConstraints" scope="instance"><description>Clears any constraints applied to this instance.  Also clears ticks
since they can't exist independent of a constraint at this time.</description></method><method name="clearTicks" scope="instance"><description>Clears any tick interval defined for this instance</description></method><method name="constrainTo" scope="instance"><description>Initializes the drag drop object's constraints to restrict movement to a certain element.
Usage:
 var dd = new Ext.dd.DDProxy(&quot;dragDiv1&quot;, &quot;proxytest&quot;,
                { dragElId: &quot;existingProxyDiv&quot; });
 dd.startDrag = function(){
     this.constrainTo(&quot;parent-id&quot;);
 };
Or you can initalize it using the Ext.Element object:
 Ext.get(&quot;dragDiv1&quot;).initDDProxy(&quot;proxytest&quot;, {dragElId: &quot;existingProxyDiv&quot;}, {
     startDrag : function(){
         this.constrainTo(&quot;parent-id&quot;);
     }
 });</description></method><method name="endDrag" scope="instance"><description>Fired when we are done dragging the object</description></method><method name="getDragEl" scope="instance"><description>Returns a reference to the actual element to drag.  By default this is
the same as the html element, but it can be assigned to another
element. An example of this can be found in Ext.dd.DDProxy</description></method><method name="getEl" scope="instance"><description>Returns a reference to the linked element</description></method><method name="init" scope="instance"><description>Sets up the DragDrop object.  Must be called in the constructor of any
Ext.dd.DragDrop subclass</description></method><method name="initTarget" scope="instance"><description>Initializes Targeting functionality only... the object does not
get a mousedown handler.</description></method><method name="isLocked" scope="instance"><description>Returns true if this instance is locked, or the drag drop mgr is locked
(meaning that all drag/drop is disabled on the page.)</description></method><method name="isValidHandleChild" scope="instance"><description>Checks the tag exclusion list to see if this click should be ignored</description></method><method name="lock" scope="instance"><description>Lock this instance</description></method><method name="onAvailable" scope="instance"><description>Override the onAvailable method to do what is needed after the initial
position was determined.</description></method><method name="onDrag" scope="instance"><description>Abstract method called during the onMouseMove event while dragging an
object.</description></method><method name="onDragDrop" scope="instance"><description>Abstract method called when this item is dropped on another DragDrop
obj</description></method><method name="onDragEnter" scope="instance"><description>Abstract method called when this element fist begins hovering over
another DragDrop obj</description></method><method name="onDragOut" scope="instance"><description>Abstract method called when we are no longer hovering over an element</description></method><method name="onDragOver" scope="instance"><description>Abstract method called when this element is hovering over another
DragDrop obj</description></method><method name="onInvalidDrop" scope="instance"><description>Abstract method called when this item is dropped on an area with no
drop target</description></method><method name="onMouseDown" scope="instance"><description>Event handler that fires when a drag/drop obj gets a mousedown</description></method><method name="onMouseUp" scope="instance"><description>Event handler that fires when a drag/drop obj gets a mouseup</description></method><method name="removeFromGroup" scope="instance"><description>Remove's this instance from the supplied interaction group</description></method><method name="removeInvalidHandleClass" scope="instance"><description>Unsets an invalid css class</description></method><method name="removeInvalidHandleId" scope="instance"><description>Unsets an invalid handle id</description></method><method name="removeInvalidHandleType" scope="instance"><description>Unsets an excluded tag name set by addInvalidHandleType</description></method><method name="resetConstraints" scope="instance"><description>resetConstraints must be called if you manually reposition a dd element.</description></method><method name="setDelta" scope="instance"><description>Sets the pointer offset.  You can call this directly to force the
offset to be in a particular location (e.g., pass in 0,0 to set it
to the center of the object)</description></method><method name="setDragElId" scope="instance"><description>Allows you to specify that an element other than the linked element
will be moved with the cursor during a drag</description></method><method name="setDragElPos" scope="instance"><description>Sets the drag element to the location of the mousedown or click event,
maintaining the cursor location relative to the location on the element
that was clicked.  Override this if you want to place the element in a
location other than where the cursor is.</description></method><method name="setHandleElId" scope="instance"><description>Allows you to specify a child of the linked element that should be
used to initiate the drag operation.  An example of this would be if
you have a content div with text and links.  Clicking anywhere in the
content area would normally start the drag operation.  Use this method
to specify that an element inside of the content div is the element
that starts the drag operation.</description></method><method name="setInitPosition" scope="instance"><description>Stores the initial placement of the linked element.</description></method><method name="setOuterHandleElId" scope="instance"><description>Allows you to set an element outside of the linked element as a drag
handle</description></method><method name="setPadding" scope="instance"><description>Configures the padding for the target zone in px.  Effectively expands
(or reduces) the virtual object size for targeting calculations.
Supports css-style shorthand; if only one parameter is passed, all sides
will have that padding, and if only two are passed, the top and bottom
will have the first param, the left and right the second.</description></method><method name="setXConstraint" scope="instance"><description>By default, the element can be dragged any place on the screen.  Use
this method to limit the horizontal travel of the element.  Pass in
0,0 for the parameters if you want to lock the drag to the y axis.</description></method><method name="setYConstraint" scope="instance"><description>By default, the element can be dragged any place on the screen.  Set
this to limit the vertical travel of the element.  Pass in 0,0 for the
parameters if you want to lock the drag to the x axis.</description></method><method name="startDrag" scope="instance"><description>Abstract method called after a drag/drop object is clicked
and the drag or mousedown time thresholds have beeen met.</description></method><method name="toString" scope="instance"><description>toString method</description></method><method name="unlock" scope="instance"><description>Unlock this instace</description></method><method name="unreg" scope="instance"><description>Remove all drag and drop hooks for this element</description></method></methods></class><class superclass="Ext.Container" type="Ext.Toolbar"><description>Basic Toolbar class. Although the defaultType for Toolbar
is button, Toolbar elements (child items for the Toolbar container) may
be virtually any type of Component. Toolbar elements can be created explicitly via their constructors,
or implicitly via their xtypes, and can be added dynamically.
Some items have shortcut strings for creation:

Shortcut  xtype          Class                  Description
'-&gt;'      'tbfill'       Ext.Toolbar.Fill       begin using the right-justified button container
'-'       'tbseparator'  Ext.Toolbar.Separator  add a vertical separator bar between toolbar items
' '       'tbspacer'     Ext.Toolbar.Spacer     add horiztonal space between elements

Example usage of various elements:
var tb = new Ext.Toolbar({
    renderTo: document.body,
    width: 600,
    height: 100,
    items: [
        {
            // xtype: 'button', // default for Toolbars, same as 'tbbutton'
            text: 'Button'
        },
        {
            xtype: 'splitbutton', // same as 'tbsplitbutton'
            text: 'Split Button'
        },
        // begin using the right-justified button container
        '-&gt;', // same as {xtype: 'tbfill'}, // Ext.Toolbar.Fill
        {
            xtype: 'textfield',
            name: 'field1',
            emptyText: 'enter search term'
        },
        // add a vertical separator bar between toolbar items
        '-', // same as {xtype: 'tbseparator'} to create Ext.Toolbar.Separator
        'text 1', // same as {xtype: 'tbtext', text: 'text1'} to create Ext.Toolbar.TextItem
        {xtype: 'tbspacer'},// same as ' ' to create Ext.Toolbar.Spacer
        'text 2',
        {xtype: 'tbspacer', width: 50}, // add a 50px space
        'text 3'
    ]
});
Example adding a ComboBox within a menu of a button:
// ComboBox creation
var combo = new Ext.form.ComboBox({
    store: new Ext.data.ArrayStore({
        autoDestroy: true,
        fields: ['initials', 'fullname'],
        data : [
            ['FF', 'Fred Flintstone'],
            ['BR', 'Barney Rubble']
        ]
    }),
    displayField: 'fullname',
    typeAhead: true,
    mode: 'local',
    forceSelection: true,
    triggerAction: 'all',
    emptyText: 'Select a name...',
    selectOnFocus: true,
    width: 135,
    getListParent: function() {
        return this.el.up('.x-menu');
    },
    iconCls: 'no-icon' //use iconCls if placing within menu to shift to right side of menu
});

// put ComboBox in a Menu
var menu = new Ext.menu.Menu({
    id: 'mainMenu',
    items: [
        combo // A Field in a Menu
    ]
});

// add a Button with the menu
tb.add({
        text:'Button w/ Menu',
        menu: menu  // assign menu by instance
    });
tb.doLayout();</description><constructors/><properties/><methods><method name="add" scope="instance"><description>Adds element(s) to the toolbar -- this function takes a variable number of
arguments of mixed type and adds them to the toolbar.
Note: See the notes within Ext.Container.add.</description></method><method name="addButton" scope="instance"><description>Adds a button (or buttons). See Ext.Button for more info on the config.
Note: See the notes within Ext.Container.add.</description></method><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addDom" scope="instance"><description>Adds a new element to the toolbar from the passed Ext.DomHelper config
Note: See the notes within Ext.Container.add.</description></method><method name="addElement" scope="instance"><description>Adds any standard HTML element to the toolbar
Note: See the notes within Ext.Container.add.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addField" scope="instance"><description>Adds a dynamically rendered Ext.form field (TextField, ComboBox, etc). Note: the field should not have
been rendered yet. For a field that has already been rendered, use addElement.
Note: See the notes within Ext.Container.add.</description></method><method name="addFill" scope="instance"><description>Forces subsequent additions into the float:right toolbar
Note: See the notes within Ext.Container.add.</description></method><method name="addItem" scope="instance"><description>Adds any Toolbar.Item or subclass
Note: See the notes within Ext.Container.add.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="addSeparator" scope="instance"><description>Adds a separator
Note: See the notes within Ext.Container.add.</description></method><method name="addSpacer" scope="instance"><description>Adds a spacer element
Note: See the notes within Ext.Container.add.</description></method><method name="addText" scope="instance"><description>Adds text to the toolbar
Note: See the notes within Ext.Container.add.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cascade" scope="instance"><description>Cascades down the component/container heirarchy from this component (called first), calling the specified function with
each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the cascade is stopped on that branch.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="doLayout" scope="instance"><description>Force this container's layout to be recalculated. A call to this function is required after adding a new component
to an already rendered container, or possibly after changing sizing/position properties of child components.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="find" scope="instance"><description>Find a component under this container at any level by property</description></method><method name="findBy" scope="instance"><description>Find a component under this container at any level by a custom function. If the passed function returns
true, the component will be included in the results. The passed function is called with the arguments (component, this container).</description></method><method name="findById" scope="instance"><description>Find a component under this container at any level by id</description></method><method name="findByType" scope="instance"><description>Find a component under this container at any level by xtype or class</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="get" scope="instance"><description>Get a component contained by this container (alias for items.get(key))</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getComponent" scope="instance"><description>Examines this container's items property
and gets a direct child component of this container.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getLayout" scope="instance"><description>Returns the layout currently in use by the container.  If the container does not currently have a layout
set, a default Ext.layout.ContainerLayout will be created and set as the container's layout.</description></method><method name="getLayoutTarget" scope="instance"><description>Returns the Element to be used to contain the child Components of this Container.
An implementation is provided which returns the Container's Element, but
if there is a more complex structure to a Container, this may be overridden to return
the element into which the layout renders child Components.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="insert" scope="instance"><description>Inserts a Component into this Container at a specified index. Fires the
beforeadd event before inserting, then fires the add event after the
Component has been inserted.</description></method><method name="insertButton" scope="instance"><description>Inserts any Ext.Toolbar.Item/Ext.Button at the specified index.
Note: See the notes within Ext.Container.add.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="remove" scope="instance"><description>Removes a component from this container.  Fires the beforeremove event before removing, then fires
the remove event after the component has been removed.</description></method><method name="removeAll" scope="instance"><description>Removes all components from this container.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method></methods></class><class superclass="Object" type="Ext.Fx"><description>A class to provide basic animation and visual effects support.  Note: This class is automatically applied
to the Ext.Element interface when included, so all effects calls should be performed via Ext.Element.
Conversely, since the effects are not actually defined in Ext.Element, Ext.Fx must be
included in order for the Element effects to work.
Method Chaining
It is important to note that although the Fx methods and many non-Fx Element methods support &quot;method chaining&quot; in that
they return the Element object itself as the method return value, it is not always possible to mix the two in a single
method chain.  The Fx methods use an internal effects queue so that each effect can be properly timed and sequenced.
Non-Fx methods, on the other hand, have no such internal queueing and will always execute immediately.  For this reason,
while it may be possible to mix certain Fx and non-Fx method calls in a single chain, it may not always provide the
expected results and should be done with care.  Also see callback.
Anchor Options for Motion Effects
Motion effects support 8-way anchoring, meaning that you can choose one of 8 different anchor points on the Element
that will serve as either the start or end point of the animation.  Following are all of the supported anchor positions:

Value  Description
-----  -----------------------------
tl     The top left corner
t      The center of the top edge
tr     The top right corner
l      The center of the left edge
r      The center of the right edge
bl     The bottom left corner
b      The center of the bottom edge
br     The bottom right corner

Note: some Fx methods accept specific custom config parameters.  The options shown in the Config Options
section below are common options that can be passed to any Fx method unless otherwise noted.</description><constructors/><properties/><methods><method name="fadeIn" scope="instance"><description>Fade an element in (from transparent to opaque).  The ending opacity can be specified
using the endOpacity config option.
Usage:
// default: fade in from opacity 0 to 100%
el.fadeIn();

// custom: fade in from opacity 0 to 75% over 2 seconds
el.fadeIn({ endOpacity: .75, duration: 2});

// common config options shown with default values
el.fadeIn({
    endOpacity: 1, //can be any value between 0 and 1 (e.g. .5)
    easing: 'easeOut',
    duration: .5
});</description></method><method name="fadeOut" scope="instance"><description>Fade an element out (from opaque to transparent).  The ending opacity can be specified
using the endOpacity config option.  Note that IE may require
useDisplay:true in order to redisplay correctly.
Usage:
// default: fade out from the element's current opacity to 0
el.fadeOut();

// custom: fade out from the element's current opacity to 25% over 2 seconds
el.fadeOut({ endOpacity: .25, duration: 2});

// common config options shown with default values
el.fadeOut({
    endOpacity: 0, //can be any value between 0 and 1 (e.g. .5)
    easing: 'easeOut',
    duration: .5,
    remove: false,
    useDisplay: false
});</description></method><method name="frame" scope="instance"><description>Shows a ripple of exploding, attenuating borders to draw attention to an Element.
Usage:
// default: a single light blue ripple
el.frame();

// custom: 3 red ripples lasting 3 seconds total
el.frame(&quot;ff0000&quot;, 3, { duration: 3 });

// common config options shown with default values
el.frame(&quot;C3DAF9&quot;, 1, {
    duration: 1 //duration of each individual ripple.
    // Note: Easing is not configurable and will be ignored if included
});</description></method><method name="ghost" scope="instance"><description>Slides the element while fading it out of view.  An anchor point can be optionally passed to set the 
ending point of the effect.
Usage:
// default: slide the element downward while fading out
el.ghost();

// custom: slide the element out to the right with a 2-second duration
el.ghost('r', { duration: 2 });

// common config options shown with default values
el.ghost('b', {
    easing: 'easeOut',
    duration: .5,
    remove: false,
    useDisplay: false
});</description></method><method name="hasActiveFx" scope="instance"><description>Returns true if the element has any effects actively running or queued, else returns false.</description></method><method name="hasFxBlock" scope="instance"><description>Returns true if the element is currently blocking so that no other effect can be queued
until this effect is finished, else returns false if blocking is not set.  This is commonly
used to ensure that an effect initiated by a user action runs to completion prior to the
same effect being restarted (e.g., firing only one effect even if the user clicks several times).</description></method><method name="highlight" scope="instance"><description>Highlights the Element by setting a color (applies to the background-color by default, but can be
changed using the &quot;attr&quot; config option) and then fading back to the original color. If no original
color is available, you should provide the &quot;endColor&quot; config option which will be cleared after the animation.
Usage:
// default: highlight background to yellow
el.highlight();

// custom: highlight foreground text to blue for 2 seconds
el.highlight(&quot;0000ff&quot;, { attr: 'color', duration: 2 });

// common config options shown with default values
el.highlight(&quot;ffff9c&quot;, {
    attr: &quot;background-color&quot;, //can be any valid CSS property (attribute) that supports a color value
    endColor: (current color) or &quot;ffffff&quot;,
    easing: 'easeIn',
    duration: 1
});</description></method><method name="pause" scope="instance"><description>Creates a pause before any subsequent queued effects begin.  If there are
no effects queued after the pause it will have no effect.
Usage:
el.pause(1);</description></method><method name="puff" scope="instance"><description>Fades the element out while slowly expanding it in all directions.  When the effect is completed, the 
element will be hidden (visibility = 'hidden') but block elements will still take up space in the document. 
The element must be removed from the DOM using the 'remove' config option if desired.
Usage:
// default
el.puff();

// common config options shown with default values
el.puff({
    easing: 'easeOut',
    duration: .5,
    remove: false,
    useDisplay: false
});</description></method><method name="scale" scope="instance"><description>Animates the transition of an element's dimensions from a starting height/width
to an ending height/width.  This method is a convenience implementation of shift.
Usage:
// change height and width to 100x100 pixels
el.scale(100, 100);

// common config options shown with default values.  The height and width will default to
// the element&#39;s existing values if passed as null.
el.scale(
    [element&#39;s width],
    [element&#39;s height], {
        easing: 'easeOut',
        duration: .35
    }
);</description></method><method name="sequenceFx" scope="instance"><description>Ensures that all effects queued after sequenceFx is called on the element are
run in sequence.  This is the opposite of syncFx.</description></method><method name="shift" scope="instance"><description>Animates the transition of any combination of an element's dimensions, xy position and/or opacity.
Any of these properties not specified in the config object will not be changed.  This effect 
requires that at least one new dimension, position or opacity setting must be passed in on
the config object in order for the function to have any effect.
Usage:
// slide the element horizontally to x position 200 while changing the height and opacity
el.shift({ x: 200, height: 50, opacity: .8 });

// common config options shown with default values.
el.shift({
    width: [element&#39;s width],
    height: [element&#39;s height],
    x: [element&#39;s x position],
    y: [element&#39;s y position],
    opacity: [element&#39;s opacity],
    easing: 'easeOut',
    duration: .35
});</description></method><method name="slideIn" scope="instance"><description>Slides the element into view.  An anchor point can be optionally passed to set the point of
origin for the slide effect.  This function automatically handles wrapping the element with
a fixed-size container if needed.  See the Fx class overview for valid anchor point options.
Usage:
// default: slide the element in from the top
el.slideIn();

// custom: slide the element in from the right with a 2-second duration
el.slideIn('r', { duration: 2 });

// common config options shown with default values
el.slideIn('t', {
    easing: 'easeOut',
    duration: .5
});</description></method><method name="slideOut" scope="instance"><description>Slides the element out of view.  An anchor point can be optionally passed to set the end point
for the slide effect.  When the effect is completed, the element will be hidden (visibility = 
'hidden') but block elements will still take up space in the document.  The element must be removed
from the DOM using the 'remove' config option if desired.  This function automatically handles 
wrapping the element with a fixed-size container if needed.  See the Fx class overview for valid anchor point options.
Usage:
// default: slide the element out to the top
el.slideOut();

// custom: slide the element out to the right with a 2-second duration
el.slideOut('r', { duration: 2 });

// common config options shown with default values
el.slideOut('t', {
    easing: 'easeOut',
    duration: .5,
    remove: false,
    useDisplay: false
});</description></method><method name="stopFx" scope="instance"><description>Stops any running effects and clears the element's internal effects queue if it contains
any additional effects that haven't started yet.</description></method><method name="switchOff" scope="instance"><description>Blinks the element as if it was clicked and then collapses on its center (similar to switching off a television).
When the effect is completed, the element will be hidden (visibility = 'hidden') but block elements will still 
take up space in the document. The element must be removed from the DOM using the 'remove' config option if desired.
Usage:
// default
el.switchOff();

// all config options shown with default values
el.switchOff({
    easing: 'easeIn',
    duration: .3,
    remove: false,
    useDisplay: false
});</description></method><method name="syncFx" scope="instance"><description>Ensures that all effects queued after syncFx is called on the element are
run concurrently.  This is the opposite of sequenceFx.</description></method></methods></class><class superclass="Object" type="Ext.Updater.BasicRenderer"><description>This class is a base class implementing a simple render method which updates an element using results from an Ajax request.
The BasicRenderer updates the element's innerHTML with the responseText. To perform a custom render (i.e. XML or JSON processing),
create an object with a conforming render method and pass it to setRenderer on the Updater.</description><constructors/><properties/><methods><method name="render" scope="instance"><description>This method is called when an Ajax response is received, and an Element needs updating.</description></method></methods></class><class superclass="Ext.dd.DropZone" type="Ext.tree.TreeDropZone"><description/><constructors/><properties/><methods><method name="addInvalidHandleClass" scope="instance"><description>Lets you specify a css class of elements that will not initiate a drag</description></method><method name="addInvalidHandleId" scope="instance"><description>Lets you to specify an element id for a child of a drag handle
that should not initiate a drag</description></method><method name="addInvalidHandleType" scope="instance"><description>Allows you to specify a tag name that should not start a drag operation
when clicked.  This is designed to facilitate embedding links within a
drag handle that do something other than start the drag.</description></method><method name="addToGroup" scope="instance"><description>Add this instance to a group of related drag/drop objects.  All
instances belong to at least one group, and can belong to as many
groups as needed.</description></method><method name="applyConfig" scope="instance"><description>Applies the configuration parameters that were passed into the constructor.
This is supposed to happen at each level through the inheritance chain.  So
a DDProxy implentation will execute apply config on DDProxy, DD, and
DragDrop in order to get all of the parameters that are available in
each object.</description></method><method name="clearConstraints" scope="instance"><description>Clears any constraints applied to this instance.  Also clears ticks
since they can't exist independent of a constraint at this time.</description></method><method name="clearTicks" scope="instance"><description>Clears any tick interval defined for this instance</description></method><method name="constrainTo" scope="instance"><description>Initializes the drag drop object's constraints to restrict movement to a certain element.
Usage:
 var dd = new Ext.dd.DDProxy(&quot;dragDiv1&quot;, &quot;proxytest&quot;,
                { dragElId: &quot;existingProxyDiv&quot; });
 dd.startDrag = function(){
     this.constrainTo(&quot;parent-id&quot;);
 };
Or you can initalize it using the Ext.Element object:
 Ext.get(&quot;dragDiv1&quot;).initDDProxy(&quot;proxytest&quot;, {dragElId: &quot;existingProxyDiv&quot;}, {
     startDrag : function(){
         this.constrainTo(&quot;parent-id&quot;);
     }
 });</description></method><method name="endDrag" scope="instance"><description>Fired when we are done dragging the object</description></method><method name="getDragEl" scope="instance"><description>Returns a reference to the actual element to drag.  By default this is
the same as the html element, but it can be assigned to another
element. An example of this can be found in Ext.dd.DDProxy</description></method><method name="getEl" scope="instance"><description>Returns a reference to the linked element</description></method><method name="getTargetFromEvent" scope="instance"><description>Returns a custom data object associated with the DOM node that is the target of the event.  By default
this looks up the event target in the Ext.dd.Registry, although you can override this method to
provide your own custom lookup.</description></method><method name="init" scope="instance"><description>Sets up the DragDrop object.  Must be called in the constructor of any
Ext.dd.DragDrop subclass</description></method><method name="initTarget" scope="instance"><description>Initializes Targeting functionality only... the object does not
get a mousedown handler.</description></method><method name="isLocked" scope="instance"><description>Returns true if this instance is locked, or the drag drop mgr is locked
(meaning that all drag/drop is disabled on the page.)</description></method><method name="isValidHandleChild" scope="instance"><description>Checks the tag exclusion list to see if this click should be ignored</description></method><method name="lock" scope="instance"><description>Lock this instance</description></method><method name="notifyDrop" scope="instance"><description>The function a Ext.dd.DragSource calls once to notify this drop zone that the dragged item has
been dropped on it.  The drag zone will look up the target node based on the event passed in, and if there
is a node registered for that event, it will delegate to onNodeDrop for node-specific handling,
otherwise it will call onContainerDrop.</description></method><method name="notifyEnter" scope="instance"><description>The function a Ext.dd.DragSource calls once to notify this drop zone that the source is now over
the zone.  The default implementation returns this.dropNotAllowed and expects that only registered drop
nodes can process drag drop operations, so if you need the drop zone itself to be able to process drops
you should override this method and provide a custom implementation.</description></method><method name="notifyOut" scope="instance"><description>The function a Ext.dd.DragSource calls once to notify this drop zone that the source has been dragged
out of the zone without dropping.  If the drag source is currently over a registered node, the notification
will be delegated to onNodeOut for node-specific handling, otherwise it will be ignored.</description></method><method name="notifyOver" scope="instance"><description>The function a Ext.dd.DragSource calls continuously while it is being dragged over the drop zone.
This method will be called on every mouse movement while the drag source is over the drop zone.
It will call onNodeOver while the drag source is over a registered node, and will also automatically
delegate to the appropriate node-specific methods as necessary when the drag source enters and exits
registered nodes (onNodeEnter, onNodeOut). If the drag source is not currently over a
registered node, it will call onContainerOver.</description></method><method name="onAvailable" scope="instance"><description>Override the onAvailable method to do what is needed after the initial
position was determined.</description></method><method name="onContainerDrop" scope="instance"><description>Called when the DropZone determines that a Ext.dd.DragSource has been dropped on it,
but not on any of its registered drop nodes.  The default implementation returns false, so it should be
overridden to provide the appropriate processing of the drop event if you need the drop zone itself to
be able to accept drops.  It should return true when valid so that the drag source's repair action does not run.</description></method><method name="onContainerOver" scope="instance"><description>Called while the DropZone determines that a Ext.dd.DragSource is being dragged over it,
but not over any of its registered drop nodes.  The default implementation returns this.dropNotAllowed, so
it should be overridden to provide the proper feedback if necessary.</description></method><method name="onDrag" scope="instance"><description>Abstract method called during the onMouseMove event while dragging an
object.</description></method><method name="onDragDrop" scope="instance"><description>Abstract method called when this item is dropped on another DragDrop
obj</description></method><method name="onDragEnter" scope="instance"><description>Abstract method called when this element fist begins hovering over
another DragDrop obj</description></method><method name="onDragOut" scope="instance"><description>Abstract method called when we are no longer hovering over an element</description></method><method name="onDragOver" scope="instance"><description>Abstract method called when this element is hovering over another
DragDrop obj</description></method><method name="onInvalidDrop" scope="instance"><description>Abstract method called when this item is dropped on an area with no
drop target</description></method><method name="onMouseDown" scope="instance"><description>Event handler that fires when a drag/drop obj gets a mousedown</description></method><method name="onMouseUp" scope="instance"><description>Event handler that fires when a drag/drop obj gets a mouseup</description></method><method name="onNodeDrop" scope="instance"><description>Called when the DropZone determines that a Ext.dd.DragSource has been dropped onto
the drop node.  The default implementation returns false, so it should be overridden to provide the
appropriate processing of the drop event and return true so that the drag source's repair action does not run.</description></method><method name="onNodeEnter" scope="instance"><description>Called when the DropZone determines that a Ext.dd.DragSource has entered a drop node
that has either been registered or detected by a configured implementation of getTargetFromEvent.
This method has no default implementation and should be overridden to provide
node-specific processing if necessary.</description></method><method name="onNodeOut" scope="instance"><description>Called when the DropZone determines that a Ext.dd.DragSource has been dragged out of
the drop node without dropping.  This method has no default implementation and should be overridden to provide
node-specific processing if necessary.</description></method><method name="onNodeOver" scope="instance"><description>Called while the DropZone determines that a Ext.dd.DragSource is over a drop node
that has either been registered or detected by a configured implementation of getTargetFromEvent.
The default implementation returns this.dropNotAllowed, so it should be
overridden to provide the proper feedback.</description></method><method name="removeFromGroup" scope="instance"><description>Remove's this instance from the supplied interaction group</description></method><method name="removeInvalidHandleClass" scope="instance"><description>Unsets an invalid css class</description></method><method name="removeInvalidHandleId" scope="instance"><description>Unsets an invalid handle id</description></method><method name="removeInvalidHandleType" scope="instance"><description>Unsets an excluded tag name set by addInvalidHandleType</description></method><method name="resetConstraints" scope="instance"><description>resetConstraints must be called if you manually reposition a dd element.</description></method><method name="setDragElId" scope="instance"><description>Allows you to specify that an element other than the linked element
will be moved with the cursor during a drag</description></method><method name="setHandleElId" scope="instance"><description>Allows you to specify a child of the linked element that should be
used to initiate the drag operation.  An example of this would be if
you have a content div with text and links.  Clicking anywhere in the
content area would normally start the drag operation.  Use this method
to specify that an element inside of the content div is the element
that starts the drag operation.</description></method><method name="setInitPosition" scope="instance"><description>Stores the initial placement of the linked element.</description></method><method name="setOuterHandleElId" scope="instance"><description>Allows you to set an element outside of the linked element as a drag
handle</description></method><method name="setPadding" scope="instance"><description>Configures the padding for the target zone in px.  Effectively expands
(or reduces) the virtual object size for targeting calculations.
Supports css-style shorthand; if only one parameter is passed, all sides
will have that padding, and if only two are passed, the top and bottom
will have the first param, the left and right the second.</description></method><method name="setXConstraint" scope="instance"><description>By default, the element can be dragged any place on the screen.  Use
this method to limit the horizontal travel of the element.  Pass in
0,0 for the parameters if you want to lock the drag to the y axis.</description></method><method name="setYConstraint" scope="instance"><description>By default, the element can be dragged any place on the screen.  Set
this to limit the vertical travel of the element.  Pass in 0,0 for the
parameters if you want to lock the drag to the x axis.</description></method><method name="startDrag" scope="instance"><description>Abstract method called after a drag/drop object is clicked
and the drag or mousedown time thresholds have beeen met.</description></method><method name="toString" scope="instance"><description>toString method</description></method><method name="unlock" scope="instance"><description>Unlock this instace</description></method><method name="unreg" scope="instance"><description>Remove all drag and drop hooks for this element</description></method></methods></class><class superclass="Ext.chart.Series" type="Ext.chart.PieSeries"><description>PieSeries class for the charts widget.</description><constructors/><properties/><methods/></class><class superclass="Ext.form.TriggerField" type="Ext.form.ComboBox"><description>A combobox control with support for autocomplete, remote-loading, paging and many other features.
A ComboBox works in a similar manner to a traditional HTML &lt;select&gt; field. The difference is
that to submit the valueField, you must specify a hiddenName to create a hidden input
field to hold the value of the valueField. The displayField is shown in the text field
which is named according to the name.
Events
To do something when something in ComboBox is selected, configure the select event:var cb = new Ext.form.ComboBox({
    // all of your config options
    listeners:{
         scope: yourScope,
         'select': yourFunction
    }
});

// Alternatively, you can assign events after the object is created:
var cb = new Ext.form.ComboBox(yourOptions);
cb.on('select', yourFunction, yourScope);
ComboBox in Grid
If using a ComboBox in an Editor Grid a renderer
will be needed to show the displayField when the editor is not active.  Set up the renderer manually, or implement
a reusable render, for example:// create reusable renderer
Ext.util.Format.comboRenderer = function(combo){
    return function(value){
        var record = combo.findRecord(combo.valueField, value);
        return record ? record.get(combo.displayField) : combo.valueNotFoundText;
    }
}

// create the combo instance
var combo = new Ext.form.ComboBox({
    typeAhead: true,
    triggerAction: 'all',
    lazyRender:true,
    mode: 'local',
    store: new Ext.data.ArrayStore({
        id: 0,
        fields: [
            'myId',
            'displayText'
        ],
        data: [[1, 'item1'], [2, 'item2']]
    }),
    valueField: 'myId',
    displayField: 'displayText'
});

// snippet of column model used within grid
var cm = new Ext.grid.ColumnModel([{
       ...
    },{
       header: &quot;Some Header&quot;,
       dataIndex: 'whatever',
       width: 130,
       editor: combo, // specify reference to combo instance
       renderer: Ext.util.Format.comboRenderer(combo) // pass combo instance to reusable renderer
    },
    ...
]);
Filtering
A ComboBox uses filtering itself, for information about filtering the ComboBox
store manually see lastQuery.</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="clearInvalid" scope="instance"><description>Clear any invalid styles/messages for this field</description></method><method name="clearValue" scope="instance"><description>Clears any text/value currently set in the field</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="collapse" scope="instance"><description>Hides the dropdown list if it is currently expanded. Fires the collapse event on completion.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="doQuery" scope="instance"><description>Execute a query to filter the dropdown list.  Fires the beforequery event prior to performing the
query allowing the query action to be canceled if needed.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="expand" scope="instance"><description>Expands the dropdown list if it is currently hidden. Fires the expand event on completion.</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getActiveError" scope="instance"><description>Gets the active error message for this field.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getErrors" scope="instance"><description>Validates a value according to the field's validation rules and returns an array of errors
for any failing validations. Validation rules are processed in the following order:

1. Field specific validator

A validator offers a way to customize and reuse a validation specification.
If a field is configured with a validator
function, it will be passed the current field value.  The validator
function is expected to return either:

Boolean true if the value is valid (validation continues).
a String to represent the invalid message if invalid (validation halts).


2. Basic Validation

If the validator has not halted validation,
basic validation proceeds as follows:

allowBlank : (Invalid message =
emptyText)
Depending on the configuration of allowBlank, a
blank field will cause validation to halt at this step and return
Boolean true or false accordingly.  

minLength : (Invalid message =
minLengthText)
If the passed value does not satisfy the minLength
specified, validation halts.

maxLength : (Invalid message =
maxLengthText)
If the passed value does not satisfy the maxLength
specified, validation halts.



3. Preconfigured Validation Types (VTypes)

If none of the prior validation steps halts validation, a field
configured with a vtype will utilize the
corresponding VTypes validation function.
If invalid, either the field's vtypeText or
the VTypes vtype Text property will be used for the invalid message.
Keystrokes on the field will be filtered according to the VTypes
vtype Mask property.

4. Field specific regex test

If none of the prior validation steps halts validation, a field's
configured regex test will be processed.
The invalid message for this test is configured with
regexText.
</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getListParent" scope="instance"><description>Returns the element used to house this ComboBox's pop-up list. Defaults to the document body.
A custom implementation may be provided as a configuration option if the floating list needs to be rendered
to a different Element. An example might be rendering the list inside a Menu so that clicking
the list does not hide the Menu:var store = new Ext.data.ArrayStore({
    autoDestroy: true,
    fields: ['initials', 'fullname'],
    data : [
        ['FF', 'Fred Flintstone'],
        ['BR', 'Barney Rubble']
    ]
});

var combo = new Ext.form.ComboBox({
    store: store,
    displayField: 'fullname',
    emptyText: 'Select a name...',
    forceSelection: true,
    getListParent: function() {
        return this.el.up('.x-menu');
    },
    iconCls: 'no-icon', //use iconCls if placing within menu to shift to right side of menu
    mode: 'local',
    selectOnFocus: true,
    triggerAction: 'all',
    typeAhead: true,
    width: 135
});

var menu = new Ext.menu.Menu({
    id: 'mainMenu',
    items: [
        combo // A Field in a Menu
    ]
});</description></method><method name="getName" scope="instance"><description>Returns the name or hiddenName
attribute of the field if available.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getRawValue" scope="instance"><description>Returns the raw data value which may or may not be a valid, defined value.  To return a normalized value see getValue.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getStore" scope="instance"><description>Returns the store associated with this combo.</description></method><method name="getValue" scope="instance"><description>Returns the currently selected field value or empty string if no value is set.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isDirty" scope="instance"><description>Returns true if the value of this Field has been changed from its original value.
Will return false if the field is disabled or has not been rendered yet.
Note that if the owning form was configured with
Ext.form.BasicForm.trackResetOnLoad
then the original value is updated when the values are loaded by
Ext.form.BasicForm.setValues.</description></method><method name="isExpanded" scope="instance"><description>Returns true if the dropdown list is expanded, else false.</description></method><method name="isValid" scope="instance"><description>Returns whether or not the field value is currently valid by
validating the processed value
of the field. Note: disabled fields are ignored.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="markInvalid" scope="instance"><description>Display an error message associated with this field, using msgTarget to determine how to
display the message and applying invalidClass to the field's UI element.
Note: this method does not cause the Field's validate method to return false
if the value does pass validation. So simply marking a Field as invalid will not prevent
submission of forms submitted with the Ext.form.Action.Submit.clientValidation option set.
invalid.</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="processValue" scope="instance"><description>This method should only be overridden if necessary to prepare raw values
for validation (see validate and isValid).  This method
is expected to return the processed value for the field which will
be used for validation (see validateValue method).</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="reset" scope="instance"><description>Resets the current field value to the originally-loaded value and clears any validation messages.
Also adds emptyText and emptyClass if the
original value was blank.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="select" scope="instance"><description>Select an item in the dropdown list by its numeric index in the list. This function does NOT cause the select event to fire.
The store must be loaded and the list expanded for this function to work, otherwise use setValue.</description></method><method name="selectByValue" scope="instance"><description>Select an item in the dropdown list by its data value. This function does NOT cause the select event to fire.
The store must be loaded and the list expanded for this function to work, otherwise use setValue.</description></method><method name="selectText" scope="instance"><description>Selects text in this field</description></method><method name="setActiveError" scope="instance"><description>Sets the current activeError to the given string. Fires the 'invalid' event.
This does not set up the error icon, only sets the message and fires the event. To show the error icon,
use markInvalid instead, which calls this method internally</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setEditable" scope="instance"><description>Allow or prevent the user from directly editing the field text.  If false is passed,
the user will only be able to modify the field using the trigger.  Will also add
a click event to the text field which will call the trigger. This method
is the runtime equivalent of setting the editable config option at config time.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setHideTrigger" scope="instance"><description>Changes the hidden status of the trigger.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setRawValue" scope="instance"><description>Sets the underlying DOM field's value directly, bypassing validation.  To set the value with validation see setValue.</description></method><method name="setReadOnly" scope="instance"><description>Setting this to true will supersede settings editable and hideTrigger.
Setting this to false will defer back to editable and hideTrigger. This method
is the runtime equivalent of setting the readOnly config option at config time.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setValue" scope="instance"><description>Sets the specified value into the field.  If the value finds a match, the corresponding record text
will be displayed in the field.  If the value does not match the data value of an existing item,
and the valueNotFoundText config option is defined, it will be displayed as the default field text.
Otherwise the field will be blank (although the value will still be set).</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="unsetActiveError" scope="instance"><description>Clears the activeError and fires the 'valid' event. This is called internally by clearInvalid and would not
usually need to be called manually</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method><method name="validate" scope="instance"><description>Validates the field value</description></method><method name="validateValue" scope="instance"><description>Uses getErrors to build an array of validation errors. If any errors are found, markInvalid is called
with the first and false is returned, otherwise true is returned. Previously, subclasses were invited
to provide an implementation of this to process validations - from 3.2 onwards getErrors should be
overridden instead.</description></method></methods></class><class superclass="Object" type="Ext.EventManager"><description>Registers event handlers that want to receive a normalized EventObject instead of the standard browser event and provides
several useful events directly.
See Ext.EventObject for more details on normalized event objects.</description><constructors/><properties/><methods><method name="addListener" scope="instance"><description>Appends an event handler to an element.  The shorthand version on is equivalent.  Typically you will
use Ext.Element.addListener directly on an Element in favor of calling this version.</description></method><method name="function" scope="instance"><description></description></method><method name="handleError" scope="instance"><description>Framework-wide error-handler.  Developers can override this method to provide
custom exception-handling.  Framework errors will often extend from the base
Ext.Error class.</description></method><method name="hasModifier" scope="instance"><description>Returns true if the control, meta, shift or alt key was pressed during this event.</description></method><method name="on" scope="instance"><description>Appends an event handler to an element.  Shorthand for addListener.</description></method><method name="onDocumentReady" scope="instance"><description>Adds a listener to be notified when the document is ready (before onload and before images are loaded). Can be
accessed shorthanded as Ext.onReady().</description></method><method name="onTextResize" scope="instance"><description>Adds a listener to be notified when the user changes the active text size. Handler gets called with 2 params, the old size and the new size.</description></method><method name="onWindowResize" scope="instance"><description>Adds a listener to be notified when the browser window is resized and provides resize event buffering (100 milliseconds),
passes new viewport width and height to handlers.</description></method><method name="removeAll" scope="instance"><description>Removes all event handers from an element.  Typically you will use Ext.Element.removeAllListeners
directly on an Element in favor of calling this version.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler from an element.  The shorthand version un is equivalent.  Typically
you will use Ext.Element.removeListener directly on an Element in favor of calling this version.</description></method><method name="removeResizeListener" scope="instance"><description>Removes the passed window resize listener.</description></method><method name="un" scope="instance"><description>Removes an event handler from an element.  Shorthand for removeListener.</description></method></methods></class><class superclass="Ext.data.Store" type="Ext.data.JsonStore"><description>Small helper class to make creating Ext.data.Stores from JSON data easier.
A JsonStore will be automatically configured with a Ext.data.JsonReader.
A store configuration would be something like:var store = new Ext.data.JsonStore({
    // store configs
    autoDestroy: true,
    url: 'get-images.php',
    storeId: 'myStore',
    // reader configs
    root: 'images',
    idProperty: 'name',
    fields: ['name', 'url', {name:'size', type: 'float'}, {name:'lastmod', type:'date'}]
});
This store is configured to consume a returned object of the form:{
    images: [
        {name: 'Image one', url:'/GetImage.php?id=1', size:46.5, lastmod: new Date(2007, 10, 29)},
        {name: 'Image Two', url:'/GetImage.php?id=2', size:43.2, lastmod: new Date(2007, 10, 30)}
    ]
}
An object literal of this form could also be used as the data config option.
*Note: Although not listed here, this class accepts all of the configuration options of
JsonReader.</description><constructors/><properties/><methods><method name="add" scope="instance"><description>Add Records to the Store and fires the add event.  To add Records
to the store from a remote source use load({add:true}).
See also recordType and insert.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="addSorted" scope="instance"><description>(Local sort only) Inserts the passed Record into the Store at the index where it
should go based on the current sort information.</description></method><method name="clearFilter" scope="instance"><description>Revert to a view of the Record cache with no filtering applied.</description></method><method name="collect" scope="instance"><description>Collects unique values for a particular dataIndex from this store.</description></method><method name="commitChanges" scope="instance"><description>Commit all Records with outstanding changes. To handle updates for changes,
subscribe to the Store's update event, and perform updating when the third parameter is
Ext.data.Record.COMMIT.</description></method><method name="destroy" scope="instance"><description>Destroys the store.</description></method><method name="each" scope="instance"><description>Calls the specified function for each of the Records in the cache.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="filter" scope="instance"><description>Filter the records by a specified property. Alternatively, pass an array of filter
options to filter by more than one property.
Single filter example:
store.filter('name', 'Ed', true, true); //finds all records containing the substring 'Ed'
Multiple filter example:
store.filter([
{
property     : 'name',
value        : 'Ed',
anyMatch     : true, //optional, defaults to true
caseSensitive: true  //optional, defaults to true
},
//filter functions can also be passed
{
fn   : function(record) {
return record.get('age') == 24
},
scope: this
}
]);</description></method><method name="filterBy" scope="instance"><description>Filter by a function. The specified function will be called for each
Record in this Store. If the function returns true the Record is included,
otherwise it is filtered out.</description></method><method name="find" scope="instance"><description>Finds the index of the first matching Record in this store by a specific field value.</description></method><method name="findBy" scope="instance"><description>Find the index of the first matching Record in this Store by a function.
If the function returns true it is considered a match.</description></method><method name="findExact" scope="instance"><description>Finds the index of the first matching Record in this store by a specific field value.</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="getAt" scope="instance"><description>Get the Record at the specified index.</description></method><method name="getById" scope="instance"><description>Get the Record with the specified id.</description></method><method name="getCount" scope="instance"><description>Gets the number of cached records.
If using paging, this may not be the total size of the dataset. If the data object
used by the Reader contains the dataset size, then the getTotalCount function returns
the dataset size.  Note: see the Important note in load.</description></method><method name="getModifiedRecords" scope="instance"><description>Gets all records modified since the last commit.  Modified records are
persisted across load operations (e.g., during paging). Note: deleted records are not
included.  See also pruneModifiedRecords and
Ext.data.RecordmarkDirty..</description></method><method name="getRange" scope="instance"><description>Returns a range of Records between specified indices.</description></method><method name="getSortState" scope="instance"><description>Returns an object describing the current sort state of this Store.</description></method><method name="getTotalCount" scope="instance"><description>Gets the total number of records in the dataset as returned by the server.
If using paging, for this to be accurate, the data object used by the Reader
must contain the dataset size. For remote data sources, the value for this property
(totalProperty for JsonReader,
totalRecords for XmlReader) shall be returned by a query on the server.
Note: see the Important note in load.</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="indexOf" scope="instance"><description>Get the index within the cache of the passed Record.</description></method><method name="indexOfId" scope="instance"><description>Get the index within the cache of the Record with the passed id.</description></method><method name="insert" scope="instance"><description>Inserts Records into the Store at the given index and fires the add event.
See also add and addSorted.</description></method><method name="isFiltered" scope="instance"><description>Returns true if this store is currently filtered</description></method><method name="load" scope="instance"><description>Loads the Record cache from the configured proxy using the configured reader.
Notes:
Important: loading is asynchronous! This call will return before the new data has been
loaded. To perform any post-processing where information from the load call is required, specify
the callback function to be called, or use a a 'load' event handler.
If using remote paging, the first load call must specify the start and limit
properties in the options.params property to establish the initial position within the
dataset, and the number of Records to cache on each read from the Proxy.
If using remote sorting, the configured sortInfo
will be automatically included with the posted parameters according to the specified
paramNames.
</description></method><method name="loadData" scope="instance"><description>Loads data from a passed data block and fires the load event. A Reader
which understands the format of the data must have been configured in the constructor.</description></method><method name="multiSort" scope="instance"><description>Sorts the contents of this store by multiple field/direction sorters. This is called internally by sort
and would not usually be called manually.
Multi sorting only currently applies to local datasets - multiple sort data is not currently sent to a proxy
if remoteSort is used.</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="query" scope="instance"><description>Query the records by a specified property.</description></method><method name="queryBy" scope="instance"><description>Query the cached records in this Store using a filtering function. The specified function
will be called with each record in this Store. If the function returns true the record is
included in the results.</description></method><method name="rejectChanges" scope="instance"><description>Reject outstanding changes on all modified records.</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="reload" scope="instance"><description>Reloads the Record cache from the configured Proxy using the configured
Reader and the options from the last load operation
performed.
Note: see the Important note in load.</description></method><method name="remove" scope="instance"><description>Remove Records from the Store and fires the remove event.</description></method><method name="removeAll" scope="instance"><description>Remove all Records from the Store and fires the clear event.</description></method><method name="removeAt" scope="instance"><description>Remove a Record from the Store at the specified index. Fires the remove event.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="save" scope="instance"><description>Saves all pending changes to the store.  If the commensurate Ext.data.Api.actions action is not configured, then
the configured url will be used.

change            url
---------------   --------------------
removed records   Ext.data.Api.actions.destroy
phantom records   Ext.data.Api.actions.create
modified records  Ext.data.Api.actions.update
</description></method><method name="setBaseParam" scope="instance"><description>Set the value for a property name in this store's baseParams.  Usage:myStore.setBaseParam('foo', {bar:3});</description></method><method name="setDefaultSort" scope="instance"><description>Sets the default sort column and order to be used by the next load operation.</description></method><method name="singleSort" scope="instance"><description>Sorts the store contents by a single field and direction. This is called internally by sort and would
not usually be called manually</description></method><method name="sort" scope="instance"><description>Sort the Records.
If remote sorting is used, the sort is performed on the server, and the cache is reloaded. If local
sorting is used, the cache is sorted internally. See also remoteSort and paramNames.
This function accepts two call signatures - pass in a field name as the first argument to sort on a single
field, or pass in an array of sort configuration objects to sort by multiple fields.
Single sort example:
store.sort('name', 'ASC');
Multi sort example:
store.sort([
{
field    : 'name',
direction: 'ASC'
},
{
field    : 'salary',
direction: 'DESC'
}
], 'ASC');
In this second form, the sort configs are applied in order, with later sorters sorting within earlier sorters' results.
For example, if two records with the same name are present they will also be sorted by salary if given the sort configs
above. Any number of sort configs can be added.</description></method><method name="sum" scope="instance"><description>Sums the value of property for each record between start
and end and returns the result.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method></methods></class><class superclass="Object" type="Ext.form.Action"><description>The subclasses of this class provide actions to perform upon Forms.
Instances of this class are only created by a Form when
the Form needs to perform an action such as submit or load. The Configuration options
listed for this class are set through the Form's action methods: submit,
load and doAction
The instance of Action which performed the action is passed to the success
and failure callbacks of the Form's action methods (submit,
load and doAction),
and to the actioncomplete and
actionfailed event handlers.</description><constructors/><properties/><methods/></class><class superclass="Ext.layout.boxOverflow.Scroller" type="Ext.layout.boxOverflow.VerticalScroller"><description>Description</description><constructors/><properties/><methods><method name="getScrollPosition" scope="instance"><description>Returns the current scroll position of the innerCt element</description></method><method name="scrollToItem" scope="instance"><description>Scrolls to the given component.</description></method></methods></class><class superclass="Ext.grid.Column" type="Ext.grid.NumberColumn"><description>A Column definition class which renders a numeric data field according to a format string.  See the
xtype config option of Ext.grid.Column for more details.</description><constructors/><properties/><methods><method name="getCellEditor" scope="instance"><description>Returns the editor defined for this column that was created to wrap the Field
used to edit the cell.</description></method><method name="setEditor" scope="instance"><description>Sets a new editor for this column.</description></method></methods></class><class superclass="Ext.util.Observable" type="Ext.grid.ColumnModel"><description>After the data has been read into the client side cache (Store),
the ColumnModel is used to configure how and what parts of that data will be displayed in the
vertical slices (columns) of the grid. The Ext.grid.ColumnModel Class is the default implementation
of a ColumnModel used by implentations of GridPanel.
Data is mapped into the store's records and then indexed into the ColumnModel using the
dataIndex:
{data source} == mapping ==&gt; {data store} == dataIndex ==&gt; {ColumnModel}
Each Column in the grid's ColumnModel is configured with a
dataIndex to specify how the data within
each record in the store is indexed into the ColumnModel.
There are two ways to initialize the ColumnModel class:
Initialization Method 1: an Array
var colModel = new Ext.grid.ColumnModel([
    { header: &quot;Ticker&quot;, width: 60, sortable: true},
    { header: &quot;Company Name&quot;, width: 150, sortable: true, id: 'company'},
    { header: &quot;Market Cap.&quot;, width: 100, sortable: true},
    { header: &quot;$ Sales&quot;, width: 100, sortable: true, renderer: money},
    { header: &quot;Employees&quot;, width: 100, sortable: true, resizable: false}
 ]);
The ColumnModel may be initialized with an Array of Ext.grid.Column column configuration
objects to define the initial layout / display of the columns in the Grid. The order of each
Ext.grid.Column column configuration object within the specified Array defines the initial
order of the column display.  A Column's display may be initially hidden using the
hidden config property (and then shown using the column
header menu).  Fields that are not included in the ColumnModel will not be displayable at all.
How each column in the grid correlates (maps) to the Ext.data.Record field in the
Store the column draws its data from is configured through the
dataIndex.  If the
dataIndex is not explicitly defined (as shown in the
example above) it will use the column configuration's index in the Array as the index.
See Ext.grid.Column for additional configuration options for each column.
Initialization Method 2: an Object
In order to use configuration options from Ext.grid.ColumnModel, an Object may be used to
initialize the ColumnModel.  The column configuration Array will be specified in the columns
config property. The defaults config property can be used to apply defaults
for all columns, e.g.:var colModel = new Ext.grid.ColumnModel({
    columns: [
        { header: &quot;Ticker&quot;, width: 60, menuDisabled: false},
        { header: &quot;Company Name&quot;, width: 150, id: 'company'},
        { header: &quot;Market Cap.&quot;},
        { header: &quot;$ Sales&quot;, renderer: money},
        { header: &quot;Employees&quot;, resizable: false}
    ],
    defaults: {
        sortable: true,
        menuDisabled: true,
        width: 100
    },
    listeners: {
        hiddenchange: function(cm, colIndex, hidden) {
            saveConfig(colIndex, hidden);
        }
    }
});
In both examples above, the ability to apply a CSS class to all cells in a column (including the
header) is demonstrated through the use of the id config
option. This column could be styled by including the following css://add this css *after* the core css is loaded
.x-grid3-td-company {
    color: red; // entire column will have red font
}
// modify the header row only, adding an icon to the column header
.x-grid3-hd-company {
    background: transparent
        url(../../resources/images/icons/silk/building.png)
        no-repeat 3px 3px ! important;
        padding-left:20px;
}
Note that the &quot;Company Name&quot; column could be specified as the
Ext.grid.GridPanel.autoExpandColumn.</description><constructors/><properties/><methods><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="destroy" scope="instance"><description>Destroys this column model by purging any event listeners. Destroys and dereferences all Columns.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findColumnIndex" scope="instance"><description>Finds the index of the first matching column for the given dataIndex.</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="getCellEditor" scope="instance"><description>Returns the editor defined for the cell/column.</description></method><method name="getColumnById" scope="instance"><description>Returns the column for a specified id.</description></method><method name="getColumnCount" scope="instance"><description>Returns the number of columns.</description></method><method name="getColumnHeader" scope="instance"><description>Returns the header for the specified column.</description></method><method name="getColumnId" scope="instance"><description>Returns the id of the column at the specified index.</description></method><method name="getColumnTooltip" scope="instance"><description>Returns the tooltip for the specified column.</description></method><method name="getColumnWidth" scope="instance"><description>Returns the width for the specified column.</description></method><method name="getColumnsBy" scope="instance"><description>Returns the column configs that return true by the passed function that is called
with (columnConfig, index)
// returns an array of column config objects for all hidden columns
var columns = grid.getColumnModel().getColumnsBy(function(c){
  return c.hidden;
});</description></method><method name="getDataIndex" scope="instance"><description>Returns the dataIndex for the specified column.
// Get field name for the column
var fieldName = grid.getColumnModel().getDataIndex(columnIndex);</description></method><method name="getIndexById" scope="instance"><description>Returns the index for a specified column id.</description></method><method name="getRenderer" scope="instance"><description>Returns the rendering (formatting) function defined for the column.</description></method><method name="getTotalWidth" scope="instance"><description>Returns the total width of all columns.</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="isCellEditable" scope="instance"><description>Returns true if the cell is editable.
var store = new Ext.data.Store({...});
var colModel = new Ext.grid.ColumnModel({
  columns: [...],
  isCellEditable: function(col, row) {
    var record = store.getAt(row);
    if (record.get('readonly')) { // replace with your condition
      return false;
    }
    return Ext.grid.ColumnModel.prototype.isCellEditable.call(this, col, row);
  }
});
var grid = new Ext.grid.GridPanel({
  store: store,
  colModel: colModel,
  ...
});</description></method><method name="isFixed" scope="instance"><description>Returns true if the column is fixed,
false otherwise.</description></method><method name="isHidden" scope="instance"><description>Returns true if the column is hidden,
false otherwise.</description></method><method name="isMenuDisabled" scope="instance"><description>Returns true if the specified column menu is disabled.</description></method><method name="isResizable" scope="instance"><description>Returns true if the column can be resized</description></method><method name="isSortable" scope="instance"><description>Returns true if the specified column is sortable.</description></method><method name="moveColumn" scope="instance"><description>Moves a column from one position to another.</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setColumnHeader" scope="instance"><description>Sets the header for a column.</description></method><method name="setColumnTooltip" scope="instance"><description>Sets the tooltip for a column.</description></method><method name="setColumnWidth" scope="instance"><description>Sets the width for a column.</description></method><method name="setConfig" scope="instance"><description>Reconfigures this column model according to the passed Array of column definition objects.
For a description of the individual properties of a column definition object, see the
Config Options.
Causes the configchange event to be fired. A GridPanel
using this ColumnModel will listen for this event and refresh its UI automatically.</description></method><method name="setDataIndex" scope="instance"><description>Sets the dataIndex for a column.</description></method><method name="setEditable" scope="instance"><description>Sets if a column is editable.</description></method><method name="setEditor" scope="instance"><description>Sets the editor for a column and destroys the prior editor.</description></method><method name="setHidden" scope="instance"><description>Sets if a column is hidden.
myGrid.getColumnModel().setHidden(0, true); // hide column 0 (0 = the first column).</description></method><method name="setRenderer" scope="instance"><description>Sets the rendering (formatting) function for a column.  See Ext.util.Format for some
default formatting functions.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method></methods></class><class superclass="Ext.BoxComponent" type="Ext.FlashComponent"><description/><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method></methods></class><class superclass="Ext.BoxComponent" type="Ext.form.Label"><description>Basic Label field.</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setText" scope="instance"><description>Updates the label's innerHTML with the specified string.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method></methods></class><class superclass="Ext.grid.GridPanel" type="Ext.grid.EditorGridPanel"><description>This class extends the GridPanel Class to provide cell editing
on selected columns. The editable columns are specified by providing
an editor in the column configuration.
Editability of columns may be controlled programatically by inserting an implementation
of isCellEditable into the
ColumnModel.
Editing is performed on the value of the field specified by the column's
dataIndex in the backing Store
(so if you are using a renderer in order to display
transformed data, this must be accounted for).
If a value-to-description mapping is used to render a column, then a ComboBox
which uses the same value-to-description
mapping would be an appropriate editor.
If there is a more complex mismatch between the visible data in the grid, and the editable data in
the Store, then code to transform the data both before and after editing can be
injected using the beforeedit and afteredit events.</description><constructors/><properties/><methods><method name="add" scope="instance"><description>Adds Component(s) to this Container.
Description :

Fires the beforeadd event before adding
The Container's default config values will be applied
accordingly (see defaults for details).
Fires the add event after the component has been added.

Notes :

If the Container is already rendered when add
is called, you may need to call doLayout to refresh the view which causes
any unrendered child Components to be rendered. This is required so that you can
add multiple child components if needed while only refreshing the layout
once. For example:var tb = new Ext.Toolbar();
tb.render(document.body);  // toolbar is rendered
tb.add({text:'Button 1'}); // add multiple items (defaultType for Toolbar is 'button')
tb.add({text:'Button 2'});
tb.doLayout();             // refresh the layout
Warning: Containers directly managed by the BorderLayout layout manager
may not be removed or added.  See the Notes for BorderLayout
for more details.
</description></method><method name="addButton" scope="instance"><description>Adds a button to this panel.  Note that this method must be called prior to rendering.  The preferred
approach is to add buttons via the buttons config.</description></method><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cascade" scope="instance"><description>Cascades down the component/container heirarchy from this component (called first), calling the specified function with
each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the cascade is stopped on that branch.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="collapse" scope="instance"><description>Collapses the panel body so that it becomes hidden.  Fires the beforecollapse event which will
cancel the collapse action if it returns false.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="doLayout" scope="instance"><description>Force this container's layout to be recalculated. A call to this function is required after adding a new component
to an already rendered container, or possibly after changing sizing/position properties of child components.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="expand" scope="instance"><description>Expands the panel body so that it becomes visible.  Fires the beforeexpand event which will
cancel the expand action if it returns false.</description></method><method name="find" scope="instance"><description>Find a component under this container at any level by property</description></method><method name="findBy" scope="instance"><description>Find a component under this container at any level by a custom function. If the passed function returns
true, the component will be included in the results. The passed function is called with the arguments (component, this container).</description></method><method name="findById" scope="instance"><description>Find a component under this container at any level by id</description></method><method name="findByType" scope="instance"><description>Find a component under this container at any level by xtype or class</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="get" scope="instance"><description>Get a component contained by this container (alias for items.get(key))</description></method><method name="getBottomToolbar" scope="instance"><description>Returns the toolbar from the bottom (bbar) section of the panel.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getColumnModel" scope="instance"><description>Returns the grid's ColumnModel.</description></method><method name="getComponent" scope="instance"><description>Examines this container's items property
and gets a direct child component of this container.</description></method><method name="getDragDropText" scope="instance"><description>Called to get grid's drag proxy text, by default returns this.ddText.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getFooterToolbar" scope="instance"><description>Returns the toolbar from the footer (fbar) section of the panel.</description></method><method name="getFrameHeight" scope="instance"><description>Returns the height in pixels of the framing elements of this panel (including any top and bottom bars and
header and footer elements, but not including the body height).  To retrieve the body height see getInnerHeight.</description></method><method name="getFrameWidth" scope="instance"><description>Returns the width in pixels of the framing elements of this panel (not including the body width).  To
retrieve the body width see getInnerWidth.</description></method><method name="getGridEl" scope="instance"><description>Returns the grid's underlying element.</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getInnerHeight" scope="instance"><description>Returns the height in pixels of the body element (not including the height of any framing elements).
For the frame height see getFrameHeight.</description></method><method name="getInnerWidth" scope="instance"><description>Returns the width in pixels of the body element (not including the width of any framing elements).
For the frame width see getFrameWidth.</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getLayout" scope="instance"><description>Returns the layout currently in use by the container.  If the container does not currently have a layout
set, a default Ext.layout.ContainerLayout will be created and set as the container's layout.</description></method><method name="getLayoutTarget" scope="instance"><description>Returns the Element to be used to contain the child Components of this Container.
An implementation is provided which returns the Container's Element, but
if there is a more complex structure to a Container, this may be overridden to return
the element into which the layout renders child Components.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSelectionModel" scope="instance"><description>Returns the grid's selection model configured by the selModel
configuration option. If no selection model was configured, this will create
and return a RowSelectionModel.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getStore" scope="instance"><description>Returns the grid's data store.</description></method><method name="getTool" scope="instance"><description>Retrieve a tool by id.</description></method><method name="getTopToolbar" scope="instance"><description>Returns the toolbar from the top (tbar) section of the panel.</description></method><method name="getUpdater" scope="instance"><description>Get the Ext.Updater for this panel. Enables you to perform Ajax updates of this panel's body.</description></method><method name="getView" scope="instance"><description>Returns the grid's GridView object.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="insert" scope="instance"><description>Inserts a Component into this Container at a specified index. Fires the
beforeadd event before inserting, then fires the add event after the
Component has been inserted.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="load" scope="instance"><description>Loads this content panel immediately with content returned from an XHR call.</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="reconfigure" scope="instance"><description>Reconfigures the grid to use a different Store and Column Model
and fires the 'reconfigure' event. The View will be bound to the new
objects and refreshed.
Be aware that upon reconfiguring a GridPanel, certain existing settings may become
invalidated. For example the configured autoExpandColumn may no longer exist in the
new ColumnModel. Also, an existing PagingToolbar will still be bound
to the old Store, and will need rebinding. Any plugins might also need reconfiguring
with the new data.</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="remove" scope="instance"><description>Removes a component from this container.  Fires the beforeremove event before removing, then fires
the remove event after the component has been removed.</description></method><method name="removeAll" scope="instance"><description>Removes all components from this container.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setIconClass" scope="instance"><description>Sets the CSS class that provides the icon image for this panel.  This method will replace any existing
icon class if one has already been set and fire the iconchange event after completion.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setTitle" scope="instance"><description>Sets the title text for the panel and optionally the icon class.
In order to be able to set the title, a header element must have been created
for the Panel. This is triggered either by configuring the Panel with a non-blank title,
or configuring it with header: true.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="startEditing" scope="instance"><description>Starts editing the specified for the specified row/column</description></method><method name="stopEditing" scope="instance"><description>Stops any active editing</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="toggleCollapse" scope="instance"><description>Shortcut for performing an expand or collapse based on the current state of the panel.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method></methods></class><class superclass="Object" type="Ext.Updater.defaults"><description>The defaults collection enables customizing the default properties of Updater</description><constructors/><properties/><methods/></class><class superclass="Ext.CompositeElementLite" type="Ext.CompositeElement"><description>This class encapsulates a collection of DOM elements, providing methods to filter
members, or to perform collective actions upon the whole set.
Although they are not listed, this class supports all of the methods of Ext.Element and
Ext.Fx. The methods from these classes will be performed on all the elements in this collection.
All methods return this and can be chained.
Usage:
var els = Ext.select(&quot;#some-el div.some-class&quot;, true);
// or select directly from an existing element
var el = Ext.get('some-el');
el.select('div.some-class', true);

els.setWidth(100); // all elements become 100 width
els.hide(true); // all elements fade out and hide
// or
els.setWidth(100).hide(true);</description><constructors/><properties/><methods><method name="" scope="instance"><description>Iterates each element in this composite
calling the supplied function using Ext.each.</description></method><method name="add" scope="instance"><description>Adds elements to this Composite object.</description></method><method name="clear" scope="instance"><description>Removes all elements.</description></method><method name="contains" scope="instance"><description>Returns true if this composite contains the passed element</description></method><method name="each" scope="instance"><description>Calls the passed function for each element in this composite.</description></method><method name="fill" scope="instance"><description>Clears this Composite and adds the elements passed.</description></method><method name="filter" scope="instance"><description>Filters this composite to only elements that match the passed selector.</description></method><method name="first" scope="instance"><description>Returns the first Element</description></method><method name="getCount" scope="instance"><description>Returns the number of elements in this Composite.</description></method><method name="indexOf" scope="instance"><description>Find the index of the passed element within the composite collection.</description></method><method name="item" scope="instance"><description>Returns a flyweight Element of the dom element object at the specified index</description></method><method name="last" scope="instance"><description>Returns the last Element</description></method><method name="removeElement" scope="instance"><description>Removes the specified element(s).</description></method><method name="replaceElement" scope="instance"><description>Replaces the specified element with the passed element.</description></method></methods></class><class superclass="Ext.layout.AnchorLayout" type="Ext.layout.FormLayout"><description>This layout manager is specifically designed for rendering and managing child Components of
forms. It is responsible for rendering the labels of
Fields.
This layout manager is used when a Container is configured with the layout:'form'
layout config option, and should generally not need to be created directly
via the new keyword. See Ext.Container.layout for additional details.
In an application, it will usually be preferrable to use a FormPanel
(which is configured with FormLayout as its layout class by default) since it also provides built-in
functionality for loading, validating and submitting the form.
A Container using the FormLayout layout manager (e.g.
Ext.form.FormPanel or specifying layout:'form') can also accept the following
layout-specific config properties:
hideLabels
labelAlign
labelPad
labelSeparator
labelWidth

Any Component (including Fields) managed by FormLayout accepts the following as a config option:

anchor

Any Component managed by FormLayout may be rendered as a form field (with an associated label) by
configuring it with a non-null fieldLabel. Components configured
in this way may be configured with the following options which affect the way the FormLayout renders them:

clearCls
fieldLabel
hideLabel
itemCls
labelSeparator
labelStyle

Example usage:
// Required if showing validation messages
Ext.QuickTips.init();

// While you can create a basic Panel with layout:'form', practically
// you should usually use a FormPanel to also get its form functionality
// since it already creates a FormLayout internally.
var form = new Ext.form.FormPanel({
    title: 'Form Layout',
    bodyStyle: 'padding:15px',
    width: 350,
    defaultType: 'textfield',
    defaults: {
        // applied to each contained item
        width: 230,
        msgTarget: 'side'
    },
    items: [{
            fieldLabel: 'First Name',
            name: 'first',
            allowBlank: false,
            labelSeparator: ':' // override labelSeparator layout config
        },{
            fieldLabel: 'Last Name',
            name: 'last'
        },{
            fieldLabel: 'Email',
            name: 'email',
            vtype:'email'
        }, {
            xtype: 'textarea',
            hideLabel: true,     // override hideLabels layout config
            name: 'msg',
            anchor: '100% -53'
        }
    ],
    buttons: [
        {text: 'Save'},
        {text: 'Cancel'}
    ],
    layoutConfig: {
        labelSeparator: '~' // superseded by assignment below
    },
    // config options applicable to container when layout='form':
    hideLabels: false,
    labelAlign: 'left',   // or 'right' or 'top'
    labelSeparator: '&gt;&gt;', // takes precedence over layoutConfig value
    labelWidth: 65,       // defaults to 100
    labelPad: 8           // defaults to 5, must specify labelWidth to be honored
});</description><constructors/><properties/><methods><method name="getTemplateArgs" scope="instance"><description>Provides template arguments for rendering the fully wrapped, labeled and styled form Field.
This method returns an object hash containing properties used by the layout's fieldTpl
to create a correctly wrapped, labeled and styled form Field. This may be overriden to
create custom layouts. The properties which must be returned are:
itemCls : StringThe CSS class applied to the outermost div wrapper
that contains this field label and field element (the default class is 'x-form-item' and itemCls
will be added to that). If supplied, itemCls at the field level will override the default itemCls
supplied at the container level.
id : StringThe id of the Field
labelStyle : String
A CSS style specification string to add to the field label for this field (defaults to '' or the
layout's value for labelStyle).
label : StringThe text to display as the label for this
field (defaults to the field's configured fieldLabel property)
labelSeparator : StringThe separator to display after
the text of the label for this field (defaults to a colon ':' or the
layout's value for labelSeparator). To hide the separator use empty string ''.
elementStyle : StringThe styles text for the input element's wrapper.
clearCls : StringThe CSS class to apply to the special clearing div
rendered directly after each form field wrapper (defaults to 'x-form-clear-left')
</description></method><method name="parseMargins" scope="instance"><description>Parses a number or string representing margin sizes into an object. Supports CSS-style margin declarations
(e.g. 10, &quot;10&quot;, &quot;10 10&quot;, &quot;10 10 10&quot; and &quot;10 10 10 10&quot; are all valid options and would return the same result)</description></method></methods></class><class superclass="Ext.util.Observable" type="Ext.direct.Provider"><description>Ext.direct.Provider is an abstract class meant to be extended.
For example ExtJs implements the following subclasses:
Provider
|
+---JsonProvider 
    |
    +---PollingProvider   
    |
    +---RemotingProvider</description><constructors/><properties/><methods><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="isConnected" scope="instance"><description>Returns whether or not the server-side is currently connected.
Abstract method for subclasses to implement.</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method></methods></class><class superclass="Ext.util.Observable" type="Ext.grid.GridView"><description>This class encapsulates the user interface of an Ext.grid.GridPanel.
Methods of this class may be used to access user interface elements to enable
special display effects. Do not change the DOM structure of the user interface.
This class does not provide ways to manipulate the underlying data. The data
model of a Grid is held in an Ext.data.Store.</description><constructors/><properties/><methods><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findCellIndex" scope="instance"><description>Return the index of the grid column which contains the passed HTMLElement.
See also findRowIndex</description></method><method name="findRow" scope="instance"><description>Return the HtmlElement representing the grid row which contains the passed element.</description></method><method name="findRowBody" scope="instance"><description>Return the HtmlElement representing the grid row body which contains the passed element.</description></method><method name="findRowIndex" scope="instance"><description>Return the index of the grid row which contains the passed HTMLElement.
See also findCellIndex</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focusCell" scope="instance"><description>Focuses the specified cell.</description></method><method name="focusRow" scope="instance"><description>Focuses the specified row.</description></method><method name="getCell" scope="instance"><description>Returns the grid's &lt;td&gt; HtmlElement at the specified coordinates.</description></method><method name="getGridInnerWidth" scope="instance"><description>Returns the total internal width available to the grid, taking the scrollbar into account</description></method><method name="getHeaderCell" scope="instance"><description>Return the &lt;td&gt; HtmlElement which represents the Grid's header cell for the specified column index.</description></method><method name="getRow" scope="instance"><description>Return the &lt;div&gt; HtmlElement which represents a Grid row for the specified index.</description></method><method name="getRowClass" scope="instance"><description>Override this function to apply custom CSS classes to rows during rendering.  You can also supply custom
parameters to the row template for the current row to customize how it is rendered using the rowParams
parameter.  This function should return the CSS class name (or empty string '' for none) that will be added
to the row's wrapping div.  To apply multiple class names, simply return them space-delimited within the string
(e.g., 'my-class another-class'). Example usage:
    viewConfig: {
    forceFit: true,
    showPreview: true, // custom property
    enableRowBody: true, // required to create a second, full-width row to show expanded Record data
    getRowClass: function(record, rowIndex, rp, ds){ // rp = rowParams
        if(this.showPreview){
            rp.body = '&lt;p&gt;'+record.data.excerpt+'&lt;/p&gt;';
            return 'x-grid3-row-expanded';
        }
        return 'x-grid3-row-collapsed';
    }
},</description></method><method name="handleHdMenuClickDefault" scope="instance"><description>Called by handleHdMenuClick if any button except a sort ASC/DESC button was clicked. The default implementation provides
the column hide/show functionality based on the check state of the menu item. A different implementation can be provided
if needed.</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="refresh" scope="instance"><description>Refreshs the grid UI</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="scrollToTop" scope="instance"><description>Scrolls the grid to the top</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method></methods></class><class superclass="Ext.chart.CartesianChart" type="Ext.chart.StackedBarChart"><description/><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bindStore" scope="instance"><description>Changes the data store bound to this chart and refreshes it.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setSeriesStyles" scope="instance"><description>Sets the styles on all series in the Chart.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setStyle" scope="instance"><description>Sets a single style value on the Chart instance.</description></method><method name="setStyles" scope="instance"><description>Resets all styles on the Chart instance.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method></methods></class><class superclass="Ext.Toolbar.Item" type="Ext.Toolbar.TextItem"><description>A simple class that renders text directly into a toolbar
(with css class:'xtb-text'). Example usage:
new Ext.Panel({
    tbar : [
        {xtype: 'tbtext', text: 'Item 1'} // or simply 'Item 1'
    ]
});</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setText" scope="instance"><description>Updates this item's text, setting the text to be used as innerHTML.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method></methods></class><class superclass="Ext.Error" type="Ext.data.Api.Error"><description>Error class for Ext.data.Api errors</description><constructors/><properties/><methods><method name="getMessage" scope="instance"><description>getMessage</description></method><method name="getName" scope="instance"><description>getName</description></method><method name="toJson" scope="instance"><description>toJson</description></method></methods></class><class superclass="Ext.Panel" type="Ext.form.FieldSet"><description>Standard container used for grouping items within a form.
var form = new Ext.FormPanel({
    title: 'Simple Form with FieldSets',
    labelWidth: 75, // label settings here cascade unless overridden
    url: 'save-form.php',
    frame:true,
    bodyStyle:'padding:5px 5px 0',
    width: 700,
    renderTo: document.body,
    layout:'column', // arrange items in columns
    defaults: {      // defaults applied to items
        layout: 'form',
        border: false,
        bodyStyle: 'padding:4px'
    },
    items: [{
        // Fieldset in Column 1
        xtype:'fieldset',
        columnWidth: 0.5,
        title: 'Fieldset 1',
        collapsible: true,
        autoHeight:true,
        defaults: {
            anchor: '-20' // leave room for error icon
        },
        defaultType: 'textfield',
        items :[{
                fieldLabel: 'Field 1'
            }, {
                fieldLabel: 'Field 2'
            }, {
                fieldLabel: 'Field 3'
            }
        ]
    },{
        // Fieldset in Column 2 - Panel inside
        xtype:'fieldset',
        title: 'Show Panel', // title, header, or checkboxToggle creates fieldset header
        autoHeight:true,
        columnWidth: 0.5,
        checkboxToggle: true,
        collapsed: true, // fieldset initially collapsed
        layout:'anchor',
        items :[{
            xtype: 'panel',
            anchor: '100%',
            title: 'Panel inside a fieldset',
            frame: true,
            height: 100
        }]
    }]
});</description><constructors/><properties/><methods><method name="add" scope="instance"><description>Adds Component(s) to this Container.
Description :

Fires the beforeadd event before adding
The Container's default config values will be applied
accordingly (see defaults for details).
Fires the add event after the component has been added.

Notes :

If the Container is already rendered when add
is called, you may need to call doLayout to refresh the view which causes
any unrendered child Components to be rendered. This is required so that you can
add multiple child components if needed while only refreshing the layout
once. For example:var tb = new Ext.Toolbar();
tb.render(document.body);  // toolbar is rendered
tb.add({text:'Button 1'}); // add multiple items (defaultType for Toolbar is 'button')
tb.add({text:'Button 2'});
tb.doLayout();             // refresh the layout
Warning: Containers directly managed by the BorderLayout layout manager
may not be removed or added.  See the Notes for BorderLayout
for more details.
</description></method><method name="addButton" scope="instance"><description>Adds a button to this panel.  Note that this method must be called prior to rendering.  The preferred
approach is to add buttons via the buttons config.</description></method><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cascade" scope="instance"><description>Cascades down the component/container heirarchy from this component (called first), calling the specified function with
each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the cascade is stopped on that branch.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="collapse" scope="instance"><description>Collapses the panel body so that it becomes hidden.  Fires the beforecollapse event which will
cancel the collapse action if it returns false.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="doLayout" scope="instance"><description>Force this container's layout to be recalculated. A call to this function is required after adding a new component
to an already rendered container, or possibly after changing sizing/position properties of child components.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="expand" scope="instance"><description>Expands the panel body so that it becomes visible.  Fires the beforeexpand event which will
cancel the expand action if it returns false.</description></method><method name="find" scope="instance"><description>Find a component under this container at any level by property</description></method><method name="findBy" scope="instance"><description>Find a component under this container at any level by a custom function. If the passed function returns
true, the component will be included in the results. The passed function is called with the arguments (component, this container).</description></method><method name="findById" scope="instance"><description>Find a component under this container at any level by id</description></method><method name="findByType" scope="instance"><description>Find a component under this container at any level by xtype or class</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="get" scope="instance"><description>Get a component contained by this container (alias for items.get(key))</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getComponent" scope="instance"><description>Examines this container's items property
and gets a direct child component of this container.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getFooterToolbar" scope="instance"><description>Returns the toolbar from the footer (fbar) section of the panel.</description></method><method name="getFrameHeight" scope="instance"><description>Returns the height in pixels of the framing elements of this panel (including any top and bottom bars and
header and footer elements, but not including the body height).  To retrieve the body height see getInnerHeight.</description></method><method name="getFrameWidth" scope="instance"><description>Returns the width in pixels of the framing elements of this panel (not including the body width).  To
retrieve the body width see getInnerWidth.</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getInnerHeight" scope="instance"><description>Returns the height in pixels of the body element (not including the height of any framing elements).
For the frame height see getFrameHeight.</description></method><method name="getInnerWidth" scope="instance"><description>Returns the width in pixels of the body element (not including the width of any framing elements).
For the frame width see getFrameWidth.</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getLayout" scope="instance"><description>Returns the layout currently in use by the container.  If the container does not currently have a layout
set, a default Ext.layout.ContainerLayout will be created and set as the container's layout.</description></method><method name="getLayoutTarget" scope="instance"><description>Returns the Element to be used to contain the child Components of this Container.
An implementation is provided which returns the Container's Element, but
if there is a more complex structure to a Container, this may be overridden to return
the element into which the layout renders child Components.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getTool" scope="instance"><description>Retrieve a tool by id.</description></method><method name="getUpdater" scope="instance"><description>Get the Ext.Updater for this panel. Enables you to perform Ajax updates of this panel's body.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="insert" scope="instance"><description>Inserts a Component into this Container at a specified index. Fires the
beforeadd event before inserting, then fires the add event after the
Component has been inserted.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="load" scope="instance"><description>Loads this content panel immediately with content returned from an XHR call.</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="onCheckClick" scope="instance"><description>This function is called by the fieldset's checkbox when it is toggled (only applies when
checkboxToggle = true).  This method should never be called externally, but can be
overridden to provide custom behavior when the checkbox is toggled if needed.</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="remove" scope="instance"><description>Removes a component from this container.  Fires the beforeremove event before removing, then fires
the remove event after the component has been removed.</description></method><method name="removeAll" scope="instance"><description>Removes all components from this container.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setTitle" scope="instance"><description>Sets the title text for the panel and optionally the icon class.
In order to be able to set the title, a header element must have been created
for the Panel. This is triggered either by configuring the Panel with a non-blank title,
or configuring it with header: true.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="toggleCollapse" scope="instance"><description>Shortcut for performing an expand or collapse based on the current state of the panel.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method></methods></class><class superclass="Object" type="Ext.dd.Registry"><description>Provides easy access to all drag drop components that are registered on a page.  Items can be retrieved either
directly by DOM node id, or by passing in the drag drop event that occurred and looking up the event target.</description><constructors/><properties/><methods><method name="getHandle" scope="instance"><description>Returns the handle registered for a DOM Node by id</description></method><method name="getHandleFromEvent" scope="instance"><description>Returns the handle that is registered for the DOM node that is the target of the event</description></method><method name="getTarget" scope="instance"><description>Returns a custom data object that is registered for a DOM node by id</description></method><method name="getTargetFromEvent" scope="instance"><description>Returns a custom data object that is registered for the DOM node that is the target of the event</description></method><method name="register" scope="instance"><description>Resgister a drag drop element</description></method><method name="unregister" scope="instance"><description>Unregister a drag drop element</description></method></methods></class><class superclass="Object" type="Ext.data.JsonReader.Error"><description>Error class for JsonReader</description><constructors/><properties/><methods/></class><class superclass="Ext.layout.FitLayout" type="Ext.layout.AccordionLayout"><description>This is a layout that manages multiple Panels in an expandable accordion style such that only
one Panel can be expanded at any given time. Each Panel has built-in support for expanding and collapsing.
Note: Only Ext.Panels and all subclasses of Ext.Panel may be used in an accordion layout Container.
This class is intended to be extended or created via the layout
configuration property.  See Ext.Container.layout for additional details.
Example usage:
var accordion = new Ext.Panel({
    title: 'Accordion Layout',
    layout:'accordion',
    defaults: {
        // applied to each contained panel
        bodyStyle: 'padding:15px'
    },
    layoutConfig: {
        // layout-specific configs go here
        titleCollapse: false,
        animate: true,
        activeOnTop: true
    },
    items: [{
        title: 'Panel 1',
        html: '&lt;p&gt;Panel content!&lt;/p&gt;'
    },{
        title: 'Panel 2',
        html: '&lt;p&gt;Panel content!&lt;/p&gt;'
    },{
        title: 'Panel 3',
        html: '&lt;p&gt;Panel content!&lt;/p&gt;'
    }]
});</description><constructors/><properties/><methods><method name="parseMargins" scope="instance"><description>Parses a number or string representing margin sizes into an object. Supports CSS-style margin declarations
(e.g. 10, &quot;10&quot;, &quot;10 10&quot;, &quot;10 10 10&quot; and &quot;10 10 10 10&quot; are all valid options and would return the same result)</description></method><method name="setActiveItem" scope="instance"><description>Sets the active (expanded) item in the layout.</description></method></methods></class><class superclass="Ext.chart.Chart" type="Ext.chart.PieChart"><description/><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bindStore" scope="instance"><description>Changes the data store bound to this chart and refreshes it.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setSeriesStyles" scope="instance"><description>Sets the styles on all series in the Chart.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setStyle" scope="instance"><description>Sets a single style value on the Chart instance.</description></method><method name="setStyles" scope="instance"><description>Resets all styles on the Chart instance.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method></methods></class><class superclass="Ext.state.Provider" type="Ext.state.CookieProvider"><description>The default Provider implementation which saves state via cookies.
Usage:
 var cp = new Ext.state.CookieProvider({
       path: &quot;/cgi-bin/&quot;,
       expires: new Date(new Date().getTime()+(1000*60*60*24*30)), //30 days
       domain: &quot;extjs.com&quot;
   });
   Ext.state.Manager.setProvider(cp);</description><constructors/><properties/><methods><method name="clear" scope="instance"><description>Clears a value from the state</description></method><method name="decodeValue" scope="instance"><description>Decodes a string previously encoded with encodeValue.</description></method><method name="encodeValue" scope="instance"><description>Encodes a value including type information.  Decode with decodeValue.</description></method><method name="get" scope="instance"><description>Returns the current value for a key</description></method><method name="set" scope="instance"><description>Sets the value for a key</description></method></methods></class><class superclass="Ext.Toolbar.Spacer" type="Ext.Toolbar.Fill"><description>A non-rendering placeholder item which instructs the Toolbar's Layout to begin using
the right-justified button container.
new Ext.Panel({
    tbar : [
        'Item 1',
        {xtype: 'tbfill'}, // or '-&gt;'
        'Item 2'
    ]
});</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method></methods></class><class superclass="Ext.util.Observable" type="Ext.dd.DragTracker"><description>A DragTracker listens for drag events on an Element and fires events at the start and end of the drag,
as well as during the drag. This is useful for components such as Ext.slider.MultiSlider, where there is
an element that can be dragged around to change the Slider's value.
DragTracker provides a series of template methods that should be overridden to provide functionality
in response to detected drag operations. These are onBeforeStart, onStart, onDrag and onEnd.
See Ext.slider.MultiSlider's initEvents function for an example implementation.</description><constructors/><properties/><methods><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="getDragTarget" scope="instance"><description>Returns the drag target</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="onBeforeStart" scope="instance"><description>Template method which should be overridden by each DragTracker instance. Called when the user first clicks and
holds the mouse button down. Return false to disallow the drag</description></method><method name="onDrag" scope="instance"><description>Template method which should be overridden by each DragTracker instance. Called whenever a drag has been detected.</description></method><method name="onEnd" scope="instance"><description>Template method which should be overridden by each DragTracker instance. Called when a drag operation has been completed
(e.g. the user clicked and held the mouse down, dragged the element and then released the mouse button)</description></method><method name="onStart" scope="instance"><description>Template method which should be overridden by each DragTracker instance. Called when a drag operation starts
(e.g. the user has moved the tracked element beyond the specified tolerance)</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method></methods></class><class superclass="Ext.chart.Series" type="Ext.chart.CartesianSeries"><description>CartesianSeries class for the charts widget.</description><constructors/><properties/><methods/></class><class superclass="Ext.Element" type="Ext.Layer"><description>An extended Ext.Element object that supports a shadow and shim, constrain to viewport and
automatic maintaining of shadow/shim positions.</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds one or more CSS classes to the element. Duplicate classes are automatically filtered out.</description></method><method name="addClassOnClick" scope="instance"><description>Sets up event handlers to add and remove a css class when the mouse is down and then up on this element (a click effect)</description></method><method name="addClassOnFocus" scope="instance"><description>Sets up event handlers to add and remove a css class when this element has the focus</description></method><method name="addClassOnOver" scope="instance"><description>Sets up event handlers to add and remove a css class when the mouse is over this element</description></method><method name="addKeyListener" scope="instance"><description>Convenience method for constructing a KeyMap</description></method><method name="addKeyMap" scope="instance"><description>Creates a KeyMap for this element</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this element.  The shorthand version on is equivalent.</description></method><method name="alignTo" scope="instance"><description>Aligns this element with another element relative to the specified anchor points. If the other element is the
document it aligns it to the viewport.
The position parameter is optional, and can be specified in any one of the following formats:

Blank: Defaults to aligning the element's top-left corner to the target's bottom-left corner (&quot;tl-bl&quot;).
One anchor (deprecated): The passed anchor position is used as the target element's anchor point.
The element being aligned will position its top-left corner (tl) to that point.  This method has been
deprecated in favor of the newer two anchor syntax below.
Two anchors: If two values from the table below are passed separated by a dash, the first value is used as the
element's anchor point, and the second value is used as the target's anchor point.

In addition to the anchor points, the position parameter also supports the &quot;?&quot; character.  If &quot;?&quot; is passed at the end of
the position string, the element will attempt to align as specified, but the position will be adjusted to constrain to
the viewport if necessary.  Note that the element being aligned might be swapped to align to a different position than
that specified in order to enforce the viewport constraints.
Following are all of the supported anchor positions:

Value  Description
-----  -----------------------------
tl     The top left corner (default)
t      The center of the top edge
tr     The top right corner
l      The center of the left edge
c      In the center of the element
r      The center of the right edge
bl     The bottom left corner
b      The center of the bottom edge
br     The bottom right corner

Example Usage:
// align el to other-el using the default positioning (&quot;tl-bl&quot;, non-constrained)
el.alignTo(&quot;other-el&quot;);

// align the top left corner of el with the top right corner of other-el (constrained to viewport)
el.alignTo(&quot;other-el&quot;, &quot;tr?&quot;);

// align the bottom right corner of el with the center left edge of other-el
el.alignTo(&quot;other-el&quot;, &quot;br-l?&quot;);

// align the center of el with the bottom left corner of other-el and
// adjust the x position by -6 pixels (and the y position by 0)
el.alignTo(&quot;other-el&quot;, &quot;c-bl&quot;, [-6, 0]);</description></method><method name="anchorTo" scope="instance"><description>Anchors an element to another element and realigns it when the window is resized.</description></method><method name="animate" scope="instance"><description>Perform custom animation on this element.

Animation Properties
The Animation Control Object enables gradual transitions for any member of an
element's style object that takes a numeric value including but not limited to
these properties:
bottom, top, left, right
height, width
margin, padding
borderWidth
opacity
fontSize
lineHeight

Animation Property Attributes
Each Animation Property is a config object with optional properties:

by*  : relative change - start at current value, change by this value
from : ignore current value, start from this value
to*  : start at current value, go to this value
unit : any allowable unit specification
* do not specify both to and by for an animation property

Animation Types
The supported animation types:
'run' : Default
var el = Ext.get('complexEl');
el.animate(
    // animation control object
    {
        borderWidth: {to: 3, from: 0},
        opacity: {to: .3, from: 1},
        height: {to: 50, from: el.getHeight()},
        width: {to: 300, from: el.getWidth()},
        top  : {by: - 100, unit: 'px'},
    },
    0.35,      // animation duration
    null,      // callback
    'easeOut', // easing method
    'run'      // animation type ('run','color','motion','scroll')
);

'color'
Animates transition of background, text, or border colors.
el.animate(
    // animation control object
    {
        color: { to: '#06e' },
        backgroundColor: { to: '#e06' }
    },
    0.35,      // animation duration
    null,      // callback
    'easeOut', // easing method
    'color'    // animation type ('run','color','motion','scroll')
);

'motion'
Animates the motion of an element to/from specific points using optional bezier
way points during transit.
el.animate(
    // animation control object
    {
        borderWidth: {to: 3, from: 0},
        opacity: {to: .3, from: 1},
        height: {to: 50, from: el.getHeight()},
        width: {to: 300, from: el.getWidth()},
        top  : {by: - 100, unit: 'px'},
        points: {
            to: [50, 100],  // go to this point
            control: [      // optional bezier way points
                [ 600, 800],
                [-100, 200]
            ]
        }
    },
    3000,      // animation duration (milliseconds!)
    null,      // callback
    'easeOut', // easing method
    'motion'   // animation type ('run','color','motion','scroll')
);

'scroll'
Animate horizontal or vertical scrolling of an overflowing page element.
el.animate(
    // animation control object
    {
        scroll: {to: [400, 300]}
    },
    0.35,      // animation duration
    null,      // callback
    'easeOut', // easing method
    'scroll'   // animation type ('run','color','motion','scroll')
);


</description></method><method name="appendChild" scope="instance"><description>Appends the passed element(s) to this element</description></method><method name="appendTo" scope="instance"><description>Appends this element to the passed element</description></method><method name="applyStyles" scope="instance"><description>More flexible version of setStyle for setting style properties.</description></method><method name="blur" scope="instance"><description>Tries to blur the element. Any exceptions are caught and ignored.</description></method><method name="boxWrap" scope="instance"><description>Wraps the specified element with a special 9 element markup/CSS block that renders by default as
a gray container with a gradient background, rounded corners and a 4-way shadow.
This special markup is used throughout Ext when box wrapping elements (Ext.Button,
Ext.Panel when frame=true, Ext.Window).  The markup
is of this form:
Ext.Element.boxMarkup =
    &#39;&lt;div class=&quot;{0}-tl&quot;&gt;&lt;div class=&quot;{0}-tr&quot;&gt;&lt;div class=&quot;{0}-tc&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
     &lt;div class=&quot;{0}-ml&quot;&gt;&lt;div class=&quot;{0}-mr&quot;&gt;&lt;div class=&quot;{0}-mc&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
     &lt;div class=&quot;{0}-bl&quot;&gt;&lt;div class=&quot;{0}-br&quot;&gt;&lt;div class=&quot;{0}-bc&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&#39;;
Example usage:
// Basic box wrap
    Ext.get(&quot;foo&quot;).boxWrap();

    // You can also add a custom class and use CSS inheritance rules to customize the box look.
    // 'x-box-blue' is a built-in alternative -- look at the related CSS definitions as an example
    // for how to create a custom box wrap style.
    Ext.get(&quot;foo&quot;).boxWrap().addClass(&quot;x-box-blue&quot;);</description></method><method name="center" scope="instance"><description>Centers the Element in either the viewport, or another Element.</description></method><method name="child" scope="instance"><description>Selects a single child at any depth below this element based on the passed CSS selector (the selector should not contain an id).</description></method><method name="clean" scope="instance"><description>Removes worthless text nodes</description></method><method name="clearOpacity" scope="instance"><description>Clears any opacity settings from this element. Required in some cases for IE.</description></method><method name="clearPositioning" scope="instance"><description>Clear positioning back to the default when the document was loaded</description></method><method name="clip" scope="instance"><description>Store the current overflow setting and clip overflow on the element - use unclip to remove</description></method><method name="contains" scope="instance"><description>Returns true if this element is an ancestor of the passed element</description></method><method name="createChild" scope="instance"><description>Creates the passed DomHelper config and appends it to this element or optionally inserts it before the passed child element.</description></method><method name="createProxy" scope="instance"><description>Creates a proxy element of this element</description></method><method name="createShim" scope="instance"><description>Creates an iframe shim for this element to keep selects and other windowed objects from
showing through.</description></method><method name="down" scope="instance"><description>Selects a single *direct* child based on the passed CSS selector (the selector should not contain an id).</description></method><method name="enableDisplayMode" scope="instance"><description>Convenience method for setVisibilityMode(Element.DISPLAY)</description></method><method name="findParent" scope="instance"><description>Looks at this node and then at parent nodes for a match of the passed simple selector (e.g. div.some-class or span:first-child)</description></method><method name="findParentNode" scope="instance"><description>Looks at parent nodes for a match of the passed simple selector (e.g. div.some-class or span:first-child)</description></method><method name="first" scope="instance"><description>Gets the first child, skipping text nodes</description></method><method name="fly" scope="instance"><description>Gets the globally shared flyweight Element, with the passed node as the active element. Do not store a reference to this element -
the dom node can be overwritten by other code. Shorthand of Ext.Element.fly
Use this to make one-time references to DOM elements which are not going to be accessed again either by
application code, or by Ext's classes. If accessing an element which will be processed regularly, then Ext.get
will be more appropriate to take advantage of the caching provided by the Ext.Element class.</description></method><method name="focus" scope="instance"><description>Tries to focus the element. Any exceptions are caught and ignored.</description></method><method name="getAlignToXY" scope="instance"><description>Gets the x,y coordinates to align this element with another element. See alignTo for more info on the
supported position values.</description></method><method name="getAnchorXY" scope="instance"><description>Gets the x,y coordinates specified by the anchor position on the element.</description></method><method name="getAttribute" scope="instance"><description>Returns the value of an attribute from the element's underlying DOM node.</description></method><method name="getAttributeNS" scope="instance"><description>Returns the value of a namespaced attribute from the element's underlying DOM node.</description></method><method name="getBorderWidth" scope="instance"><description>Gets the width of the border(s) for the specified side(s)</description></method><method name="getBottom" scope="instance"><description>Gets the bottom Y coordinate of the element (element Y position + element height)</description></method><method name="getBox" scope="instance"><description>Return an object defining the area of this Element which can be passed to setBox to
set another Element's size/location to match this element.</description></method><method name="getCenterXY" scope="instance"><description>Calculates the x, y to center this element on the screen</description></method><method name="getColor" scope="instance"><description>Return the CSS color for the specified CSS attribute. rgb, 3 digit (like #fff) and valid values
are convert to standard 6 digit hex color.</description></method><method name="getComputedHeight" scope="instance"><description>Returns either the offsetHeight or the height of this element based on CSS height adjusted by padding or borders
when needed to simulate offsetHeight when offsets aren't available. This may not work on display:none elements
if a height has not been set using CSS.</description></method><method name="getComputedWidth" scope="instance"><description>Returns either the offsetWidth or the width of this element based on CSS width adjusted by padding or borders
when needed to simulate offsetWidth when offsets aren't available. This may not work on display:none elements
if a width has not been set using CSS.</description></method><method name="getFrameWidth" scope="instance"><description>Returns the sum width of the padding and borders for the passed &quot;sides&quot;. See getBorderWidth()
         for more information about the sides.</description></method><method name="getHeight" scope="instance"><description>Returns the offset height of the element</description></method><method name="getLeft" scope="instance"><description>Gets the left X coordinate</description></method><method name="getMargins" scope="instance"><description>Returns an object with properties top, left, right and bottom representing the margins of this element unless sides is passed,
then it returns the calculated width of the sides (see getPadding)</description></method><method name="getOffsetsTo" scope="instance"><description>Returns the offsets of this element from the passed element. Both element must be part of the DOM tree and not have display:none to have page coordinates.</description></method><method name="getPadding" scope="instance"><description>Gets the width of the padding(s) for the specified side(s)</description></method><method name="getPositioning" scope="instance"><description>Gets an object with all CSS positioning properties. Useful along with setPostioning to get
snapshot before performing an update and then restoring the element.</description></method><method name="getRegion" scope="instance"><description>Returns the region of the given element.
The element must be part of the DOM tree to have a region (display:none or elements not appended return false).</description></method><method name="getRight" scope="instance"><description>Gets the right X coordinate of the element (element X position + element width)</description></method><method name="getScroll" scope="instance"><description>Returns the current scroll position of the element.</description></method><method name="getSize" scope="instance"><description>Returns the size of the element.</description></method><method name="getStyle" scope="instance"><description>Normalizes currentStyle and computedStyle.</description></method><method name="getStyleSize" scope="instance"><description>Returns the dimensions of the element available to lay content out in.
getStyleSize utilizes prefers style sizing if present, otherwise it chooses the larger of offsetHeight/clientHeight and offsetWidth/clientWidth.
To obtain the size excluding scrollbars, use getViewSize
Sizing of the document body is handled at the adapter level which handles special cases for IE and strict modes, etc.</description></method><method name="getStyles" scope="instance"><description>Returns an object with properties matching the styles requested.
For example, el.getStyles('color', 'font-size', 'width') might return
{'color': '#FFFFFF', 'font-size': '13px', 'width': '100px'}.</description></method><method name="getTextWidth" scope="instance"><description>Returns the width in pixels of the passed text, or the width of the text in this Element.</description></method><method name="getTop" scope="instance"><description>Gets the top Y coordinate</description></method><method name="getUpdater" scope="instance"><description>Gets this element's Updater</description></method><method name="getValue" scope="instance"><description>Returns the value of the &quot;value&quot; attribute</description></method><method name="getViewSize" scope="instance"><description>Returns the dimensions of the element available to lay content out in.
If the element (or any ancestor element) has CSS style display : none, the dimensions will be zero.
example:var vpSize = Ext.getBody().getViewSize();

        // all Windows created afterwards will have a default value of 90% height and 95% width
        Ext.Window.override({
            width: vpSize.width * 0.9,
            height: vpSize.height * 0.95
        });
        // To handle window resizing you would have to hook onto onWindowResize.
getViewSize utilizes clientHeight/clientWidth which excludes sizing of scrollbars.
To obtain the size including scrollbars, use getStyleSize
Sizing of the document body is handled at the adapter level which handles special cases for IE and strict modes, etc.</description></method><method name="getWidth" scope="instance"><description>Returns the offset width of the element</description></method><method name="getX" scope="instance"><description>Gets the current X position of the element based on page coordinates.  Element must be part of the DOM tree to have page coordinates (display:none or elements not appended return false).</description></method><method name="getXY" scope="instance"><description>Gets the current position of the element based on page coordinates.  Element must be part of the DOM tree to have page coordinates (display:none or elements not appended return false).</description></method><method name="getY" scope="instance"><description>Gets the current Y position of the element based on page coordinates.  Element must be part of the DOM tree to have page coordinates (display:none or elements not appended return false).</description></method><method name="hasClass" scope="instance"><description>Checks if the specified CSS class exists on this element's DOM node.</description></method><method name="hide" scope="instance"><description>Hide this element - Uses display mode to determine whether to use &quot;display&quot; or &quot;visibility&quot;. See setVisible.</description></method><method name="hover" scope="instance"><description>Sets up event handlers to call the passed functions when the mouse is moved into and out of the Element.</description></method><method name="initDD" scope="instance"><description>Initializes a Ext.dd.DD drag drop object for this element.</description></method><method name="initDDProxy" scope="instance"><description>Initializes a Ext.dd.DDProxy object for this element.</description></method><method name="initDDTarget" scope="instance"><description>Initializes a Ext.dd.DDTarget object for this element.</description></method><method name="insertAfter" scope="instance"><description>Inserts this element after the passed element in the DOM</description></method><method name="insertBefore" scope="instance"><description>Inserts this element before the passed element in the DOM</description></method><method name="insertFirst" scope="instance"><description>Inserts (or creates) an element (or DomHelper config) as the first child of this element</description></method><method name="insertHtml" scope="instance"><description>Inserts an html fragment into this element</description></method><method name="insertSibling" scope="instance"><description>Inserts (or creates) the passed element (or DomHelper config) as a sibling of this element</description></method><method name="is" scope="instance"><description>Returns true if this element matches the passed simple selector (e.g. div.some-class or span:first-child)</description></method><method name="isBorderBox" scope="instance"><description>Tests various css rules/browsers to determine if this element uses a border box</description></method><method name="isDisplayed" scope="instance"><description>Returns true if display is not &quot;none&quot;</description></method><method name="isMasked" scope="instance"><description>Returns true if this element is masked</description></method><method name="isScrollable" scope="instance"><description>Returns true if this element is scrollable.</description></method><method name="isVisible" scope="instance"><description>Checks whether the element is currently visible using both visibility and display properties.</description></method><method name="last" scope="instance"><description>Gets the last child, skipping text nodes</description></method><method name="load" scope="instance"><description>Updates the innerHTML of this Element
from a specified URL. Note that this is subject to the Same Origin Policy
Updating innerHTML of an element will not execute embedded &lt;script&gt; elements. This is a browser restriction.</description></method><method name="mask" scope="instance"><description>Puts a mask over this element to disable user interaction. Requires core.css.
This method can only be applied to elements which accept child nodes.</description></method><method name="move" scope="instance"><description>Move this element relative to its current position.</description></method><method name="moveTo" scope="instance"><description>Sets the position of the element in page coordinates, regardless of how the element is positioned.
The element must be part of the DOM tree to have page coordinates (display:none or elements not appended return false).</description></method><method name="next" scope="instance"><description>Gets the next sibling, skipping text nodes</description></method><method name="on" scope="instance"><description>Appends an event handler (shorthand for addListener).</description></method><method name="parent" scope="instance"><description>Gets the parent node for this element, optionally chaining up trying to match a selector</description></method><method name="position" scope="instance"><description>Initializes positioning on this element. If a desired position is not passed, it will make the
the element positioned relative IF it is not already positioned.</description></method><method name="prev" scope="instance"><description>Gets the previous sibling, skipping text nodes</description></method><method name="purgeAllListeners" scope="instance"><description>Recursively removes all previous added listeners from this element and its children</description></method><method name="query" scope="instance"><description>Selects child nodes based on the passed CSS selector (the selector should not contain an id).</description></method><method name="radioClass" scope="instance"><description>Adds one or more CSS classes to this element and removes the same class(es) from all siblings.</description></method><method name="relayEvent" scope="instance"><description>Create an event handler on this element such that when the event fires and is handled by this element,
it will be relayed to another object (i.e., fired again as if it originated from that object instead).</description></method><method name="remove" scope="instance"><description>Removes this element's dom reference.  Note that event and cache removal is handled at Ext.removeNode</description></method><method name="removeAllListeners" scope="instance"><description>Removes all previous added listeners from this element</description></method><method name="removeAnchor" scope="instance"><description>Remove any anchor to this element. See anchorTo.</description></method><method name="removeClass" scope="instance"><description>Removes one or more CSS classes from the element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler from this element.  The shorthand version un is equivalent.
Note: if a scope was explicitly specified when adding the
listener, the same scope must be specified here.
Example:
el.removeListener('click', this.handlerFn);
// or
el.un('click', this.handlerFn);</description></method><method name="repaint" scope="instance"><description>Forces the browser to repaint this element</description></method><method name="replace" scope="instance"><description>Replaces the passed element with this element</description></method><method name="replaceClass" scope="instance"><description>Replaces a CSS class on the element with another.  If the old name does not exist, the new name will simply be added.</description></method><method name="replaceWith" scope="instance"><description>Replaces this element with the passed element</description></method><method name="scroll" scope="instance"><description>Scrolls this element the specified direction. Does bounds checking to make sure the scroll is
within this element's scrollable range.</description></method><method name="scrollIntoView" scope="instance"><description>Scrolls this element into view within the passed container.</description></method><method name="scrollTo" scope="instance"><description>Scrolls this element the specified scroll point. It does NOT do bounds checking so if you scroll to a weird value it will try to do it. For auto bounds checking, use scroll().</description></method><method name="select" scope="instance"><description>Creates a Ext.CompositeElement for child nodes based on the passed CSS selector (the selector should not contain an id).</description></method><method name="set" scope="instance"><description>Sets the passed attributes as attributes of this element (a style attribute can be a string, object or function)</description></method><method name="setBottom" scope="instance"><description>Sets the element's CSS bottom style.</description></method><method name="setBounds" scope="instance"><description>Sets the element's position and size in one shot. If animation is true then width, height, x and y will be animated concurrently.</description></method><method name="setBox" scope="instance"><description>Sets the element's box. Use getBox() on another element to get a box obj. If animate is true then width, height, x and y will be animated concurrently.</description></method><method name="setDisplayed" scope="instance"><description>Sets the CSS display property. Uses originalDisplay if the specified value is a boolean true.</description></method><method name="setHeight" scope="instance"><description>Set the height of this Element.
// change the height to 200px and animate with default configuration
Ext.fly('elementId').setHeight(200, true);

// change the height to 150px and animate with a custom configuration
Ext.fly('elId').setHeight(150, {
    duration : .5, // animation will have a duration of .5 seconds
    // will change the content to &quot;finished&quot;
    callback: function(){ this.update(&quot;finished&quot;); }
});</description></method><method name="setLeft" scope="instance"><description>Sets the element's left position directly using CSS style (instead of setX).</description></method><method name="setLeftTop" scope="instance"><description>Quick set left and top adding default units</description></method><method name="setLocation" scope="instance"><description>Sets the position of the element in page coordinates, regardless of how the element is positioned.
The element must be part of the DOM tree to have page coordinates (display:none or elements not appended return false).</description></method><method name="setOpacity" scope="instance"><description>Set the opacity of the element</description></method><method name="setPositioning" scope="instance"><description>Set positioning with an object returned by getPositioning().</description></method><method name="setRegion" scope="instance"><description>Sets the element's position and size the specified region. If animation is true then width, height, x and y will be animated concurrently.</description></method><method name="setRight" scope="instance"><description>Sets the element's CSS right style.</description></method><method name="setSize" scope="instance"><description>Set the size of this Element. If animation is true, both width and height will be animated concurrently.</description></method><method name="setStyle" scope="instance"><description>Wrapper for setting style properties, also takes single object parameter of multiple styles.</description></method><method name="setTop" scope="instance"><description>Sets the element's top position directly using CSS style (instead of setY).</description></method><method name="setVisibilityMode" scope="instance"><description>Sets the element's visibility mode. When setVisible() is called it
will use this to determine whether to set the visibility or the display property.</description></method><method name="setVisible" scope="instance"><description>Sets the visibility of the element (see details). If the visibilityMode is set to Element.DISPLAY, it will use
the display property to hide the element, otherwise it uses visibility. The default is to hide and show using the visibility property.</description></method><method name="setWidth" scope="instance"><description>Set the width of this Element.</description></method><method name="setX" scope="instance"><description>Sets the X position of the element based on page coordinates.  Element must be part of the DOM tree to have page coordinates (display:none or elements not appended return false).</description></method><method name="setXY" scope="instance"><description>Sets the position of the element in page coordinates, regardless of how the element is positioned.
The element must be part of the DOM tree to have page coordinates (display:none or elements not appended return false).</description></method><method name="setY" scope="instance"><description>Sets the Y position of the element based on page coordinates.  Element must be part of the DOM tree to have page coordinates (display:none or elements not appended return false).</description></method><method name="setZIndex" scope="instance"><description>Sets the z-index of this layer and adjusts any shadow and shim z-indexes. The layer z-index is automatically
incremented by two more than the value passed in so that it always shows above any shadow or shim (the shadow
element, if any, will be assigned z-index + 1, and the shim element, if any, will be assigned the unmodified z-index).</description></method><method name="show" scope="instance"><description>Show this element - Uses display mode to determine whether to use &quot;display&quot; or &quot;visibility&quot;. See setVisible.</description></method><method name="swallowEvent" scope="instance"><description>Stops the specified event(s) from bubbling and optionally prevents the default action</description></method><method name="toggle" scope="instance"><description>Toggles the element's visibility or display, depending on visibility mode.</description></method><method name="toggleClass" scope="instance"><description>Toggles the specified CSS class on this element (removes it if it already exists, otherwise adds it).</description></method><method name="translatePoints" scope="instance"><description>Translates the passed page coordinates into left/top css values for this element</description></method><method name="un" scope="instance"><description>Removes an event handler from this element (see removeListener for additional notes).</description></method><method name="unclip" scope="instance"><description>Return clipping (overflow) to original clipping before clip was called</description></method><method name="unmask" scope="instance"><description>Removes a previously applied mask.</description></method><method name="unselectable" scope="instance"><description>Disables text selection for this element (normalized across browsers)</description></method><method name="up" scope="instance"><description>Walks up the dom looking for a parent node that matches the passed simple selector (e.g. div.some-class or span:first-child).
This is a shortcut for findParentNode() that always returns an Ext.Element.</description></method><method name="update" scope="instance"><description>Update the innerHTML of this element</description></method><method name="wrap" scope="instance"><description>Creates and wraps this element with another element</description></method></methods></class><class superclass="Object" type="Ext.layout.ContainerLayout"><description>This class is intended to be extended or created via the layout
configuration property.  See Ext.Container.layout for additional details.</description><constructors/><properties/><methods><method name="parseMargins" scope="instance"><description>Parses a number or string representing margin sizes into an object. Supports CSS-style margin declarations
(e.g. 10, &quot;10&quot;, &quot;10 10&quot;, &quot;10 10 10&quot; and &quot;10 10 10 10&quot; are all valid options and would return the same result)</description></method></methods></class><class superclass="Object" type="Ext.Template"><description>Represents an HTML fragment template. Templates may be precompiled
for greater performance.
For example usage see the constructor.</description><constructors/><properties/><methods><method name="Template.from" scope="instance"><description>Creates a template from the passed element's value (display:none textarea, preferred) or innerHTML.</description></method><method name="append" scope="instance"><description>Applies the supplied values to the template and appends
the new node(s) to the specified el.
For example usage see the constructor.</description></method><method name="apply" scope="instance"><description>Alias for applyTemplate
Returns an HTML fragment of this template with the specified values applied.</description></method><method name="applyTemplate" scope="instance"><description>Returns an HTML fragment of this template with the specified values applied.</description></method><method name="compile" scope="instance"><description>Compiles the template into an internal function, eliminating the RegEx overhead.</description></method><method name="insertAfter" scope="instance"><description>Applies the supplied values to the template and inserts the new node(s) after el.</description></method><method name="insertBefore" scope="instance"><description>Applies the supplied values to the template and inserts the new node(s) before el.</description></method><method name="insertFirst" scope="instance"><description>Applies the supplied values to the template and inserts the new node(s) as the first child of el.</description></method><method name="overwrite" scope="instance"><description>Applies the supplied values to the template and overwrites the content of el with the new node(s).</description></method><method name="set" scope="instance"><description>Sets the HTML used as the template and optionally compiles it.</description></method></methods></class><class superclass="Ext.util.Observable" type="Ext.grid.PropertyStore"><description>A custom wrapper for the Ext.grid.PropertyGrid's Ext.data.Store. This class handles the mapping
between the custom data source objects supported by the grid and the Ext.grid.PropertyRecord format
required for compatibility with the underlying store. Generally this class should not need to be used directly --
the grid's data should be accessed from the underlying store via the store property.</description><constructors/><properties/><methods><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method></methods></class><class superclass="Ext.menu.Menu" type="Ext.menu.ColorMenu"><description>A menu containing a Ext.ColorPalette Component.
Notes:
Although not listed here, the constructor for this class
accepts all of the configuration options of Ext.ColorPalette.
If subclassing ColorMenu, any configuration options for the ColorPalette must be
applied to the initialConfig property of the ColorMenu.
Applying ColorPalette configuration settings to
this will not affect the ColorPalette's configuration.
 *</description><constructors/><properties/><methods><method name="add" scope="instance"><description>Adds Component(s) to this Container.
Description :

Fires the beforeadd event before adding
The Container's default config values will be applied
accordingly (see defaults for details).
Fires the add event after the component has been added.

Notes :

If the Container is already rendered when add
is called, you may need to call doLayout to refresh the view which causes
any unrendered child Components to be rendered. This is required so that you can
add multiple child components if needed while only refreshing the layout
once. For example:var tb = new Ext.Toolbar();
tb.render(document.body);  // toolbar is rendered
tb.add({text:'Button 1'}); // add multiple items (defaultType for Toolbar is 'button')
tb.add({text:'Button 2'});
tb.doLayout();             // refresh the layout
Warning: Containers directly managed by the BorderLayout layout manager
may not be removed or added.  See the Notes for BorderLayout
for more details.
</description></method><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addElement" scope="instance"><description>Adds an Ext.Element object to the menu</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addItem" scope="instance"><description>Adds an existing object based on Ext.menu.BaseItem to the menu</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="addMenuItem" scope="instance"><description>Creates a new Ext.menu.Item based an the supplied config object and adds it to the menu</description></method><method name="addSeparator" scope="instance"><description>Adds a separator bar to the menu</description></method><method name="addText" scope="instance"><description>Creates a new Ext.menu.TextItem with the supplied text and adds it to the menu</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cascade" scope="instance"><description>Cascades down the component/container heirarchy from this component (called first), calling the specified function with
each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the cascade is stopped on that branch.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="doLayout" scope="instance"><description>Force this container's layout to be recalculated. A call to this function is required after adding a new component
to an already rendered container, or possibly after changing sizing/position properties of child components.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="find" scope="instance"><description>Find a component under this container at any level by property</description></method><method name="findBy" scope="instance"><description>Find a component under this container at any level by a custom function. If the passed function returns
true, the component will be included in the results. The passed function is called with the arguments (component, this container).</description></method><method name="findById" scope="instance"><description>Find a component under this container at any level by id</description></method><method name="findByType" scope="instance"><description>Find a component under this container at any level by xtype or class</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="get" scope="instance"><description>Get a component contained by this container (alias for items.get(key))</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getComponent" scope="instance"><description>Examines this container's items property
and gets a direct child component of this container.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getLayout" scope="instance"><description>Returns the layout currently in use by the container.  If the container does not currently have a layout
set, a default Ext.layout.ContainerLayout will be created and set as the container's layout.</description></method><method name="getLayoutTarget" scope="instance"><description>Returns the Element to be used to contain the child Components of this Container.
An implementation is provided which returns the Container's Element, but
if there is a more complex structure to a Container, this may be overridden to return
the element into which the layout renders child Components.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hides this menu and optionally all parent menus</description></method><method name="insert" scope="instance"><description>Inserts a Component into this Container at a specified index. Fires the
beforeadd event before inserting, then fires the add event after the
Component has been inserted.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="remove" scope="instance"><description>Removes a component from this container.  Fires the beforeremove event before removing, then fires
the remove event after the component has been removed.</description></method><method name="removeAll" scope="instance"><description>Removes all components from this container.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>If floating=true, shows this menu relative to
another element using showat, otherwise uses Ext.Component.show.</description></method><method name="showAt" scope="instance"><description>Displays this menu at a specific xy position and fires the 'show' event if a
handler for the 'beforeshow' event does not return false cancelling the operation.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method></methods></class><class superclass="Ext.ToolTip" type="Ext.QuickTip"><description/><constructors/><properties/><methods><method name="add" scope="instance"><description>Adds Component(s) to this Container.
Description :

Fires the beforeadd event before adding
The Container's default config values will be applied
accordingly (see defaults for details).
Fires the add event after the component has been added.

Notes :

If the Container is already rendered when add
is called, you may need to call doLayout to refresh the view which causes
any unrendered child Components to be rendered. This is required so that you can
add multiple child components if needed while only refreshing the layout
once. For example:var tb = new Ext.Toolbar();
tb.render(document.body);  // toolbar is rendered
tb.add({text:'Button 1'}); // add multiple items (defaultType for Toolbar is 'button')
tb.add({text:'Button 2'});
tb.doLayout();             // refresh the layout
Warning: Containers directly managed by the BorderLayout layout manager
may not be removed or added.  See the Notes for BorderLayout
for more details.
</description></method><method name="addButton" scope="instance"><description>Adds a button to this panel.  Note that this method must be called prior to rendering.  The preferred
approach is to add buttons via the buttons config.</description></method><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cancelShow" scope="instance"><description>Hides a visible tip or cancels an impending show for a particular element.</description></method><method name="cascade" scope="instance"><description>Cascades down the component/container heirarchy from this component (called first), calling the specified function with
each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the cascade is stopped on that branch.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="collapse" scope="instance"><description>Collapses the panel body so that it becomes hidden.  Fires the beforecollapse event which will
cancel the collapse action if it returns false.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="doLayout" scope="instance"><description>Force this container's layout to be recalculated. A call to this function is required after adding a new component
to an already rendered container, or possibly after changing sizing/position properties of child components.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="expand" scope="instance"><description>Expands the panel body so that it becomes visible.  Fires the beforeexpand event which will
cancel the expand action if it returns false.</description></method><method name="find" scope="instance"><description>Find a component under this container at any level by property</description></method><method name="findBy" scope="instance"><description>Find a component under this container at any level by a custom function. If the passed function returns
true, the component will be included in the results. The passed function is called with the arguments (component, this container).</description></method><method name="findById" scope="instance"><description>Find a component under this container at any level by id</description></method><method name="findByType" scope="instance"><description>Find a component under this container at any level by xtype or class</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="get" scope="instance"><description>Get a component contained by this container (alias for items.get(key))</description></method><method name="getBottomToolbar" scope="instance"><description>Returns the toolbar from the bottom (bbar) section of the panel.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getComponent" scope="instance"><description>Examines this container's items property
and gets a direct child component of this container.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getFooterToolbar" scope="instance"><description>Returns the toolbar from the footer (fbar) section of the panel.</description></method><method name="getFrameHeight" scope="instance"><description>Returns the height in pixels of the framing elements of this panel (including any top and bottom bars and
header and footer elements, but not including the body height).  To retrieve the body height see getInnerHeight.</description></method><method name="getFrameWidth" scope="instance"><description>Returns the width in pixels of the framing elements of this panel (not including the body width).  To
retrieve the body width see getInnerWidth.</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getInnerHeight" scope="instance"><description>Returns the height in pixels of the body element (not including the height of any framing elements).
For the frame height see getFrameHeight.</description></method><method name="getInnerWidth" scope="instance"><description>Returns the width in pixels of the body element (not including the width of any framing elements).
For the frame width see getFrameWidth.</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getLayout" scope="instance"><description>Returns the layout currently in use by the container.  If the container does not currently have a layout
set, a default Ext.layout.ContainerLayout will be created and set as the container's layout.</description></method><method name="getLayoutTarget" scope="instance"><description>Returns the Element to be used to contain the child Components of this Container.
An implementation is provided which returns the Container's Element, but
if there is a more complex structure to a Container, this may be overridden to return
the element into which the layout renders child Components.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getTool" scope="instance"><description>Retrieve a tool by id.</description></method><method name="getTopToolbar" scope="instance"><description>Returns the toolbar from the top (tbar) section of the panel.</description></method><method name="getUpdater" scope="instance"><description>Get the Ext.Updater for this panel. Enables you to perform Ajax updates of this panel's body.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hides this tooltip if visible.</description></method><method name="initTarget" scope="instance"><description>Binds this ToolTip to the specified element. The tooltip will be displayed when the mouse moves over the element.</description></method><method name="insert" scope="instance"><description>Inserts a Component into this Container at a specified index. Fires the
beforeadd event before inserting, then fires the add event after the
Component has been inserted.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="load" scope="instance"><description>Loads this content panel immediately with content returned from an XHR call.</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="register" scope="instance"><description>Configures a new quick tip instance and assigns it to a target element.  The following config values are
supported (for example usage, see the Ext.QuickTips class header):

autoHide
cls
dismissDelay (overrides the singleton value)
target (required)
text (required)
title
width</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="remove" scope="instance"><description>Removes a component from this container.  Fires the beforeremove event before removing, then fires
the remove event after the component has been removed.</description></method><method name="removeAll" scope="instance"><description>Removes all components from this container.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setIconClass" scope="instance"><description>Sets the CSS class that provides the icon image for this panel.  This method will replace any existing
icon class if one has already been set and fire the iconchange event after completion.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setTitle" scope="instance"><description>Sets the title text for the panel and optionally the icon class.
In order to be able to set the title, a header element must have been created
for the Panel. This is triggered either by configuring the Panel with a non-blank title,
or configuring it with header: true.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Shows this tooltip at the current event target XY position.</description></method><method name="showAt" scope="instance"><description>Shows this tip at the specified XY position.  Example usage:
// Show the tip at x:50 and y:100
tip.showAt([50,100]);</description></method><method name="showBy" scope="instance"><description>Experimental. Shows this tip at a position relative to another element using a standard Ext.Element.alignTo
anchor position value.  Example usage:
// Show the tip at the default position ('tl-br?')
tip.showBy('my-el');

// Show the tip's top-left corner anchored to the element's top-right corner
tip.showBy('my-el', 'tl-tr');</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="toggleCollapse" scope="instance"><description>Shortcut for performing an expand or collapse based on the current state of the panel.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="unregister" scope="instance"><description>Removes this quick tip from its element and destroys it.</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method></methods></class><class superclass="Ext.menu.BaseItem" type="Ext.menu.Item"><description>A base class for all menu items that require menu-related functionality (like sub-menus) and are not static
display items.  Item extends the base functionality of Ext.menu.BaseItem by adding menu-specific
activation and click handling.</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHandler" scope="instance"><description>Sets the function that will handle click events for this item (equivalent to passing in the handler
config property).  If an existing handler is already registered, it will be unregistered for you.</description></method><method name="setIconClass" scope="instance"><description>Sets the CSS class to apply to the item's icon element</description></method><method name="setText" scope="instance"><description>Sets the text to display in this menu item</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method></methods></class><class superclass="Ext.form.Field" type="Ext.form.SliderField"><description>Wraps a Slider so it can be used as a form field.</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="clearInvalid" scope="instance"><description>Clear any invalid styles/messages for this field</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getActiveError" scope="instance"><description>Gets the active error message for this field.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getErrors" scope="instance"><description>Runs this field's validators and returns an array of error messages for any validation failures.
This is called internally during validation and would not usually need to be used manually.
Each subclass should override or augment the return value to provide their own errors</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getName" scope="instance"><description>Returns the name or hiddenName
attribute of the field if available.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getRawValue" scope="instance"><description>Returns the raw data value which may or may not be a valid, defined value.  To return a normalized value see getValue.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getValue" scope="instance"><description>Gets the current value for this field.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isDirty" scope="instance"><description>Returns true if the value of this Field has been changed from its original value.
Will return false if the field is disabled or has not been rendered yet.
Note that if the owning form was configured with
Ext.form.BasicForm.trackResetOnLoad
then the original value is updated when the values are loaded by
Ext.form.BasicForm.setValues.</description></method><method name="isValid" scope="instance"><description>Returns whether or not the field value is currently valid by
validating the processed value
of the field. Note: disabled fields are ignored.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="markInvalid" scope="instance"><description>Display an error message associated with this field, using msgTarget to determine how to
display the message and applying invalidClass to the field's UI element.
Note: this method does not cause the Field's validate method to return false
if the value does pass validation. So simply marking a Field as invalid will not prevent
submission of forms submitted with the Ext.form.Action.Submit.clientValidation option set.
invalid.</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="processValue" scope="instance"><description>This method should only be overridden if necessary to prepare raw values
for validation (see validate and isValid).  This method
is expected to return the processed value for the field which will
be used for validation (see validateValue method).</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="reset" scope="instance"><description>Resets the current field value to the originally loaded value and clears any validation messages.
See Ext.form.BasicForm.trackResetOnLoad</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setActiveError" scope="instance"><description>Sets the current activeError to the given string. Fires the 'invalid' event.
This does not set up the error icon, only sets the message and fires the event. To show the error icon,
use markInvalid instead, which calls this method internally</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setMaxValue" scope="instance"><description>Sets the maximum field value.</description></method><method name="setMinValue" scope="instance"><description>Sets the minimum field value.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setRawValue" scope="instance"><description>Sets the underlying DOM field's value directly, bypassing validation.  To set the value with validation see setValue.</description></method><method name="setReadOnly" scope="instance"><description>Sets the read only state of this field.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setValue" scope="instance"><description>Sets the value for this field.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="unsetActiveError" scope="instance"><description>Clears the activeError and fires the 'valid' event. This is called internally by clearInvalid and would not
usually need to be called manually</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method><method name="validate" scope="instance"><description>Validates the field value</description></method><method name="validateValue" scope="instance"><description>Uses getErrors to build an array of validation errors. If any errors are found, markInvalid is called
with the first and false is returned, otherwise true is returned. Previously, subclasses were invited
to provide an implementation of this to process validations - from 3.2 onwards getErrors should be
overridden instead.</description></method></methods></class><class superclass="Ext.BoxComponent" type="Ext.Toolbar.Item"><description>The base class that other non-interacting Toolbar Item classes should extend in order to
get some basic common toolbar item functionality.</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method></methods></class><class superclass="Object" type="Ext.CompositeElementLite"><description>This class encapsulates a collection of DOM elements, providing methods to filter
members, or to perform collective actions upon the whole set.
Although they are not listed, this class supports all of the methods of Ext.Element and
Ext.Fx. The methods from these classes will be performed on all the elements in this collection.
Example:var els = Ext.select(&quot;#some-el div.some-class&quot;);
// or select directly from an existing element
var el = Ext.get('some-el');
el.select('div.some-class');

els.setWidth(100); // all elements become 100 width
els.hide(true); // all elements fade out and hide
// or
els.setWidth(100).hide(true);
</description><constructors/><properties/><methods><method name="add" scope="instance"><description>Adds elements to this Composite object.</description></method><method name="clear" scope="instance"><description>Removes all elements.</description></method><method name="contains" scope="instance"><description>Returns true if this composite contains the passed element</description></method><method name="each" scope="instance"><description>Calls the passed function for each element in this composite.</description></method><method name="fill" scope="instance"><description>Clears this Composite and adds the elements passed.</description></method><method name="filter" scope="instance"><description>Filters this composite to only elements that match the passed selector.</description></method><method name="first" scope="instance"><description>Returns the first Element</description></method><method name="getCount" scope="instance"><description>Returns the number of elements in this Composite.</description></method><method name="indexOf" scope="instance"><description>Find the index of the passed element within the composite collection.</description></method><method name="item" scope="instance"><description>Returns a flyweight Element of the dom element object at the specified index</description></method><method name="last" scope="instance"><description>Returns the last Element</description></method><method name="removeElement" scope="instance"><description>Removes the specified element(s).</description></method><method name="replaceElement" scope="instance"><description>Replaces the specified element with the passed element.</description></method></methods></class><class superclass="Ext.dd.DD" type="Ext.dd.DDProxy"><description>A DragDrop implementation that inserts an empty, bordered div into
the document that follows the cursor during drag operations.  At the time of
the click, the frame div is resized to the dimensions of the linked html
element, and moved to the exact location of the linked element.
References to the &quot;frame&quot; element refer to the single proxy element that
was created to be dragged in place of all DDProxy elements on the
page.</description><constructors/><properties/><methods><method name="addInvalidHandleClass" scope="instance"><description>Lets you specify a css class of elements that will not initiate a drag</description></method><method name="addInvalidHandleId" scope="instance"><description>Lets you to specify an element id for a child of a drag handle
that should not initiate a drag</description></method><method name="addInvalidHandleType" scope="instance"><description>Allows you to specify a tag name that should not start a drag operation
when clicked.  This is designed to facilitate embedding links within a
drag handle that do something other than start the drag.</description></method><method name="addToGroup" scope="instance"><description>Add this instance to a group of related drag/drop objects.  All
instances belong to at least one group, and can belong to as many
groups as needed.</description></method><method name="alignElWithMouse" scope="instance"><description>Sets the element to the location of the mousedown or click event,
maintaining the cursor location relative to the location on the element
that was clicked.  Override this if you want to place the element in a
location other than where the cursor is.</description></method><method name="applyConfig" scope="instance"><description>Sets up config options specific to this class. Overrides
Ext.dd.DragDrop, but all versions of this method through the
inheritance chain are called</description></method><method name="autoOffset" scope="instance"><description>Sets the pointer offset to the distance between the linked element's top
left corner and the location the element was clicked</description></method><method name="b4Drag" scope="instance"><description>Event that fires prior to the onDrag event.  Overrides
Ext.dd.DragDrop.</description></method><method name="b4MouseDown" scope="instance"><description>Event that fires prior to the onMouseDown event.  Overrides
Ext.dd.DragDrop.</description></method><method name="cachePosition" scope="instance"><description>Saves the most recent position so that we can reset the constraints and
tick marks on-demand.  We need to know this so that we can calculate the
number of pixels the element is offset from its original position.</description></method><method name="clearConstraints" scope="instance"><description>Clears any constraints applied to this instance.  Also clears ticks
since they can't exist independent of a constraint at this time.</description></method><method name="clearTicks" scope="instance"><description>Clears any tick interval defined for this instance</description></method><method name="constrainTo" scope="instance"><description>Initializes the drag drop object's constraints to restrict movement to a certain element.
Usage:
 var dd = new Ext.dd.DDProxy(&quot;dragDiv1&quot;, &quot;proxytest&quot;,
                { dragElId: &quot;existingProxyDiv&quot; });
 dd.startDrag = function(){
     this.constrainTo(&quot;parent-id&quot;);
 };
Or you can initalize it using the Ext.Element object:
 Ext.get(&quot;dragDiv1&quot;).initDDProxy(&quot;proxytest&quot;, {dragElId: &quot;existingProxyDiv&quot;}, {
     startDrag : function(){
         this.constrainTo(&quot;parent-id&quot;);
     }
 });</description></method><method name="createFrame" scope="instance"><description>Creates the proxy element if it does not yet exist</description></method><method name="endDrag" scope="instance"><description>Fired when we are done dragging the object</description></method><method name="getDragEl" scope="instance"><description>Returns a reference to the actual element to drag.  By default this is
the same as the html element, but it can be assigned to another
element. An example of this can be found in Ext.dd.DDProxy</description></method><method name="getEl" scope="instance"><description>Returns a reference to the linked element</description></method><method name="init" scope="instance"><description>Sets up the DragDrop object.  Must be called in the constructor of any
Ext.dd.DragDrop subclass</description></method><method name="initFrame" scope="instance"><description>Initialization for the drag frame element.  Must be called in the
constructor of all subclasses</description></method><method name="initTarget" scope="instance"><description>Initializes Targeting functionality only... the object does not
get a mousedown handler.</description></method><method name="isLocked" scope="instance"><description>Returns true if this instance is locked, or the drag drop mgr is locked
(meaning that all drag/drop is disabled on the page.)</description></method><method name="isValidHandleChild" scope="instance"><description>Checks the tag exclusion list to see if this click should be ignored</description></method><method name="lock" scope="instance"><description>Lock this instance</description></method><method name="onAvailable" scope="instance"><description>Override the onAvailable method to do what is needed after the initial
position was determined.</description></method><method name="onDrag" scope="instance"><description>Abstract method called during the onMouseMove event while dragging an
object.</description></method><method name="onDragDrop" scope="instance"><description>Abstract method called when this item is dropped on another DragDrop
obj</description></method><method name="onDragEnter" scope="instance"><description>Abstract method called when this element fist begins hovering over
another DragDrop obj</description></method><method name="onDragOut" scope="instance"><description>Abstract method called when we are no longer hovering over an element</description></method><method name="onDragOver" scope="instance"><description>Abstract method called when this element is hovering over another
DragDrop obj</description></method><method name="onInvalidDrop" scope="instance"><description>Abstract method called when this item is dropped on an area with no
drop target</description></method><method name="onMouseDown" scope="instance"><description>Event handler that fires when a drag/drop obj gets a mousedown</description></method><method name="onMouseUp" scope="instance"><description>Event handler that fires when a drag/drop obj gets a mouseup</description></method><method name="removeFromGroup" scope="instance"><description>Remove's this instance from the supplied interaction group</description></method><method name="removeInvalidHandleClass" scope="instance"><description>Unsets an invalid css class</description></method><method name="removeInvalidHandleId" scope="instance"><description>Unsets an invalid handle id</description></method><method name="removeInvalidHandleType" scope="instance"><description>Unsets an excluded tag name set by addInvalidHandleType</description></method><method name="resetConstraints" scope="instance"><description>resetConstraints must be called if you manually reposition a dd element.</description></method><method name="setDelta" scope="instance"><description>Sets the pointer offset.  You can call this directly to force the
offset to be in a particular location (e.g., pass in 0,0 to set it
to the center of the object)</description></method><method name="setDragElId" scope="instance"><description>Allows you to specify that an element other than the linked element
will be moved with the cursor during a drag</description></method><method name="setDragElPos" scope="instance"><description>Sets the drag element to the location of the mousedown or click event,
maintaining the cursor location relative to the location on the element
that was clicked.  Override this if you want to place the element in a
location other than where the cursor is.</description></method><method name="setHandleElId" scope="instance"><description>Allows you to specify a child of the linked element that should be
used to initiate the drag operation.  An example of this would be if
you have a content div with text and links.  Clicking anywhere in the
content area would normally start the drag operation.  Use this method
to specify that an element inside of the content div is the element
that starts the drag operation.</description></method><method name="setInitPosition" scope="instance"><description>Stores the initial placement of the linked element.</description></method><method name="setOuterHandleElId" scope="instance"><description>Allows you to set an element outside of the linked element as a drag
handle</description></method><method name="setPadding" scope="instance"><description>Configures the padding for the target zone in px.  Effectively expands
(or reduces) the virtual object size for targeting calculations.
Supports css-style shorthand; if only one parameter is passed, all sides
will have that padding, and if only two are passed, the top and bottom
will have the first param, the left and right the second.</description></method><method name="setXConstraint" scope="instance"><description>By default, the element can be dragged any place on the screen.  Use
this method to limit the horizontal travel of the element.  Pass in
0,0 for the parameters if you want to lock the drag to the y axis.</description></method><method name="setYConstraint" scope="instance"><description>By default, the element can be dragged any place on the screen.  Set
this to limit the vertical travel of the element.  Pass in 0,0 for the
parameters if you want to lock the drag to the x axis.</description></method><method name="startDrag" scope="instance"><description>Abstract method called after a drag/drop object is clicked
and the drag or mousedown time thresholds have beeen met.</description></method><method name="toString" scope="instance"><description>toString method</description></method><method name="unlock" scope="instance"><description>Unlock this instace</description></method><method name="unreg" scope="instance"><description>Remove all drag and drop hooks for this element</description></method></methods></class><class superclass="Ext.Error" type="Ext.data.DataReader.Error"><description>General error class for Ext.data.DataReader</description><constructors/><properties/><methods><method name="getMessage" scope="instance"><description>getMessage</description></method><method name="getName" scope="instance"><description>getName</description></method><method name="toJson" scope="instance"><description>toJson</description></method></methods></class><class superclass="Ext.tree.TreeNode" type="Ext.tree.AsyncTreeNode"><description/><constructors/><properties/><methods><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="appendChild" scope="instance"><description>Insert node(s) as the last child node of this node.</description></method><method name="bubble" scope="instance"><description>Bubbles up the tree from this node, calling the specified function with each node. The arguments to the function
will be the args provided or the current node. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cascade" scope="instance"><description>Cascades down the tree from this node, calling the specified function with each node. The arguments to the function
will be the args provided or the current node. If the function returns false at any point,
the cascade is stopped on that branch.</description></method><method name="collapse" scope="instance"><description>Collapse this node.</description></method><method name="collapseChildNodes" scope="instance"><description>Collapse all child nodes</description></method><method name="contains" scope="instance"><description>Returns true if this node is an ancestor (at any point) of the passed node.</description></method><method name="destroy" scope="instance"><description>Destroys the node.</description></method><method name="disable" scope="instance"><description>Disables this node</description></method><method name="eachChild" scope="instance"><description>Interates the child nodes of this node, calling the specified function with each node. The arguments to the function
will be the args provided or the current node. If the function returns false at any point,
the iteration stops.</description></method><method name="enable" scope="instance"><description>Enables this node</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="ensureVisible" scope="instance"><description>Ensures all parent nodes are expanded, and if necessary, scrolls
the node into view.</description></method><method name="expand" scope="instance"><description>Expand this node.</description></method><method name="expandChildNodes" scope="instance"><description>Expand all child nodes</description></method><method name="findChild" scope="instance"><description>Finds the first child that has the attribute with the specified value.</description></method><method name="findChildBy" scope="instance"><description>Finds the first child by a custom function. The child matches if the function passed returns true.</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="getDepth" scope="instance"><description>Returns depth of this node (the root node has a depth of 0)</description></method><method name="getOwnerTree" scope="instance"><description>Returns the tree this node is in.</description></method><method name="getPath" scope="instance"><description>Returns the path for this node. The path can be used to expand or select this node programmatically.</description></method><method name="getUI" scope="instance"><description>Returns the UI object for this node.</description></method><method name="hasChildNodes" scope="instance"><description>Returns true if this node has one or more child nodes, else false.</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="indexOf" scope="instance"><description>Returns the index of a child node</description></method><method name="insertBefore" scope="instance"><description>Inserts the first node before the second node in this nodes childNodes collection.</description></method><method name="isAncestor" scope="instance"><description>Returns true if the passed node is an ancestor (at any point) of this node.</description></method><method name="isExpandable" scope="instance"><description>Returns true if this node has one or more child nodes, or if the expandable
node attribute is explicitly specified as true (see attributes), otherwise returns false.</description></method><method name="isExpanded" scope="instance"><description>Returns true if this node is expanded</description></method><method name="isFirst" scope="instance"><description>Returns true if this node is the first child of its parent</description></method><method name="isLast" scope="instance"><description>Returns true if this node is the last child of its parent</description></method><method name="isLeaf" scope="instance"><description>Returns true if this node is a leaf</description></method><method name="isLoaded" scope="instance"><description>Returns true if this node has been loaded</description></method><method name="isLoading" scope="instance"><description>Returns true if this node is currently loading</description></method><method name="isSelected" scope="instance"><description>Returns true if this node is selected</description></method><method name="item" scope="instance"><description>Returns the child node at the specified index.</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="reload" scope="instance"><description>Trigger a reload for this node</description></method><method name="remove" scope="instance"><description>Removes this node from its parent</description></method><method name="removeAll" scope="instance"><description>Removes all child nodes from this node.</description></method><method name="removeChild" scope="instance"><description>Removes a child node from this node.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="replaceChild" scope="instance"><description>Replaces one child node in this node with another.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="select" scope="instance"><description>Triggers selection of this node</description></method><method name="setCls" scope="instance"><description>Sets the class on this node.</description></method><method name="setHref" scope="instance"><description>Sets the href for the node.</description></method><method name="setIcon" scope="instance"><description>Sets the icon for this node.</description></method><method name="setIconCls" scope="instance"><description>Sets the icon class for this node.</description></method><method name="setId" scope="instance"><description>Changes the id of this node.</description></method><method name="setText" scope="instance"><description>Sets the text for this node</description></method><method name="setTooltip" scope="instance"><description>Sets the tooltip for this node.</description></method><method name="sort" scope="instance"><description>Sorts this nodes children using the supplied sort function.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="toggle" scope="instance"><description>Toggles expanded/collapsed state of the node</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="unselect" scope="instance"><description>Triggers deselection of this node</description></method></methods></class><class superclass="Object" type="Ext.KeyMap"><description>Handles mapping keys to actions for an element. One key map can be used for multiple actions.
The constructor accepts the same config object as defined by addBinding.
If you bind a callback function to a KeyMap, anytime the KeyMap handles an expected key
combination it will call the function with this signature (if the match is a multi-key
combination the callback will still be called only once): (String key, Ext.EventObject e)
A KeyMap can also handle a string representation of keys.
Usage:
 // map one key by key code
var map = new Ext.KeyMap(&quot;my-element&quot;, {
    key: 13, // or Ext.EventObject.ENTER
    fn: myHandler,
    scope: myObject
});

// map multiple keys to one action by string
var map = new Ext.KeyMap(&quot;my-element&quot;, {
    key: &quot;a\r\n\t&quot;,
    fn: myHandler,
    scope: myObject
});

// map multiple keys to multiple actions by strings and array of codes
var map = new Ext.KeyMap(&quot;my-element&quot;, [
    {
        key: [10,13],
        fn: function(){ alert(&quot;Return was pressed&quot;); }
    }, {
        key: &quot;abc&quot;,
        fn: function(){ alert('a, b or c was pressed'); }
    }, {
        key: &quot;\t&quot;,
        ctrl:true,
        shift:true,
        fn: function(){ alert('Control + shift + tab was pressed.'); }
    }
]);
Note: A KeyMap starts enabled</description><constructors/><properties/><methods><method name="addBinding" scope="instance"><description>Add a new binding to this KeyMap. The following config object properties are supported:

Property    Type             Description
----------  ---------------  ----------------------------------------------------------------------
key         String/Array     A single keycode or an array of keycodes to handle
shift       Boolean          True to handle key only when shift is pressed, False to handle the key only when shift is not pressed (defaults to undefined)
ctrl        Boolean          True to handle key only when ctrl is pressed, False to handle the key only when ctrl is not pressed (defaults to undefined)
alt         Boolean          True to handle key only when alt is pressed, False to handle the key only when alt is not pressed (defaults to undefined)
handler     Function         The function to call when KeyMap finds the expected key combination
fn          Function         Alias of handler (for backwards-compatibility)
scope       Object           The scope of the callback function
stopEvent   Boolean          True to stop the event from bubbling and prevent the default browser action if the key was handled by the KeyMap (defaults to false)

Usage:
// Create a KeyMap
var map = new Ext.KeyMap(document, {
    key: Ext.EventObject.ENTER,
    fn: handleKey,
    scope: this
});

//Add a new binding to the existing KeyMap later
map.addBinding({
    key: 'abc',
    shift: true,
    fn: handleKey,
    scope: this
});</description></method><method name="disable" scope="instance"><description>Disable this KeyMap</description></method><method name="enable" scope="instance"><description>Enables this KeyMap</description></method><method name="isEnabled" scope="instance"><description>Returns true if this KeyMap is enabled</description></method><method name="on" scope="instance"><description>Shorthand for adding a single key listener</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method></methods></class><class superclass="Object" type="Ext.Element"><description>Encapsulates a DOM element, adding simple DOM manipulation facilities, normalizing for browser differences.
All instances of this class inherit the methods of Ext.Fx making visual effects easily available to all DOM elements.
Note that the events documented in this class are not Ext events, they encapsulate browser events. To
access the underlying browser event, see Ext.EventObject.browserEvent. Some older
browsers may not support the full range of events. Which events are supported is beyond the control of ExtJs.
Usage:
// by id
var el = Ext.get(&quot;my-div&quot;);

// by DOM element reference
var el = Ext.get(myDivElement);
Animations
When an element is manipulated, by default there is no animation.
var el = Ext.get(&quot;my-div&quot;);

// no animation
el.setWidth(100);
Many of the functions for manipulating an element have an optional &quot;animate&quot; parameter.  This
parameter can be specified as boolean (true) for default animation effects.
// default animation
el.setWidth(100, true);
To configure the effects, an object literal with animation options to use as the Element animation
configuration object can also be specified. Note that the supported Element animation configuration
options are a subset of the Ext.Fx animation options specific to Fx effects.  The supported
Element animation configuration options are:

Option    Default   Description
--------- --------  ---------------------------------------------
duration  .35       The duration of the animation in seconds
easing    easeOut   The easing method
callback  none      A function to execute when the anim completes
scope     this      The scope (this) of the callback function

// Element animation options object
var opt = {
    duration: 1,
    easing: 'elasticIn',
    callback: this.foo,
    scope: this
};
// animation with some options set
el.setWidth(100, opt);
The Element animation object being used for the animation will be set on the options
object as &quot;anim&quot;, which allows you to stop or manipulate the animation. Here is an example:
// using the &quot;anim&quot; property to get the Anim object
if(opt.anim.isAnimated()){
    opt.anim.stop();
}
Also see the animate method for another animation technique.
 Composite (Collections of) Elements
For working with collections of Elements, see Ext.CompositeElement</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds one or more CSS classes to the element. Duplicate classes are automatically filtered out.</description></method><method name="addClassOnClick" scope="instance"><description>Sets up event handlers to add and remove a css class when the mouse is down and then up on this element (a click effect)</description></method><method name="addClassOnFocus" scope="instance"><description>Sets up event handlers to add and remove a css class when this element has the focus</description></method><method name="addClassOnOver" scope="instance"><description>Sets up event handlers to add and remove a css class when the mouse is over this element</description></method><method name="addKeyListener" scope="instance"><description>Convenience method for constructing a KeyMap</description></method><method name="addKeyMap" scope="instance"><description>Creates a KeyMap for this element</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this element.  The shorthand version on is equivalent.</description></method><method name="alignTo" scope="instance"><description>Aligns this element with another element relative to the specified anchor points. If the other element is the
document it aligns it to the viewport.
The position parameter is optional, and can be specified in any one of the following formats:

Blank: Defaults to aligning the element's top-left corner to the target's bottom-left corner (&quot;tl-bl&quot;).
One anchor (deprecated): The passed anchor position is used as the target element's anchor point.
The element being aligned will position its top-left corner (tl) to that point.  This method has been
deprecated in favor of the newer two anchor syntax below.
Two anchors: If two values from the table below are passed separated by a dash, the first value is used as the
element's anchor point, and the second value is used as the target's anchor point.

In addition to the anchor points, the position parameter also supports the &quot;?&quot; character.  If &quot;?&quot; is passed at the end of
the position string, the element will attempt to align as specified, but the position will be adjusted to constrain to
the viewport if necessary.  Note that the element being aligned might be swapped to align to a different position than
that specified in order to enforce the viewport constraints.
Following are all of the supported anchor positions:

Value  Description
-----  -----------------------------
tl     The top left corner (default)
t      The center of the top edge
tr     The top right corner
l      The center of the left edge
c      In the center of the element
r      The center of the right edge
bl     The bottom left corner
b      The center of the bottom edge
br     The bottom right corner

Example Usage:
// align el to other-el using the default positioning (&quot;tl-bl&quot;, non-constrained)
el.alignTo(&quot;other-el&quot;);

// align the top left corner of el with the top right corner of other-el (constrained to viewport)
el.alignTo(&quot;other-el&quot;, &quot;tr?&quot;);

// align the bottom right corner of el with the center left edge of other-el
el.alignTo(&quot;other-el&quot;, &quot;br-l?&quot;);

// align the center of el with the bottom left corner of other-el and
// adjust the x position by -6 pixels (and the y position by 0)
el.alignTo(&quot;other-el&quot;, &quot;c-bl&quot;, [-6, 0]);</description></method><method name="anchorTo" scope="instance"><description>Anchors an element to another element and realigns it when the window is resized.</description></method><method name="animate" scope="instance"><description>Perform custom animation on this element.

Animation Properties
The Animation Control Object enables gradual transitions for any member of an
element's style object that takes a numeric value including but not limited to
these properties:
bottom, top, left, right
height, width
margin, padding
borderWidth
opacity
fontSize
lineHeight

Animation Property Attributes
Each Animation Property is a config object with optional properties:

by*  : relative change - start at current value, change by this value
from : ignore current value, start from this value
to*  : start at current value, go to this value
unit : any allowable unit specification
* do not specify both to and by for an animation property

Animation Types
The supported animation types:
'run' : Default
var el = Ext.get('complexEl');
el.animate(
    // animation control object
    {
        borderWidth: {to: 3, from: 0},
        opacity: {to: .3, from: 1},
        height: {to: 50, from: el.getHeight()},
        width: {to: 300, from: el.getWidth()},
        top  : {by: - 100, unit: 'px'},
    },
    0.35,      // animation duration
    null,      // callback
    'easeOut', // easing method
    'run'      // animation type ('run','color','motion','scroll')
);

'color'
Animates transition of background, text, or border colors.
el.animate(
    // animation control object
    {
        color: { to: '#06e' },
        backgroundColor: { to: '#e06' }
    },
    0.35,      // animation duration
    null,      // callback
    'easeOut', // easing method
    'color'    // animation type ('run','color','motion','scroll')
);

'motion'
Animates the motion of an element to/from specific points using optional bezier
way points during transit.
el.animate(
    // animation control object
    {
        borderWidth: {to: 3, from: 0},
        opacity: {to: .3, from: 1},
        height: {to: 50, from: el.getHeight()},
        width: {to: 300, from: el.getWidth()},
        top  : {by: - 100, unit: 'px'},
        points: {
            to: [50, 100],  // go to this point
            control: [      // optional bezier way points
                [ 600, 800],
                [-100, 200]
            ]
        }
    },
    3000,      // animation duration (milliseconds!)
    null,      // callback
    'easeOut', // easing method
    'motion'   // animation type ('run','color','motion','scroll')
);

'scroll'
Animate horizontal or vertical scrolling of an overflowing page element.
el.animate(
    // animation control object
    {
        scroll: {to: [400, 300]}
    },
    0.35,      // animation duration
    null,      // callback
    'easeOut', // easing method
    'scroll'   // animation type ('run','color','motion','scroll')
);


</description></method><method name="appendChild" scope="instance"><description>Appends the passed element(s) to this element</description></method><method name="appendTo" scope="instance"><description>Appends this element to the passed element</description></method><method name="applyStyles" scope="instance"><description>More flexible version of setStyle for setting style properties.</description></method><method name="blur" scope="instance"><description>Tries to blur the element. Any exceptions are caught and ignored.</description></method><method name="boxWrap" scope="instance"><description>Wraps the specified element with a special 9 element markup/CSS block that renders by default as
a gray container with a gradient background, rounded corners and a 4-way shadow.
This special markup is used throughout Ext when box wrapping elements (Ext.Button,
Ext.Panel when frame=true, Ext.Window).  The markup
is of this form:
Ext.Element.boxMarkup =
    &#39;&lt;div class=&quot;{0}-tl&quot;&gt;&lt;div class=&quot;{0}-tr&quot;&gt;&lt;div class=&quot;{0}-tc&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
     &lt;div class=&quot;{0}-ml&quot;&gt;&lt;div class=&quot;{0}-mr&quot;&gt;&lt;div class=&quot;{0}-mc&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
     &lt;div class=&quot;{0}-bl&quot;&gt;&lt;div class=&quot;{0}-br&quot;&gt;&lt;div class=&quot;{0}-bc&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&#39;;
Example usage:
// Basic box wrap
    Ext.get(&quot;foo&quot;).boxWrap();

    // You can also add a custom class and use CSS inheritance rules to customize the box look.
    // 'x-box-blue' is a built-in alternative -- look at the related CSS definitions as an example
    // for how to create a custom box wrap style.
    Ext.get(&quot;foo&quot;).boxWrap().addClass(&quot;x-box-blue&quot;);</description></method><method name="center" scope="instance"><description>Centers the Element in either the viewport, or another Element.</description></method><method name="child" scope="instance"><description>Selects a single child at any depth below this element based on the passed CSS selector (the selector should not contain an id).</description></method><method name="clean" scope="instance"><description>Removes worthless text nodes</description></method><method name="clearOpacity" scope="instance"><description>Clears any opacity settings from this element. Required in some cases for IE.</description></method><method name="clearPositioning" scope="instance"><description>Clear positioning back to the default when the document was loaded</description></method><method name="clip" scope="instance"><description>Store the current overflow setting and clip overflow on the element - use unclip to remove</description></method><method name="contains" scope="instance"><description>Returns true if this element is an ancestor of the passed element</description></method><method name="createChild" scope="instance"><description>Creates the passed DomHelper config and appends it to this element or optionally inserts it before the passed child element.</description></method><method name="createProxy" scope="instance"><description>Creates a proxy element of this element</description></method><method name="createShim" scope="instance"><description>Creates an iframe shim for this element to keep selects and other windowed objects from
showing through.</description></method><method name="down" scope="instance"><description>Selects a single *direct* child based on the passed CSS selector (the selector should not contain an id).</description></method><method name="enableDisplayMode" scope="instance"><description>Convenience method for setVisibilityMode(Element.DISPLAY)</description></method><method name="findParent" scope="instance"><description>Looks at this node and then at parent nodes for a match of the passed simple selector (e.g. div.some-class or span:first-child)</description></method><method name="findParentNode" scope="instance"><description>Looks at parent nodes for a match of the passed simple selector (e.g. div.some-class or span:first-child)</description></method><method name="first" scope="instance"><description>Gets the first child, skipping text nodes</description></method><method name="fly" scope="instance"><description>Gets the globally shared flyweight Element, with the passed node as the active element. Do not store a reference to this element -
the dom node can be overwritten by other code. Shorthand of Ext.Element.fly
Use this to make one-time references to DOM elements which are not going to be accessed again either by
application code, or by Ext's classes. If accessing an element which will be processed regularly, then Ext.get
will be more appropriate to take advantage of the caching provided by the Ext.Element class.</description></method><method name="focus" scope="instance"><description>Tries to focus the element. Any exceptions are caught and ignored.</description></method><method name="get" scope="instance"><description>Retrieves Ext.Element objects.
This method does not retrieve Components. This method
retrieves Ext.Element objects which encapsulate DOM elements. To retrieve a Component by
its ID, use Ext.ComponentMgr.get.
Uses simple caching to consistently return the same object. Automatically fixes if an
object was recreated with the same id via AJAX or DOM.</description></method><method name="getAlignToXY" scope="instance"><description>Gets the x,y coordinates to align this element with another element. See alignTo for more info on the
supported position values.</description></method><method name="getAnchorXY" scope="instance"><description>Gets the x,y coordinates specified by the anchor position on the element.</description></method><method name="getAttribute" scope="instance"><description>Returns the value of an attribute from the element's underlying DOM node.</description></method><method name="getAttributeNS" scope="instance"><description>Returns the value of a namespaced attribute from the element's underlying DOM node.</description></method><method name="getBorderWidth" scope="instance"><description>Gets the width of the border(s) for the specified side(s)</description></method><method name="getBottom" scope="instance"><description>Gets the bottom Y coordinate of the element (element Y position + element height)</description></method><method name="getBox" scope="instance"><description>Return an object defining the area of this Element which can be passed to setBox to
set another Element's size/location to match this element.</description></method><method name="getCenterXY" scope="instance"><description>Calculates the x, y to center this element on the screen</description></method><method name="getColor" scope="instance"><description>Return the CSS color for the specified CSS attribute. rgb, 3 digit (like #fff) and valid values
are convert to standard 6 digit hex color.</description></method><method name="getComputedHeight" scope="instance"><description>Returns either the offsetHeight or the height of this element based on CSS height adjusted by padding or borders
when needed to simulate offsetHeight when offsets aren't available. This may not work on display:none elements
if a height has not been set using CSS.</description></method><method name="getComputedWidth" scope="instance"><description>Returns either the offsetWidth or the width of this element based on CSS width adjusted by padding or borders
when needed to simulate offsetWidth when offsets aren't available. This may not work on display:none elements
if a width has not been set using CSS.</description></method><method name="getFrameWidth" scope="instance"><description>Returns the sum width of the padding and borders for the passed &quot;sides&quot;. See getBorderWidth()
         for more information about the sides.</description></method><method name="getHeight" scope="instance"><description>Returns the offset height of the element</description></method><method name="getLeft" scope="instance"><description>Gets the left X coordinate</description></method><method name="getMargins" scope="instance"><description>Returns an object with properties top, left, right and bottom representing the margins of this element unless sides is passed,
then it returns the calculated width of the sides (see getPadding)</description></method><method name="getOffsetsTo" scope="instance"><description>Returns the offsets of this element from the passed element. Both element must be part of the DOM tree and not have display:none to have page coordinates.</description></method><method name="getPadding" scope="instance"><description>Gets the width of the padding(s) for the specified side(s)</description></method><method name="getPositioning" scope="instance"><description>Gets an object with all CSS positioning properties. Useful along with setPostioning to get
snapshot before performing an update and then restoring the element.</description></method><method name="getRegion" scope="instance"><description>Returns the region of the given element.
The element must be part of the DOM tree to have a region (display:none or elements not appended return false).</description></method><method name="getRight" scope="instance"><description>Gets the right X coordinate of the element (element X position + element width)</description></method><method name="getScroll" scope="instance"><description>Returns the current scroll position of the element.</description></method><method name="getSize" scope="instance"><description>Returns the size of the element.</description></method><method name="getStyle" scope="instance"><description>Normalizes currentStyle and computedStyle.</description></method><method name="getStyleSize" scope="instance"><description>Returns the dimensions of the element available to lay content out in.
getStyleSize utilizes prefers style sizing if present, otherwise it chooses the larger of offsetHeight/clientHeight and offsetWidth/clientWidth.
To obtain the size excluding scrollbars, use getViewSize
Sizing of the document body is handled at the adapter level which handles special cases for IE and strict modes, etc.</description></method><method name="getStyles" scope="instance"><description>Returns an object with properties matching the styles requested.
For example, el.getStyles('color', 'font-size', 'width') might return
{'color': '#FFFFFF', 'font-size': '13px', 'width': '100px'}.</description></method><method name="getTextWidth" scope="instance"><description>Returns the width in pixels of the passed text, or the width of the text in this Element.</description></method><method name="getTop" scope="instance"><description>Gets the top Y coordinate</description></method><method name="getUpdater" scope="instance"><description>Gets this element's Updater</description></method><method name="getValue" scope="instance"><description>Returns the value of the &quot;value&quot; attribute</description></method><method name="getViewSize" scope="instance"><description>Returns the dimensions of the element available to lay content out in.
If the element (or any ancestor element) has CSS style display : none, the dimensions will be zero.
example:var vpSize = Ext.getBody().getViewSize();

        // all Windows created afterwards will have a default value of 90% height and 95% width
        Ext.Window.override({
            width: vpSize.width * 0.9,
            height: vpSize.height * 0.95
        });
        // To handle window resizing you would have to hook onto onWindowResize.
getViewSize utilizes clientHeight/clientWidth which excludes sizing of scrollbars.
To obtain the size including scrollbars, use getStyleSize
Sizing of the document body is handled at the adapter level which handles special cases for IE and strict modes, etc.</description></method><method name="getWidth" scope="instance"><description>Returns the offset width of the element</description></method><method name="getX" scope="instance"><description>Gets the current X position of the element based on page coordinates.  Element must be part of the DOM tree to have page coordinates (display:none or elements not appended return false).</description></method><method name="getXY" scope="instance"><description>Gets the current position of the element based on page coordinates.  Element must be part of the DOM tree to have page coordinates (display:none or elements not appended return false).</description></method><method name="getY" scope="instance"><description>Gets the current Y position of the element based on page coordinates.  Element must be part of the DOM tree to have page coordinates (display:none or elements not appended return false).</description></method><method name="hasClass" scope="instance"><description>Checks if the specified CSS class exists on this element's DOM node.</description></method><method name="hide" scope="instance"><description>Hide this element - Uses display mode to determine whether to use &quot;display&quot; or &quot;visibility&quot;. See setVisible.</description></method><method name="hover" scope="instance"><description>Sets up event handlers to call the passed functions when the mouse is moved into and out of the Element.</description></method><method name="initDD" scope="instance"><description>Initializes a Ext.dd.DD drag drop object for this element.</description></method><method name="initDDProxy" scope="instance"><description>Initializes a Ext.dd.DDProxy object for this element.</description></method><method name="initDDTarget" scope="instance"><description>Initializes a Ext.dd.DDTarget object for this element.</description></method><method name="insertAfter" scope="instance"><description>Inserts this element after the passed element in the DOM</description></method><method name="insertBefore" scope="instance"><description>Inserts this element before the passed element in the DOM</description></method><method name="insertFirst" scope="instance"><description>Inserts (or creates) an element (or DomHelper config) as the first child of this element</description></method><method name="insertHtml" scope="instance"><description>Inserts an html fragment into this element</description></method><method name="insertSibling" scope="instance"><description>Inserts (or creates) the passed element (or DomHelper config) as a sibling of this element</description></method><method name="is" scope="instance"><description>Returns true if this element matches the passed simple selector (e.g. div.some-class or span:first-child)</description></method><method name="isBorderBox" scope="instance"><description>Tests various css rules/browsers to determine if this element uses a border box</description></method><method name="isDisplayed" scope="instance"><description>Returns true if display is not &quot;none&quot;</description></method><method name="isMasked" scope="instance"><description>Returns true if this element is masked</description></method><method name="isScrollable" scope="instance"><description>Returns true if this element is scrollable.</description></method><method name="isVisible" scope="instance"><description>Checks whether the element is currently visible using both visibility and display properties.</description></method><method name="last" scope="instance"><description>Gets the last child, skipping text nodes</description></method><method name="load" scope="instance"><description>Updates the innerHTML of this Element
from a specified URL. Note that this is subject to the Same Origin Policy
Updating innerHTML of an element will not execute embedded &lt;script&gt; elements. This is a browser restriction.</description></method><method name="mask" scope="instance"><description>Puts a mask over this element to disable user interaction. Requires core.css.
This method can only be applied to elements which accept child nodes.</description></method><method name="move" scope="instance"><description>Move this element relative to its current position.</description></method><method name="moveTo" scope="instance"><description>Sets the position of the element in page coordinates, regardless of how the element is positioned.
The element must be part of the DOM tree to have page coordinates (display:none or elements not appended return false).</description></method><method name="next" scope="instance"><description>Gets the next sibling, skipping text nodes</description></method><method name="on" scope="instance"><description>Appends an event handler (shorthand for addListener).</description></method><method name="parent" scope="instance"><description>Gets the parent node for this element, optionally chaining up trying to match a selector</description></method><method name="position" scope="instance"><description>Initializes positioning on this element. If a desired position is not passed, it will make the
the element positioned relative IF it is not already positioned.</description></method><method name="prev" scope="instance"><description>Gets the previous sibling, skipping text nodes</description></method><method name="purgeAllListeners" scope="instance"><description>Recursively removes all previous added listeners from this element and its children</description></method><method name="query" scope="instance"><description>Selects child nodes based on the passed CSS selector (the selector should not contain an id).</description></method><method name="radioClass" scope="instance"><description>Adds one or more CSS classes to this element and removes the same class(es) from all siblings.</description></method><method name="relayEvent" scope="instance"><description>Create an event handler on this element such that when the event fires and is handled by this element,
it will be relayed to another object (i.e., fired again as if it originated from that object instead).</description></method><method name="remove" scope="instance"><description>Removes this element's dom reference.  Note that event and cache removal is handled at Ext.removeNode</description></method><method name="removeAllListeners" scope="instance"><description>Removes all previous added listeners from this element</description></method><method name="removeAnchor" scope="instance"><description>Remove any anchor to this element. See anchorTo.</description></method><method name="removeClass" scope="instance"><description>Removes one or more CSS classes from the element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler from this element.  The shorthand version un is equivalent.
Note: if a scope was explicitly specified when adding the
listener, the same scope must be specified here.
Example:
el.removeListener('click', this.handlerFn);
// or
el.un('click', this.handlerFn);</description></method><method name="repaint" scope="instance"><description>Forces the browser to repaint this element</description></method><method name="replace" scope="instance"><description>Replaces the passed element with this element</description></method><method name="replaceClass" scope="instance"><description>Replaces a CSS class on the element with another.  If the old name does not exist, the new name will simply be added.</description></method><method name="replaceWith" scope="instance"><description>Replaces this element with the passed element</description></method><method name="scroll" scope="instance"><description>Scrolls this element the specified direction. Does bounds checking to make sure the scroll is
within this element's scrollable range.</description></method><method name="scrollIntoView" scope="instance"><description>Scrolls this element into view within the passed container.</description></method><method name="scrollTo" scope="instance"><description>Scrolls this element the specified scroll point. It does NOT do bounds checking so if you scroll to a weird value it will try to do it. For auto bounds checking, use scroll().</description></method><method name="select" scope="instance"><description>Creates a Ext.CompositeElement for child nodes based on the passed CSS selector (the selector should not contain an id).</description></method><method name="set" scope="instance"><description>Sets the passed attributes as attributes of this element (a style attribute can be a string, object or function)</description></method><method name="setBottom" scope="instance"><description>Sets the element's CSS bottom style.</description></method><method name="setBounds" scope="instance"><description>Sets the element's position and size in one shot. If animation is true then width, height, x and y will be animated concurrently.</description></method><method name="setBox" scope="instance"><description>Sets the element's box. Use getBox() on another element to get a box obj. If animate is true then width, height, x and y will be animated concurrently.</description></method><method name="setDisplayed" scope="instance"><description>Sets the CSS display property. Uses originalDisplay if the specified value is a boolean true.</description></method><method name="setHeight" scope="instance"><description>Set the height of this Element.
// change the height to 200px and animate with default configuration
Ext.fly('elementId').setHeight(200, true);

// change the height to 150px and animate with a custom configuration
Ext.fly('elId').setHeight(150, {
    duration : .5, // animation will have a duration of .5 seconds
    // will change the content to &quot;finished&quot;
    callback: function(){ this.update(&quot;finished&quot;); }
});</description></method><method name="setLeft" scope="instance"><description>Sets the element's left position directly using CSS style (instead of setX).</description></method><method name="setLeftTop" scope="instance"><description>Quick set left and top adding default units</description></method><method name="setLocation" scope="instance"><description>Sets the position of the element in page coordinates, regardless of how the element is positioned.
The element must be part of the DOM tree to have page coordinates (display:none or elements not appended return false).</description></method><method name="setOpacity" scope="instance"><description>Set the opacity of the element</description></method><method name="setPositioning" scope="instance"><description>Set positioning with an object returned by getPositioning().</description></method><method name="setRegion" scope="instance"><description>Sets the element's position and size the specified region. If animation is true then width, height, x and y will be animated concurrently.</description></method><method name="setRight" scope="instance"><description>Sets the element's CSS right style.</description></method><method name="setSize" scope="instance"><description>Set the size of this Element. If animation is true, both width and height will be animated concurrently.</description></method><method name="setStyle" scope="instance"><description>Wrapper for setting style properties, also takes single object parameter of multiple styles.</description></method><method name="setTop" scope="instance"><description>Sets the element's top position directly using CSS style (instead of setY).</description></method><method name="setVisibilityMode" scope="instance"><description>Sets the element's visibility mode. When setVisible() is called it
will use this to determine whether to set the visibility or the display property.</description></method><method name="setVisible" scope="instance"><description>Sets the visibility of the element (see details). If the visibilityMode is set to Element.DISPLAY, it will use
the display property to hide the element, otherwise it uses visibility. The default is to hide and show using the visibility property.</description></method><method name="setWidth" scope="instance"><description>Set the width of this Element.</description></method><method name="setX" scope="instance"><description>Sets the X position of the element based on page coordinates.  Element must be part of the DOM tree to have page coordinates (display:none or elements not appended return false).</description></method><method name="setXY" scope="instance"><description>Sets the position of the element in page coordinates, regardless of how the element is positioned.
The element must be part of the DOM tree to have page coordinates (display:none or elements not appended return false).</description></method><method name="setY" scope="instance"><description>Sets the Y position of the element based on page coordinates.  Element must be part of the DOM tree to have page coordinates (display:none or elements not appended return false).</description></method><method name="show" scope="instance"><description>Show this element - Uses display mode to determine whether to use &quot;display&quot; or &quot;visibility&quot;. See setVisible.</description></method><method name="swallowEvent" scope="instance"><description>Stops the specified event(s) from bubbling and optionally prevents the default action</description></method><method name="toggle" scope="instance"><description>Toggles the element's visibility or display, depending on visibility mode.</description></method><method name="toggleClass" scope="instance"><description>Toggles the specified CSS class on this element (removes it if it already exists, otherwise adds it).</description></method><method name="translatePoints" scope="instance"><description>Translates the passed page coordinates into left/top css values for this element</description></method><method name="un" scope="instance"><description>Removes an event handler from this element (see removeListener for additional notes).</description></method><method name="unclip" scope="instance"><description>Return clipping (overflow) to original clipping before clip was called</description></method><method name="unmask" scope="instance"><description>Removes a previously applied mask.</description></method><method name="unselectable" scope="instance"><description>Disables text selection for this element (normalized across browsers)</description></method><method name="up" scope="instance"><description>Walks up the dom looking for a parent node that matches the passed simple selector (e.g. div.some-class or span:first-child).
This is a shortcut for findParentNode() that always returns an Ext.Element.</description></method><method name="update" scope="instance"><description>Update the innerHTML of this element</description></method><method name="wrap" scope="instance"><description>Creates and wraps this element with another element</description></method></methods></class><class superclass="Ext.Panel" type="Ext.form.FormPanel"><description>Standard form container.
Layout
By default, FormPanel is configured with layout:'form' to use an Ext.layout.FormLayout
layout manager, which styles and renders fields and labels correctly. When nesting additional Containers
within a FormPanel, you should ensure that any descendant Containers which host input Fields use the
Ext.layout.FormLayout layout manager.
BasicForm
Although not listed as configuration options of FormPanel, the FormPanel class accepts all
of the config options required to configure its internal Ext.form.BasicForm for:

file uploads
functionality for loading, validating and submitting the form

Note: If subclassing FormPanel, any configuration options for the BasicForm must be applied to
the initialConfig property of the FormPanel. Applying BasicForm
configuration settings to this will not affect the BasicForm's configuration.
Form Validation
For information on form validation see the following:

Ext.form.TextField
Ext.form.VTypes
BasicForm.doAction clientValidation notes
monitorValid

Form Submission
By default, Ext Forms are submitted through Ajax, using Ext.form.Action. To enable normal browser
submission of the BasicForm contained in this FormPanel, see the
standardSubmit option.</description><constructors/><properties/><methods><method name="add" scope="instance"><description>Adds Component(s) to this Container.
Description :

Fires the beforeadd event before adding
The Container's default config values will be applied
accordingly (see defaults for details).
Fires the add event after the component has been added.

Notes :

If the Container is already rendered when add
is called, you may need to call doLayout to refresh the view which causes
any unrendered child Components to be rendered. This is required so that you can
add multiple child components if needed while only refreshing the layout
once. For example:var tb = new Ext.Toolbar();
tb.render(document.body);  // toolbar is rendered
tb.add({text:'Button 1'}); // add multiple items (defaultType for Toolbar is 'button')
tb.add({text:'Button 2'});
tb.doLayout();             // refresh the layout
Warning: Containers directly managed by the BorderLayout layout manager
may not be removed or added.  See the Notes for BorderLayout
for more details.
</description></method><method name="addButton" scope="instance"><description>Adds a button to this panel.  Note that this method must be called prior to rendering.  The preferred
approach is to add buttons via the buttons config.</description></method><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cascade" scope="instance"><description>Cascades down the component/container heirarchy from this component (called first), calling the specified function with
each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the cascade is stopped on that branch.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="collapse" scope="instance"><description>Collapses the panel body so that it becomes hidden.  Fires the beforecollapse event which will
cancel the collapse action if it returns false.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="doLayout" scope="instance"><description>Force this container's layout to be recalculated. A call to this function is required after adding a new component
to an already rendered container, or possibly after changing sizing/position properties of child components.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="expand" scope="instance"><description>Expands the panel body so that it becomes visible.  Fires the beforeexpand event which will
cancel the expand action if it returns false.</description></method><method name="find" scope="instance"><description>Find a component under this container at any level by property</description></method><method name="findBy" scope="instance"><description>Find a component under this container at any level by a custom function. If the passed function returns
true, the component will be included in the results. The passed function is called with the arguments (component, this container).</description></method><method name="findById" scope="instance"><description>Find a component under this container at any level by id</description></method><method name="findByType" scope="instance"><description>Find a component under this container at any level by xtype or class</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="get" scope="instance"><description>Get a component contained by this container (alias for items.get(key))</description></method><method name="getBottomToolbar" scope="instance"><description>Returns the toolbar from the bottom (bbar) section of the panel.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getComponent" scope="instance"><description>Examines this container's items property
and gets a direct child component of this container.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getFooterToolbar" scope="instance"><description>Returns the toolbar from the footer (fbar) section of the panel.</description></method><method name="getForm" scope="instance"><description>Provides access to the Form which this Panel contains.</description></method><method name="getFrameHeight" scope="instance"><description>Returns the height in pixels of the framing elements of this panel (including any top and bottom bars and
header and footer elements, but not including the body height).  To retrieve the body height see getInnerHeight.</description></method><method name="getFrameWidth" scope="instance"><description>Returns the width in pixels of the framing elements of this panel (not including the body width).  To
retrieve the body width see getInnerWidth.</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getInnerHeight" scope="instance"><description>Returns the height in pixels of the body element (not including the height of any framing elements).
For the frame height see getFrameHeight.</description></method><method name="getInnerWidth" scope="instance"><description>Returns the width in pixels of the body element (not including the width of any framing elements).
For the frame width see getFrameWidth.</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getLayout" scope="instance"><description>Returns the layout currently in use by the container.  If the container does not currently have a layout
set, a default Ext.layout.ContainerLayout will be created and set as the container's layout.</description></method><method name="getLayoutTarget" scope="instance"><description>Returns the Element to be used to contain the child Components of this Container.
An implementation is provided which returns the Container's Element, but
if there is a more complex structure to a Container, this may be overridden to return
the element into which the layout renders child Components.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getTool" scope="instance"><description>Retrieve a tool by id.</description></method><method name="getTopToolbar" scope="instance"><description>Returns the toolbar from the top (tbar) section of the panel.</description></method><method name="getUpdater" scope="instance"><description>Get the Ext.Updater for this panel. Enables you to perform Ajax updates of this panel's body.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="insert" scope="instance"><description>Inserts a Component into this Container at a specified index. Fires the
beforeadd event before inserting, then fires the add event after the
Component has been inserted.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="load" scope="instance"><description>This is a proxy for the underlying BasicForm's Ext.form.BasicForm.load call.</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="remove" scope="instance"><description>Removes a component from this container.  Fires the beforeremove event before removing, then fires
the remove event after the component has been removed.</description></method><method name="removeAll" scope="instance"><description>Removes all components from this container.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setIconClass" scope="instance"><description>Sets the CSS class that provides the icon image for this panel.  This method will replace any existing
icon class if one has already been set and fire the iconchange event after completion.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setTitle" scope="instance"><description>Sets the title text for the panel and optionally the icon class.
In order to be able to set the title, a header element must have been created
for the Panel. This is triggered either by configuring the Panel with a non-blank title,
or configuring it with header: true.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="startMonitoring" scope="instance"><description>Starts monitoring of the valid state of this form. Usually this is done by passing the config
option &quot;monitorValid&quot;</description></method><method name="stopMonitoring" scope="instance"><description>Stops monitoring of the valid state of this form</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="toggleCollapse" scope="instance"><description>Shortcut for performing an expand or collapse based on the current state of the panel.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method></methods></class><class superclass="Ext.util.Observable" type="Ext.tree.DefaultSelectionModel"><description>The default single selection for a TreePanel.</description><constructors/><properties/><methods><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="clearSelections" scope="instance"><description>Clear all selections</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="getSelectedNode" scope="instance"><description>Get the selected node</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="isSelected" scope="instance"><description>Returns true if the node is selected</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="select" scope="instance"><description>Select a node.</description></method><method name="selectNext" scope="instance"><description>Selects the node above the selected node in the tree, intelligently walking the nodes</description></method><method name="selectPrevious" scope="instance"><description>Selects the node above the selected node in the tree, intelligently walking the nodes</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="unselect" scope="instance"><description>Deselect a node.</description></method></methods></class><class superclass="Object" type="Ext.data.Types"><description>This is s static class containing the system-supplied data types which may be given to a Field.
The properties in this class are used as type indicators in the Field class, so to
test whether a Field is of a certain type, compare the type property against properties
of this class.
Developers may add their own application-specific data types to this class. Definition names must be UPPERCASE.
each type definition must contain three properties:

convert : FunctionA function to convert raw data values from a data block into the data
to be stored in the Field. The function is passed the collowing parameters:

v : MixedThe data value as read by the Reader, if undefined will use
the configured defaultValue.
rec : MixedThe data object containing the row as read by the Reader.
Depending on the Reader type, this could be an Array (ArrayReader), an object
(JsonReader), or an XML element (XMLReader).

sortType : Function A function to convert the stored data into comparable form, as defined by Ext.data.SortTypes.
type : String A textual data type name.

For example, to create a VELatLong field (See the Microsoft Bing Mapping API) containing the latitude/longitude value of a datapoint on a map from a JsonReader data block
which contained the properties lat and long, you would define a new data type like this:
// Add a new Field data type which stores a VELatLong object in the Record.
Ext.data.Types.VELATLONG = {
    convert: function(v, data) {
        return new VELatLong(data.lat, data.long);
    },
    sortType: function(v) {
        return v.Latitude;  // When sorting, order by latitude
    },
    type: 'VELatLong'
};
Then, when declaring a Record, use var types = Ext.data.Types; // allow shorthand type access
UnitRecord = Ext.data.Record.create([
    { name: 'unitName', mapping: 'UnitName' },
    { name: 'curSpeed', mapping: 'CurSpeed', type: types.INT },
    { name: 'latitude', mapping: 'lat', type: types.FLOAT },
    { name: 'latitude', mapping: 'lat', type: types.FLOAT },
    { name: 'position', type: types.VELATLONG }
]);</description><constructors/><properties/><methods/></class><class superclass="Ext.grid.ColumnModel" type="Ext.grid.PropertyColumnModel"><description>A custom column model for the Ext.grid.PropertyGrid.  Generally it should not need to be used directly.</description><constructors/><properties/><methods><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="destroy" scope="instance"><description>Destroys this column model by purging any event listeners. Destroys and dereferences all Columns.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findColumnIndex" scope="instance"><description>Finds the index of the first matching column for the given dataIndex.</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="getCellEditor" scope="instance"><description>Returns the editor defined for the cell/column.</description></method><method name="getColumnById" scope="instance"><description>Returns the column for a specified id.</description></method><method name="getColumnCount" scope="instance"><description>Returns the number of columns.</description></method><method name="getColumnHeader" scope="instance"><description>Returns the header for the specified column.</description></method><method name="getColumnId" scope="instance"><description>Returns the id of the column at the specified index.</description></method><method name="getColumnTooltip" scope="instance"><description>Returns the tooltip for the specified column.</description></method><method name="getColumnWidth" scope="instance"><description>Returns the width for the specified column.</description></method><method name="getColumnsBy" scope="instance"><description>Returns the column configs that return true by the passed function that is called
with (columnConfig, index)
// returns an array of column config objects for all hidden columns
var columns = grid.getColumnModel().getColumnsBy(function(c){
  return c.hidden;
});</description></method><method name="getDataIndex" scope="instance"><description>Returns the dataIndex for the specified column.
// Get field name for the column
var fieldName = grid.getColumnModel().getDataIndex(columnIndex);</description></method><method name="getIndexById" scope="instance"><description>Returns the index for a specified column id.</description></method><method name="getRenderer" scope="instance"><description>Returns the rendering (formatting) function defined for the column.</description></method><method name="getTotalWidth" scope="instance"><description>Returns the total width of all columns.</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="isCellEditable" scope="instance"><description>Returns true if the cell is editable.
var store = new Ext.data.Store({...});
var colModel = new Ext.grid.ColumnModel({
  columns: [...],
  isCellEditable: function(col, row) {
    var record = store.getAt(row);
    if (record.get('readonly')) { // replace with your condition
      return false;
    }
    return Ext.grid.ColumnModel.prototype.isCellEditable.call(this, col, row);
  }
});
var grid = new Ext.grid.GridPanel({
  store: store,
  colModel: colModel,
  ...
});</description></method><method name="isFixed" scope="instance"><description>Returns true if the column is fixed,
false otherwise.</description></method><method name="isHidden" scope="instance"><description>Returns true if the column is hidden,
false otherwise.</description></method><method name="isMenuDisabled" scope="instance"><description>Returns true if the specified column menu is disabled.</description></method><method name="isResizable" scope="instance"><description>Returns true if the column can be resized</description></method><method name="isSortable" scope="instance"><description>Returns true if the specified column is sortable.</description></method><method name="moveColumn" scope="instance"><description>Moves a column from one position to another.</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setColumnHeader" scope="instance"><description>Sets the header for a column.</description></method><method name="setColumnTooltip" scope="instance"><description>Sets the tooltip for a column.</description></method><method name="setColumnWidth" scope="instance"><description>Sets the width for a column.</description></method><method name="setConfig" scope="instance"><description>Reconfigures this column model according to the passed Array of column definition objects.
For a description of the individual properties of a column definition object, see the
Config Options.
Causes the configchange event to be fired. A GridPanel
using this ColumnModel will listen for this event and refresh its UI automatically.</description></method><method name="setDataIndex" scope="instance"><description>Sets the dataIndex for a column.</description></method><method name="setEditable" scope="instance"><description>Sets if a column is editable.</description></method><method name="setEditor" scope="instance"><description>Sets the editor for a column and destroys the prior editor.</description></method><method name="setHidden" scope="instance"><description>Sets if a column is hidden.
myGrid.getColumnModel().setHidden(0, true); // hide column 0 (0 = the first column).</description></method><method name="setRenderer" scope="instance"><description>Sets the rendering (formatting) function for a column.  See Ext.util.Format for some
default formatting functions.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method></methods></class><class superclass="Object" type="Ext.chart.Series"><description>Series class for the charts widget.</description><constructors/><properties/><methods/></class><class superclass="Ext.grid.RowSelectionModel" type="Ext.grid.CheckboxSelectionModel"><description>A custom selection model that renders a column of checkboxes that can be toggled to select or deselect rows.</description><constructors/><properties/><methods><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="clearSelections" scope="instance"><description>Clears all selections if the selection model
is not locked.</description></method><method name="deselectRange" scope="instance"><description>Deselects a range of rows if the selection model
is not locked.  
All rows in between startRow and endRow are also deselected.</description></method><method name="deselectRow" scope="instance"><description>Deselects a row.  Before deselecting a row, checks if the selection model
is locked.
If this check is satisfied the row will be deselected and followed up by
firing the rowdeselect and selectionchange events.</description></method><method name="each" scope="instance"><description>Calls the passed function with each selection. If the function returns
false, iteration is stopped and this function returns
false. Otherwise it returns true.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="getCount" scope="instance"><description>Gets the number of selected rows.</description></method><method name="getSelected" scope="instance"><description>Returns the first selected record.</description></method><method name="getSelections" scope="instance"><description>Returns the selected records</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hasNext" scope="instance"><description>Returns true if there is a next record to select</description></method><method name="hasPrevious" scope="instance"><description>Returns true if there is a previous record to select</description></method><method name="hasSelection" scope="instance"><description>Returns true if there is a selection.</description></method><method name="isIdSelected" scope="instance"><description>Returns true if the specified record id is selected.</description></method><method name="isLocked" scope="instance"><description>Returns true if the selections are locked.</description></method><method name="isSelected" scope="instance"><description>Returns true if the specified row is selected.</description></method><method name="lock" scope="instance"><description>Locks the selections.</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="selectAll" scope="instance"><description>Selects all rows if the selection model
is not locked.</description></method><method name="selectFirstRow" scope="instance"><description>Selects the first row in the grid.</description></method><method name="selectLastRow" scope="instance"><description>Select the last row.</description></method><method name="selectNext" scope="instance"><description>Selects the row immediately following the last selected row.</description></method><method name="selectPrevious" scope="instance"><description>Selects the row that precedes the last selected row.</description></method><method name="selectRange" scope="instance"><description>Selects a range of rows if the selection model
is not locked.
All rows in between startRow and endRow are also selected.</description></method><method name="selectRecords" scope="instance"><description>Select records.</description></method><method name="selectRow" scope="instance"><description>Selects a row.  Before selecting a row, checks if the selection model
is locked and fires the
beforerowselect event.  If these checks are satisfied the row
will be selected and followed up by  firing the rowselect and
selectionchange events.</description></method><method name="selectRows" scope="instance"><description>Selects multiple rows.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="unlock" scope="instance"><description>Unlocks the selections.</description></method></methods></class><class superclass="Object" type="Ext.ComponentMgr"><description>Provides a registry of all Components (instances of Ext.Component or any subclass
thereof) on a page so that they can be easily accessed by component
id (see get, or the convenience method Ext.getCmp).
This object also provides a registry of available Component classes
indexed by a mnemonic code known as the Component's xtype.
The xtype provides a way to avoid instantiating child Components
when creating a full, nested config object for a complete Ext page.
A child Component may be specified simply as a config object
as long as the correct xtype is specified so that if and when the Component
needs rendering, the correct type can be looked up for lazy instantiation.
For a list of all available xtypes, see Ext.Component.</description><constructors/><properties/><methods><method name="create" scope="instance"><description>Creates a new Component from the specified config object using the
config object's xtype to determine the class to instantiate.</description></method><method name="createPlugin" scope="instance"><description>Creates a new Plugin from the specified config object using the
config object's ptype to determine the class to instantiate.</description></method><method name="get" scope="instance"><description>Returns a component by id.
For additional details see Ext.util.MixedCollection.get.</description></method><method name="isPluginRegistered" scope="instance"><description>Checks if a Plugin type is registered.</description></method><method name="isRegistered" scope="instance"><description>Checks if a Component type is registered.</description></method><method name="onAvailable" scope="instance"><description>Registers a function that will be called when a Component with the specified id is added to ComponentMgr. This will happen on instantiation.</description></method><method name="register" scope="instance"><description>Registers a component.</description></method><method name="registerPlugin" scope="instance"><description>Registers a new Plugin constructor, keyed by a new
Ext.Component.ptype.
Use this method (or its alias Ext.preg) to register new
plugins for Ext.Components so that lazy instantiation may be used when specifying
Plugins.</description></method><method name="registerType" scope="instance"><description>Registers a new Component constructor, keyed by a new
Ext.Component.xtype.
Use this method (or its alias Ext.reg) to register new
subclasses of Ext.Component so that lazy instantiation may be used when specifying
child Components.
see Ext.Container.items</description></method><method name="unregister" scope="instance"><description>Unregisters a component.</description></method></methods></class><class superclass="Ext.form.TextField" type="Ext.form.NumberField"><description>Numeric text field that provides automatic keystroke filtering and numeric validation.</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="autoSize" scope="instance"><description>Automatically grows the field to accomodate the width of the text up to the maximum field width allowed.
This only takes effect if grow = true, and fires the autosize event.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="clearInvalid" scope="instance"><description>Clear any invalid styles/messages for this field</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getActiveError" scope="instance"><description>Gets the active error message for this field.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getErrors" scope="instance"><description>Runs all of NumberFields validations and returns an array of any errors. Note that this first
runs TextField's validations, so the returned array is an amalgamation of all field errors.
The additional validations run test that the value is a number, and that it is within the
configured min and max values.</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getName" scope="instance"><description>Returns the name or hiddenName
attribute of the field if available.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getRawValue" scope="instance"><description>Returns the raw data value which may or may not be a valid, defined value.  To return a normalized value see getValue.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getValue" scope="instance"><description>Returns the normalized data value (undefined or emptyText will be returned as '').  To return the raw value see getRawValue.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isDirty" scope="instance"><description>Returns true if the value of this Field has been changed from its original value.
Will return false if the field is disabled or has not been rendered yet.
Note that if the owning form was configured with
Ext.form.BasicForm.trackResetOnLoad
then the original value is updated when the values are loaded by
Ext.form.BasicForm.setValues.</description></method><method name="isValid" scope="instance"><description>Returns whether or not the field value is currently valid by
validating the processed value
of the field. Note: disabled fields are ignored.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="markInvalid" scope="instance"><description>Display an error message associated with this field, using msgTarget to determine how to
display the message and applying invalidClass to the field's UI element.
Note: this method does not cause the Field's validate method to return false
if the value does pass validation. So simply marking a Field as invalid will not prevent
submission of forms submitted with the Ext.form.Action.Submit.clientValidation option set.
invalid.</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="processValue" scope="instance"><description>This method should only be overridden if necessary to prepare raw values
for validation (see validate and isValid).  This method
is expected to return the processed value for the field which will
be used for validation (see validateValue method).</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="reset" scope="instance"><description>Resets the current field value to the originally-loaded value and clears any validation messages.
Also adds emptyText and emptyClass if the
original value was blank.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="selectText" scope="instance"><description>Selects text in this field</description></method><method name="setActiveError" scope="instance"><description>Sets the current activeError to the given string. Fires the 'invalid' event.
This does not set up the error icon, only sets the message and fires the event. To show the error icon,
use markInvalid instead, which calls this method internally</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setMaxValue" scope="instance"><description>Replaces any existing maxValue with the new value.</description></method><method name="setMinValue" scope="instance"><description>Replaces any existing minValue with the new value.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setRawValue" scope="instance"><description>Sets the underlying DOM field's value directly, bypassing validation.  To set the value with validation see setValue.</description></method><method name="setReadOnly" scope="instance"><description>Sets the read only state of this field.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setValue" scope="instance"><description>Sets a data value into the field and validates it.  To set the value directly without validation see setRawValue.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="unsetActiveError" scope="instance"><description>Clears the activeError and fires the 'valid' event. This is called internally by clearInvalid and would not
usually need to be called manually</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method><method name="validate" scope="instance"><description>Validates the field value</description></method><method name="validateValue" scope="instance"><description>Uses getErrors to build an array of validation errors. If any errors are found, markInvalid is called
with the first and false is returned, otherwise true is returned. Previously, subclasses were invited
to provide an implementation of this to process validations - from 3.2 onwards getErrors should be
overridden instead.</description></method></methods></class><class superclass="Ext.data.DataProxy" type="Ext.data.HttpProxy"><description>An implementation of Ext.data.DataProxy that processes data requests within the same
domain of the originating page.
Note: this class cannot be used to retrieve data from a domain other
than the domain from which the running page was served. For cross-domain requests, use a
ScriptTagProxy.
Be aware that to enable the browser to parse an XML document, the server must set
the Content-Type header in the HTTP response to &quot;text/xml&quot;.</description><constructors/><properties/><methods><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="destroy" scope="instance"><description>Destroys the proxy by purging any event listeners and cancelling any active requests.</description></method><method name="doRequest" scope="instance"><description>HttpProxy implementation of DataProxy#doRequest</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="getConnection" scope="instance"><description>Return the Ext.data.Connection object being used by this Proxy.</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="isApiAction" scope="instance"><description>Returns true if the specified action is defined as a unique action in the api-config.
request.  If all API-actions are routed to unique urls, the xaction parameter is unecessary.  However, if no api is defined
and all Proxy actions are routed to DataProxy#url, the server-side will require the xaction parameter to perform a switch to
the corresponding code for CRUD action.</description></method><method name="load" scope="instance"><description>Deprecated load method using old method signature. See {@doRequest} for preferred method.</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="onRead" scope="instance"><description>Callback for read action</description></method><method name="onWrite" scope="instance"><description>Callback for write actions</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="request" scope="instance"><description>All proxy actions are executed through this method.  Automatically fires the &quot;before&quot; + action event</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setApi" scope="instance"><description>Redefines the Proxy's API or a single action of an API. Can be called with two method signatures.
If called with an object as the only parameter, the object should redefine the entire API, e.g.:proxy.setApi({
    read    : '/users/read',
    create  : '/users/create',
    update  : '/users/update',
    destroy : '/users/destroy'
});
If called with two parameters, the first parameter should be a string specifying the API action to
redefine and the second parameter should be the URL (or function if using DirectProxy) to call for that action, e.g.:proxy.setApi(Ext.data.Api.actions.read, '/users/new_load_url');</description></method><method name="setUrl" scope="instance"><description>Used for overriding the url used for a single request.  Designed to be called during a beforeaction event.  Calling setUrl
will override any urls set via the api configuration parameter.  Set the optional parameter makePermanent to set the url for
all subsequent requests.  If not set to makePermanent, the next request will use the same url or api configuration defined
in the initial proxy configuration.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method></methods></class><class superclass="Ext.menu.BaseItem" type="Ext.menu.Separator"><description>Adds a separator bar to a menu, used to divide logical groups of menu items. Generally you will
add one of these by using &quot;-&quot; in you call to add() or in your items config rather than creating one directly.</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHandler" scope="instance"><description>Sets the function that will handle click events for this item (equivalent to passing in the handler
config property).  If an existing handler is already registered, it will be unregistered for you.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method></methods></class><class superclass="Ext.util.Observable" type="Ext.Resizable"><description>Applies drag handles to an element to make it resizable. The drag handles are inserted into the element
and positioned absolute. Some elements, such as a textarea or image, don't support this. To overcome that, you can wrap
the textarea in a div and set 'resizeChild' to true (or to the id of the element), or set wrap:true in your config and
the element will be wrapped for you automatically.
Here is the list of valid resize handles:

Value   Description
------  -------------------
 'n'     north
 's'     south
 'e'     east
 'w'     west
 'nw'    northwest
 'sw'    southwest
 'se'    southeast
 'ne'    northeast
 'all'   all

Here's an example showing the creation of a typical Resizable:
var resizer = new Ext.Resizable('element-id', {
    handles: 'all',
    minWidth: 200,
    minHeight: 100,
    maxWidth: 500,
    maxHeight: 400,
    pinned: true
});
resizer.on('resize', myHandler);
To hide a particular handle, set its display to none in CSS, or through script:
resizer.east.setDisplayed(false);</description><constructors/><properties/><methods><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="destroy" scope="instance"><description>Destroys this resizable. If the element was wrapped and
removeEl is not true then the element remains.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="getEl" scope="instance"><description>Returns the element this component is bound to.</description></method><method name="getResizeChild" scope="instance"><description>Returns the resizeChild element (or null).</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="resizeElement" scope="instance"><description>Performs resizing of the associated Element. This method is called internally by this
class, and should not be called by user code.
If a Resizable is being used to resize an Element which encapsulates a more complex UI
component such as a Panel, this method may be overridden by specifying an implementation
as a config option to provide appropriate behaviour at the end of the resize operation on
mouseup, for example resizing the Panel, and relaying the Panel's content.
The new area to be resized to is available by examining the state of the proxy
Element. Example:
new Ext.Panel({
    title: 'Resize me',
    x: 100,
    y: 100,
    renderTo: Ext.getBody(),
    floating: true,
    frame: true,
    width: 400,
    height: 200,
    listeners: {
        render: function(p) {
            new Ext.Resizable(p.getEl(), {
                handles: 'all',
                pinned: true,
                transparent: true,
                resizeElement: function() {
                    var box = this.proxy.getBox();
                    p.updateBox(box);
                    if (p.layout) {
                        p.doLayout();
                    }
                    return box;
                }
           });
       }
    }
}).show();</description></method><method name="resizeTo" scope="instance"><description>Perform a manual resize and fires the 'resize' event.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method></methods></class><class superclass="Ext.layout.BorderLayout.Region" type="Ext.layout.BorderLayout.SplitRegion"><description>This is a specialized type of BorderLayout region that
has a built-in Ext.SplitBar for user resizing of regions.  The movement of the split bar
is configurable to move either smooth or incrementally.</description><constructors/><properties/><methods><method name="getMargins" scope="instance"><description>Returns the current margins for this region.  If the region is collapsed, the
cmargins (collapsed margins) value will be returned, otherwise the
margins value will be returned.</description></method><method name="getMinHeight" scope="instance"><description>Returns the minimum allowable height for this region.</description></method><method name="getMinWidth" scope="instance"><description>Returns the minimum allowable width for this region.</description></method><method name="getSize" scope="instance"><description>Returns the current size of this region.  If the region is collapsed, the size of the
collapsedEl will be returned, otherwise the size of the region's panel will be returned.</description></method><method name="getSplitBar" scope="instance"><description>Returns a reference to the split bar in use by this region.</description></method><method name="isVisible" scope="instance"><description>True if this region is currently visible, else false.</description></method><method name="setPanel" scope="instance"><description>Sets the specified panel as the container element for this region.</description></method><method name="slideIn" scope="instance"><description>If this Region is floatable, and this Region has been slid into floating visibility, then this method slides
this region back into its collapsed state.</description></method><method name="slideOut" scope="instance"><description>If this Region is floatable, this method slides this Region into full visibility over the top
of the center Region where it floats until either slideIn is called, or other regions of the layout
are clicked, or the mouse exits the Region.</description></method></methods></class><class superclass="Object" type="Function"><description>These functions are available on every Function object (any JavaScript function).</description><constructors/><properties/><methods><method name="createCallback" scope="instance"><description>Creates a callback that passes arguments[0], arguments[1], arguments[2], ...
Call directly on any function. Example: myFunction.createCallback(arg1, arg2)
Will create a function that is bound to those 2 args. If a specific scope is required in the
callback, use createDelegate instead. The function returned by createCallback always
executes in the window scope.
This method is required when you want to pass arguments to a callback function.  If no arguments
are needed, you can simply pass a reference to the function as a callback (e.g., callback: myFn).
However, if you tried to pass a function with arguments (e.g., callback: myFn(arg1, arg2)) the function
would simply execute immediately when the code is parsed. Example usage:
var sayHi = function(name){
    alert('Hi, ' + name);
}

// clicking the button alerts &quot;Hi, Fred&quot;
new Ext.Button({
    text: 'Say Hi',
    renderTo: Ext.getBody(),
    handler: sayHi.createCallback('Fred')
});</description></method><method name="createDelegate" scope="instance"><description>Creates a delegate (callback) that sets the scope to obj.
Call directly on any function. Example: this.myFunction.createDelegate(this, [arg1, arg2])
Will create a function that is automatically scoped to obj so that the this variable inside the
callback points to obj. Example usage:
var sayHi = function(name){
    // Note this use of &quot;this.text&quot; here.  This function expects to
    // execute within a scope that contains a text property.  In this
    // example, the &quot;this&quot; variable is pointing to the btn object that
    // was passed in createDelegate below.
    alert('Hi, ' + name + '. You clicked the &quot;' + this.text + '&quot; button.');
}

var btn = new Ext.Button({
    text: 'Say Hi',
    renderTo: Ext.getBody()
});

// This callback will execute in the scope of the
// button instance. Clicking the button alerts
// &quot;Hi, Fred. You clicked the &quot;Say Hi&quot; button.&quot;
btn.on('click', sayHi.createDelegate(btn, ['Fred']));</description></method><method name="createInterceptor" scope="instance"><description>Creates an interceptor function. The passed function is called before the original one. If it returns false,
the original one is not called. The resulting function returns the results of the original function.
The passed function is called with the parameters of the original function. Example usage:
var sayHi = function(name){
    alert('Hi, ' + name);
}

sayHi('Fred'); // alerts &quot;Hi, Fred&quot;

// create a new function that validates input without
// directly modifying the original function:
var sayHiToFriend = sayHi.createInterceptor(function(name){
    return name == 'Brian';
});

sayHiToFriend('Fred');  // no alert
sayHiToFriend('Brian'); // alerts &quot;Hi, Brian&quot;</description></method><method name="createSequence" scope="instance"><description>Create a combined function call sequence of the original function + the passed function.
The resulting function returns the results of the original function.
The passed fcn is called with the parameters of the original function. Example usage:
var sayHi = function(name){
    alert('Hi, ' + name);
}

sayHi('Fred'); // alerts &quot;Hi, Fred&quot;

var sayGoodbye = sayHi.createSequence(function(name){
    alert('Bye, ' + name);
});

sayGoodbye('Fred'); // both alerts show</description></method><method name="defer" scope="instance"><description>Calls this function after the number of millseconds specified, optionally in a specific scope. Example usage:
var sayHi = function(name){
    alert('Hi, ' + name);
}

// executes immediately:
sayHi('Fred');

// executes after 2 seconds:
sayHi.defer(2000, this, ['Fred']);

// this syntax is sometimes useful for deferring
// execution of an anonymous function:
(function(){
    alert('Anonymous');
}).defer(100);</description></method></methods></class><class superclass="Ext.BoxComponent" type="Ext.DataView"><description>A mechanism for displaying data using custom layout templates and formatting. DataView uses an Ext.XTemplate
as its internal templating mechanism, and is bound to an Ext.data.Store
so that as the data in the store changes the view is automatically updated to reflect the changes.  The view also
provides built-in behavior for many common events that can occur for its contained items including click, doubleclick,
mouseover, mouseout, etc. as well as a built-in selection model. In order to use these features, an itemSelector
config must be provided for the DataView to determine what nodes it will be working with.
The example below binds a DataView to a Ext.data.Store and renders it into an Ext.Panel.
var store = new Ext.data.JsonStore({
    url: 'get-images.php',
    root: 'images',
    fields: [
        'name', 'url',
        {name:'size', type: 'float'},
        {name:'lastmod', type:'date', dateFormat:'timestamp'}
    ]
});
store.load();

var tpl = new Ext.XTemplate(
    '&lt;tpl for=&quot;.&quot;&gt;',
        '&lt;div class=&quot;thumb-wrap&quot; id=&quot;{name}&quot;&gt;',
        '&lt;div class=&quot;thumb&quot;&gt;&lt;img src=&quot;{url}&quot; title=&quot;{name}&quot;&gt;&lt;/div&gt;',
        '&lt;span class=&quot;x-editable&quot;&gt;{shortName}&lt;/span&gt;&lt;/div&gt;',
    '&lt;/tpl&gt;',
    '&lt;div class=&quot;x-clear&quot;&gt;&lt;/div&gt;'
);

var panel = new Ext.Panel({
    id:'images-view',
    frame:true,
    width:535,
    autoHeight:true,
    collapsible:true,
    layout:'fit',
    title:'Simple DataView',

    items: new Ext.DataView({
        store: store,
        tpl: tpl,
        autoHeight:true,
        multiSelect: true,
        overClass:'x-view-over',
        itemSelector:'div.thumb-wrap',
        emptyText: 'No images to display'
    })
});
panel.render(document.body);</description><constructors/><properties/><methods><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="applyToMarkup" scope="instance"><description>Apply this component to existing markup that is valid. With this function, no call to render() is required.</description></method><method name="bindStore" scope="instance"><description>Changes the data store bound to this view and refreshes it.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="clearSelections" scope="instance"><description>Clears all selections.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="collectData" scope="instance"><description>Function which can be overridden which returns the data object passed to this
DataView's template to render the whole DataView.
This is usually an Array of data objects, each element of which is processed by an
XTemplate which uses '&lt;tpl for=&quot;.&quot;&gt;' to iterate over its supplied
data object as an Array. However, named properties may be placed into the data object to
provide non-repeating data such as headings, totals etc.</description></method><method name="deselect" scope="instance"><description>Deselects a node.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="disable" scope="instance"><description>Disable this component and fire the 'disable' event.</description></method><method name="enable" scope="instance"><description>Enable this component and fire the 'enable' event.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="findItemFromChild" scope="instance"><description>Returns the template node the passed child belongs to, or null if it doesn't belong to one.</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getNode" scope="instance"><description>Gets a template node.</description></method><method name="getNodes" scope="instance"><description>Gets a range nodes.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getRecord" scope="instance"><description>Gets a record from a node</description></method><method name="getRecords" scope="instance"><description>Gets an array of the records from an array of nodes</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSelectedIndexes" scope="instance"><description>Gets the indexes of the selected nodes.</description></method><method name="getSelectedNodes" scope="instance"><description>Gets the currently selected nodes.</description></method><method name="getSelectedRecords" scope="instance"><description>Gets an array of the selected records</description></method><method name="getSelectionCount" scope="instance"><description>Gets the number of selected nodes.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getStore" scope="instance"><description>Returns the store associated with this DataView.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="indexOf" scope="instance"><description>Finds the index of the passed node.</description></method><method name="isSelected" scope="instance"><description>Returns true if the passed node is selected, else false.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="prepareData" scope="instance"><description>Function which can be overridden to provide custom formatting for each Record that is used by this
DataView's template to render each node.</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="refresh" scope="instance"><description>Refreshes the view by reloading the data from the store and re-rendering the template.</description></method><method name="refreshNode" scope="instance"><description>Refreshes an individual node's data from the store.</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="select" scope="instance"><description>Selects a set of nodes.</description></method><method name="selectRange" scope="instance"><description>Selects a range of nodes. All nodes between start and end are selected.</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setDisabled" scope="instance"><description>Convenience function for setting disabled/enabled by boolean.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setStore" scope="instance"><description>Changes the data store bound to this view and refreshes it. (deprecated in favor of bindStore)</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method></methods></class><class superclass="Object" type="Ext.WindowGroup"><description>An object that manages a group of Ext.Window instances and provides z-order management
and window activation behavior.</description><constructors/><properties/><methods><method name="bringToFront" scope="instance"><description>Brings the specified window to the front of any other active windows in this WindowGroup.</description></method><method name="each" scope="instance"><description>Executes the specified function once for every window in this WindowGroup, passing each
window as the only parameter. Returning false from the function will stop the iteration.</description></method><method name="get" scope="instance"><description>Gets a registered window by id.</description></method><method name="getActive" scope="instance"><description>Gets the currently-active window in this WindowGroup.</description></method><method name="getBy" scope="instance"><description>Returns zero or more windows in this WindowGroup using the custom search function passed to this method.
The function should accept a single Ext.Window reference as its only argument and should
return true if the window matches the search criteria, otherwise it should return false.</description></method><method name="hideAll" scope="instance"><description>Hides all windows in this WindowGroup.</description></method><method name="register" scope="instance"><description>Registers a Window with this WindowManager. This should not
need to be called under normal circumstances. Windows are automatically registered
with a manager at construction time.
Where this may be useful is moving Windows between two WindowManagers. For example,
to bring the Ext.MessageBox dialog under the same manager as the Desktop's
WindowManager in the desktop sample app:
var msgWin = Ext.MessageBox.getDialog();
MyDesktop.getDesktop().getManager().register(msgWin);
</description></method><method name="sendToBack" scope="instance"><description>Sends the specified window to the back of other active windows in this WindowGroup.</description></method><method name="unregister" scope="instance"><description>Unregisters a Window from this WindowManager. This should not
need to be called. Windows are automatically unregistered upon destruction.
See register.</description></method></methods></class><class superclass="Ext.util.Observable" type="Ext.data.Tree"><description>Represents a tree data structure and bubbles all the events for its nodes. The nodes
in the tree have most standard DOM functionality.</description><constructors/><properties/><methods><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="getNodeById" scope="instance"><description>Gets a node in this tree by its id.</description></method><method name="getRootNode" scope="instance"><description>Returns the root node for this tree.</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setRootNode" scope="instance"><description>Sets the root node for this tree.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method></methods></class><class superclass="Object" type="Ext.LoadMask"><description>A simple utility class for generically masking elements while loading data.  If the store
config option is specified, the masking will be automatically synchronized with the store's loading
process and the mask element will be cached for reuse.  For all other elements, this mask will replace the
element's Updater load indicator and will be destroyed after the initial load.
Example usage:
// Basic mask:
var myMask = new Ext.LoadMask(Ext.getBody(), {msg:&quot;Please wait...&quot;});
myMask.show();</description><constructors/><properties/><methods><method name="disable" scope="instance"><description>Disables the mask to prevent it from being displayed</description></method><method name="enable" scope="instance"><description>Enables the mask so that it can be displayed</description></method><method name="hide" scope="instance"><description>Hide this LoadMask.</description></method><method name="show" scope="instance"><description>Show this LoadMask over the configured Element.</description></method></methods></class><class superclass="Object" type="Ext.SplitBar.BasicLayoutAdapter"><description>Default Adapter. It assumes the splitter and resizing element are not positioned
elements and only gets/sets the width of the element. Generally used for table based layouts.</description><constructors/><properties/><methods><method name="getElementSize" scope="instance"><description>Called before drag operations to get the current size of the resizing element.</description></method><method name="setElementSize" scope="instance"><description>Called after drag operations to set the size of the resizing element.</description></method></methods></class><class superclass="Ext.Panel" type="Ext.grid.GridPanel"><description>This class represents the primary interface of a component based grid control to represent data
in a tabular format of rows and columns. The GridPanel is composed of the following:

Store : The Model holding the data records (rows)

Column model : Column makeup

View : Encapsulates the user interface

selection model : Selection behavior


Example usage:
var grid = new Ext.grid.GridPanel({
    store: new Ext.data.Store({
        autoDestroy: true,
        reader: reader,
        data: xg.dummyData
    }),
    colModel: new Ext.grid.ColumnModel({
        defaults: {
            width: 120,
            sortable: true
        },
        columns: [
            {id: 'company', header: 'Company', width: 200, sortable: true, dataIndex: 'company'},
            {header: 'Price', renderer: Ext.util.Format.usMoney, dataIndex: 'price'},
            {header: 'Change', dataIndex: 'change'},
            {header: '% Change', dataIndex: 'pctChange'},
            // instead of specifying renderer: Ext.util.Format.dateRenderer('m/d/Y') use xtype
            {
                header: 'Last Updated', width: 135, dataIndex: 'lastChange',
                xtype: 'datecolumn', format: 'M d, Y'
            }
        ],
    }),
    viewConfig: {
        forceFit: true,

//      Return CSS class to apply to rows depending upon data values
        getRowClass: function(record, index) {
            var c = record.get('change');
            if (c &lt; 0) {
                return 'price-fall';
            } else if (c &gt; 0) {
                return 'price-rise';
            }
        }
    },
    sm: new Ext.grid.RowSelectionModel({singleSelect:true}),
    width: 600,
    height: 300,
    frame: true,
    title: 'Framed with Row Selection and Horizontal Scrolling',
    iconCls: 'icon-grid'
});
Notes:

Although this class inherits many configuration options from base classes, some of them
(such as autoScroll, autoWidth, layout, items, etc) are not used by this class, and will
have no effect.
A grid requires a width in which to scroll its columns, and a height in which to
scroll its rows. These dimensions can either be set explicitly through the
height and width
configuration options or implicitly set by using the grid as a child item of a
Container which will have a layout manager
provide the sizing of its child items (for example the Container of the Grid may specify
layout:'fit').
To access the data in a Grid, it is necessary to use the data model encapsulated
by the Store. See the cellclick event for more details.
</description><constructors/><properties/><methods><method name="addButton" scope="instance"><description>Adds a button to this panel.  Note that this method must be called prior to rendering.  The preferred
approach is to add buttons via the buttons config.</description></method><method name="addClass" scope="instance"><description>Adds a CSS class to the component's underlying element.</description></method><method name="addEvents" scope="instance"><description>Adds the specified events to the list of events which this Observable may fire.</description></method><method name="addListener" scope="instance"><description>Appends an event handler to this object.</description></method><method name="bubble" scope="instance"><description>Bubbles up the component/container heirarchy, calling the specified function with each component. The scope (this) of
function call will be the scope provided or the current component. The arguments to the function
will be the args provided or the current component. If the function returns false at any point,
the bubble is stopped.</description></method><method name="cloneConfig" scope="instance"><description>Clone the current component using the original config values passed into this instance by default.</description></method><method name="collapse" scope="instance"><description>Collapses the panel body so that it becomes hidden.  Fires the beforecollapse event which will
cancel the collapse action if it returns false.</description></method><method name="destroy" scope="instance"><description>Destroys this component by purging any event listeners, removing the component's element from the DOM,
removing the component from its Ext.Container (if applicable) and unregistering it from
Ext.ComponentMgr.  Destruction is generally handled automatically by the framework and this method
should usually not need to be called directly.</description></method><method name="enableBubble" scope="instance"><description>Enables events fired by this Observable to bubble up an owner hierarchy by calling
this.getBubbleTarget() if present. There is no implementation in the Observable base class.
This is commonly used by Ext.Components to bubble events to owner Containers. See Ext.Component.getBubbleTarget. The default
implementation in Ext.Component returns the Component's immediate owner. But if a known target is required, this can be overridden to
access the required target more quickly.
Example:Ext.override(Ext.form.Field, {
    //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
    initComponent : Ext.form.Field.prototype.initComponent.createSequence(function() {
        this.enableBubble('change');
    }),

    //  We know that we want Field&#39;s events to bubble directly to the FormPanel.
    getBubbleTarget : function() {
        if (!this.formPanel) {
            this.formPanel = this.findParentByType('form');
        }
        return this.formPanel;
    }
});

var myForm = new Ext.formPanel({
    title: 'User Details',
    items: [{
        ...
    }],
    listeners: {
        change: function() {
            // Title goes red if form has been modified.
            myForm.header.setStyle('color', 'red');
        }
    }
});</description></method><method name="expand" scope="instance"><description>Expands the panel body so that it becomes visible.  Fires the beforeexpand event which will
cancel the expand action if it returns false.</description></method><method name="findParentBy" scope="instance"><description>Find a container above this component at any level by a custom function. If the passed function returns
true, the container will be returned.</description></method><method name="findParentByType" scope="instance"><description>Find a container above this component at any level by xtype or class</description></method><method name="fireEvent" scope="instance"><description>Fires the specified event with the passed parameters (minus the event name).
An event may be set to bubble up an Observable parent hierarchy (See Ext.Component.getBubbleTarget)
by calling enableBubble.</description></method><method name="focus" scope="instance"><description>Try to focus this component.</description></method><method name="get" scope="instance"><description>Get a component contained by this container (alias for items.get(key))</description></method><method name="getBottomToolbar" scope="instance"><description>Returns the toolbar from the bottom (bbar) section of the panel.</description></method><method name="getBox" scope="instance"><description>Gets the current box measurements of the component's underlying element.</description></method><method name="getBubbleTarget" scope="instance"><description>Provides the link for Observable's fireEvent method to bubble up the ownership hierarchy.</description></method><method name="getColumnModel" scope="instance"><description>Returns the grid's ColumnModel.</description></method><method name="getDragDropText" scope="instance"><description>Called to get grid's drag proxy text, by default returns this.ddText.</description></method><method name="getEl" scope="instance"><description>Returns the Ext.Element which encapsulates this Component.
This will usually be a &lt;DIV&gt; element created by the class's onRender method, but
that may be overridden using the autoEl config.
Note: this element will not be available until this Component has been rendered.
To add listeners for DOM events to this Component (as opposed to listeners
for this Component's own Observable events), see the listeners config for a suggestion,
or use a render listener directly:new Ext.Panel({
    title: 'The Clickable Panel',
    listeners: {
        render: function(p) {
            // Append the Panel to the click handler&#39;s argument list.
            p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
        },
        single: true  // Remove the listener after first invocation
    }
});</description></method><method name="getFooterToolbar" scope="instance"><description>Returns the toolbar from the footer (fbar) section of the panel.</description></method><method name="getFrameHeight" scope="instance"><description>Returns the height in pixels of the framing elements of this panel (including any top and bottom bars and
header and footer elements, but not including the body height).  To retrieve the body height see getInnerHeight.</description></method><method name="getFrameWidth" scope="instance"><description>Returns the width in pixels of the framing elements of this panel (not including the body width).  To
retrieve the body width see getInnerWidth.</description></method><method name="getGridEl" scope="instance"><description>Returns the grid's underlying element.</description></method><method name="getHeight" scope="instance"><description>Gets the current height of the component's underlying element.</description></method><method name="getId" scope="instance"><description>Returns the id of this component or automatically generates and
returns an id if an id is not defined yet:'ext-comp-' + (++Ext.Component.AUTO_ID)</description></method><method name="getInnerHeight" scope="instance"><description>Returns the height in pixels of the body element (not including the height of any framing elements).
For the frame height see getFrameHeight.</description></method><method name="getInnerWidth" scope="instance"><description>Returns the width in pixels of the body element (not including the width of any framing elements).
For the frame width see getFrameWidth.</description></method><method name="getItemId" scope="instance"><description>Returns the itemId of this component.  If an
itemId was not assigned through configuration the
id is returned using getId.</description></method><method name="getLayoutTarget" scope="instance"><description>Returns the Element to be used to contain the child Components of this Container.
An implementation is provided which returns the Container's Element, but
if there is a more complex structure to a Container, this may be overridden to return
the element into which the layout renders child Components.</description></method><method name="getOuterSize" scope="instance"><description>Gets the current size of the component's underlying element, including space taken by its margins.</description></method><method name="getPosition" scope="instance"><description>Gets the current XY position of the component's underlying element.</description></method><method name="getResizeEl" scope="instance"><description>Returns the outermost Element of this Component which defines the Components overall size.
Usually this will return the same Element as getEl,
but in some cases, a Component may have some more wrapping Elements around its main
active Element.
An example is a ComboBox. It is encased in a wrapping Element which
contains both the &lt;input&gt; Element (which is what would be returned
by its getEl method, and the trigger button Element.
This Element is returned as the resizeEl.</description></method><method name="getSelectionModel" scope="instance"><description>Returns the grid's selection model configured by the selModel
configuration option. If no selection model was configured, this will create
and return a RowSelectionModel.</description></method><method name="getSize" scope="instance"><description>Gets the current size of the component's underlying element.</description></method><method name="getStore" scope="instance"><description>Returns the grid's data store.</description></method><method name="getTool" scope="instance"><description>Retrieve a tool by id.</description></method><method name="getTopToolbar" scope="instance"><description>Returns the toolbar from the top (tbar) section of the panel.</description></method><method name="getView" scope="instance"><description>Returns the grid's GridView object.</description></method><method name="getWidth" scope="instance"><description>Gets the current width of the component's underlying element.</description></method><method name="getXType" scope="instance"><description>Gets the xtype for this component as registered with Ext.ComponentMgr. For a list of all
available xtypes, see the Ext.Component header. Example usage:
var t = new Ext.form.TextField();
alert(t.getXType());  // alerts 'textfield'</description></method><method name="getXTypes" scope="instance"><description>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the Ext.Component header.
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
Example usage:
var t = new Ext.form.TextField();
alert(t.getXTypes());  // alerts 'component/box/field/textfield'</description></method><method name="hasListener" scope="instance"><description>Checks to see if this object has any listeners for a specified event</description></method><method name="hide" scope="instance"><description>Hide this component.  Listen to the 'beforehide' event and return
false to cancel hiding the component.  Fires the 'hide'
event after hiding the component. Note this method is called internally if
the component is configured to be hidden.</description></method><method name="isVisible" scope="instance"><description>Returns true if this component is visible.</description></method><method name="isXType" scope="instance"><description>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
from the xtype (default) or whether it is directly of the xtype specified (shallow = true).
If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.
For a list of all available xtypes, see the Ext.Component header.
Example usage:
var t = new Ext.form.TextField();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('box');       // true, descended from BoxComponent
var isBoxInstance = t.isXType('box', true); // false, not a direct BoxComponent instance</description></method><method name="mon" scope="instance"><description>Adds listeners to any Observable object (or Elements) which are automatically removed when this Component
is destroyed. Usage:
myGridPanel.mon(myGridPanel.getSelectionModel(), 'selectionchange', handleSelectionChange, null, {buffer: 50});

or:
myGridPanel.mon(myGridPanel.getSelectionModel(), {
    selectionchange: handleSelectionChange,
    buffer: 50
});
</description></method><method name="mun" scope="instance"><description>Removes listeners that were added by the mon method.</description></method><method name="nextSibling" scope="instance"><description>Returns the next component in the owning container</description></method><method name="on" scope="instance"><description>Appends an event handler to this object (shorthand for addListener.)</description></method><method name="previousSibling" scope="instance"><description>Returns the previous component in the owning container</description></method><method name="purgeListeners" scope="instance"><description>Removes all listeners for this object</description></method><method name="reconfigure" scope="instance"><description>Reconfigures the grid to use a different Store and Column Model
and fires the 'reconfigure' event. The View will be bound to the new
objects and refreshed.
Be aware that upon reconfiguring a GridPanel, certain existing settings may become
invalidated. For example the configured autoExpandColumn may no longer exist in the
new ColumnModel. Also, an existing PagingToolbar will still be bound
to the old Store, and will need rebinding. Any plugins might also need reconfiguring
with the new data.</description></method><method name="relayEvents" scope="instance"><description>Relays selected events from the specified Observable as if the events were fired by this.</description></method><method name="removeAll" scope="instance"><description>Removes all components from this container.</description></method><method name="removeClass" scope="instance"><description>Removes a CSS class from the component's underlying element.</description></method><method name="removeListener" scope="instance"><description>Removes an event handler.</description></method><method name="render" scope="instance"><description>Render this Component into the passed HTML element.
If you are using a Container object to house this Component, then
do not use the render method.
A Container's child Components are rendered by that Container's
layout manager when the Container is first rendered.
Certain layout managers allow dynamic addition of child components. Those that do
include Ext.layout.CardLayout, Ext.layout.AnchorLayout,
Ext.layout.FormLayout, Ext.layout.TableLayout.
If the Container is already rendered when a new child Component is added, you may need to call
the Container's doLayout to refresh the view which causes any
unrendered child Components to be rendered. This is required so that you can add multiple
child components if needed while only refreshing the layout once.
When creating complex UIs, it is important to remember that sizing and positioning
of child items is the responsibility of the Container's layout manager.
If you expect child items to be sized in response to user interactions, you must
configure the Container with a layout manager which creates and manages the type of layout you
have in mind.
Omitting the Container's layout config means that a basic
layout manager is used which does nothing but render child components sequentially into the
Container. No sizing or positioning will be performed in this situation.</description></method><method name="resumeEvents" scope="instance"><description>Resume firing events. (see suspendEvents)
If events were suspended using the queueSuspended parameter, then all
events fired during event suspension will be sent to any listeners now.</description></method><method name="setAutoScroll" scope="instance"><description>Sets the overflow on the content element of the component.</description></method><method name="setHeight" scope="instance"><description>Sets the height of the component.  This method fires the resize event.</description></method><method name="setIconClass" scope="instance"><description>Sets the CSS class that provides the icon image for this panel.  This method will replace any existing
icon class if one has already been set and fire the iconchange event after completion.</description></method><method name="setPagePosition" scope="instance"><description>Sets the page XY position of the component.  To set the left and top instead, use setPosition.
This method fires the move event.</description></method><method name="setPosition" scope="instance"><description>Sets the left and top of the component.  To set the page XY position instead, use setPagePosition.
This method fires the move event.</description></method><method name="setSize" scope="instance"><description>Sets the width and height of this BoxComponent. This method fires the resize event. This method can accept
either width and height as separate arguments, or you can pass a size object like {width:10, height:20}.</description></method><method name="setTitle" scope="instance"><description>Sets the title text for the panel and optionally the icon class.
In order to be able to set the title, a header element must have been created
for the Panel. This is triggered either by configuring the Panel with a non-blank title,
or configuring it with header: true.</description></method><method name="setVisible" scope="instance"><description>Convenience function to hide or show this component by boolean.</description></method><method name="setWidth" scope="instance"><description>Sets the width of the component.  This method fires the resize event.</description></method><method name="show" scope="instance"><description>Show this component.  Listen to the 'beforeshow' event and return
false to cancel showing the component.  Fires the 'show'
event after showing the component.</description></method><method name="suspendEvents" scope="instance"><description>Suspend the firing of all events. (see resumeEvents)</description></method><method name="syncSize" scope="instance"><description>Force the component's size to recalculate based on the underlying element's current height and width.</description></method><method name="toggleCollapse" scope="instance"><description>Shortcut for performing an expand or collapse based on the current state of the panel.</description></method><method name="un" scope="instance"><description>Removes an event handler (shorthand for removeListener.)</description></method><method name="update" scope="instance"><description>Update the content area of a component.</description></method><method name="updateBox" scope="instance"><description>Sets the current box measurements of the component's underlying element.</description></method></methods></class></javascript>

